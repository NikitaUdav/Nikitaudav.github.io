var jquery351 = (function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var jquery3_5_1 = createCommonjsModule(function (module) {
	  /*!
	   * jQuery JavaScript Library v3.5.1
	   * https://jquery.com/
	   *
	   * Includes Sizzle.js
	   * https://sizzlejs.com/
	   *
	   * Copyright JS Foundation and other contributors
	   * Released under the MIT license
	   * https://jquery.org/license
	   *
	   * Date: 2020-05-04T22:49Z
	   */
	  (function (global, factory) {

	    {
	      // For CommonJS and CommonJS-like environments where a proper `window`
	      // is present, execute the factory and get jQuery.
	      // For environments that do not have a `window` with a `document`
	      // (such as Node.js), expose a factory as module.exports.
	      // This accentuates the need for the creation of a real `window`.
	      // e.g. var jQuery = require("jquery")(window);
	      // See ticket #14549 for more info.
	      module.exports = global.document ? factory(global, true) : function (w) {
	        if (!w.document) {
	          throw new Error("jQuery requires a window with a document");
	        }

	        return factory(w);
	      };
	    } // Pass this if window is not defined yet

	  })(typeof window !== "undefined" ? window : commonjsGlobal, function (window, noGlobal) {

	    var arr = [];
	    var getProto = Object.getPrototypeOf;
	    var slice = arr.slice;
	    var flat = arr.flat ? function (array) {
	      return arr.flat.call(array);
	    } : function (array) {
	      return arr.concat.apply([], array);
	    };
	    var push = arr.push;
	    var indexOf = arr.indexOf;
	    var class2type = {};
	    var toString = class2type.toString;
	    var hasOwn = class2type.hasOwnProperty;
	    var fnToString = hasOwn.toString;
	    var ObjectFunctionString = fnToString.call(Object);
	    var support = {};

	    var isFunction = function isFunction(obj) {
	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	    };

	    var isWindow = function isWindow(obj) {
	      return obj != null && obj === obj.window;
	    };

	    var document = window.document;
	    var preservedScriptAttributes = {
	      type: true,
	      src: true,
	      nonce: true,
	      noModule: true
	    };

	    function DOMEval(code, node, doc) {
	      doc = doc || document;
	      var i,
	          val,
	          script = doc.createElement("script");
	      script.text = code;

	      if (node) {
	        for (i in preservedScriptAttributes) {
	          // Support: Firefox 64+, Edge 18+
	          // Some browsers don't support the "nonce" property on scripts.
	          // On the other hand, just using `getAttribute` is not enough as
	          // the `nonce` attribute is reset to an empty string whenever it
	          // becomes browsing-context connected.
	          // See https://github.com/whatwg/html/issues/2369
	          // See https://html.spec.whatwg.org/#nonce-attributes
	          // The `node.getAttribute` check was added for the sake of
	          // `jQuery.globalEval` so that it can fake a nonce-containing node
	          // via an object.
	          val = node[i] || node.getAttribute && node.getAttribute(i);

	          if (val) {
	            script.setAttribute(i, val);
	          }
	        }
	      }

	      doc.head.appendChild(script).parentNode.removeChild(script);
	    }

	    function toType(obj) {
	      if (obj == null) {
	        return obj + "";
	      } // Support: Android <=2.3 only (functionish RegExp)


	      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
	    }
	    /* global Symbol */
	    // Defining this global in .eslintrc.json would create a danger of using the global
	    // unguarded in another place, it seems safer to define global only for this module


	    var version = "3.5.1",
	        // Define a local copy of jQuery
	    jQuery = function (selector, context) {
	      // The jQuery object is actually just the init constructor 'enhanced'
	      // Need init if jQuery is called (just allow error to be thrown if not included)
	      return new jQuery.fn.init(selector, context);
	    };

	    jQuery.fn = jQuery.prototype = {
	      // The current version of jQuery being used
	      jquery: version,
	      constructor: jQuery,
	      // The default length of a jQuery object is 0
	      length: 0,
	      toArray: function () {
	        return slice.call(this);
	      },
	      // Get the Nth element in the matched element set OR
	      // Get the whole matched element set as a clean array
	      get: function (num) {
	        // Return all the elements in a clean array
	        if (num == null) {
	          return slice.call(this);
	        } // Return just the one element from the set


	        return num < 0 ? this[num + this.length] : this[num];
	      },
	      // Take an array of elements and push it onto the stack
	      // (returning the new matched element set)
	      pushStack: function (elems) {
	        // Build a new jQuery matched element set
	        var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

	        ret.prevObject = this; // Return the newly-formed element set

	        return ret;
	      },
	      // Execute a callback for every element in the matched set.
	      each: function (callback) {
	        return jQuery.each(this, callback);
	      },
	      map: function (callback) {
	        return this.pushStack(jQuery.map(this, function (elem, i) {
	          return callback.call(elem, i, elem);
	        }));
	      },
	      slice: function () {
	        return this.pushStack(slice.apply(this, arguments));
	      },
	      first: function () {
	        return this.eq(0);
	      },
	      last: function () {
	        return this.eq(-1);
	      },
	      even: function () {
	        return this.pushStack(jQuery.grep(this, function (_elem, i) {
	          return (i + 1) % 2;
	        }));
	      },
	      odd: function () {
	        return this.pushStack(jQuery.grep(this, function (_elem, i) {
	          return i % 2;
	        }));
	      },
	      eq: function (i) {
	        var len = this.length,
	            j = +i + (i < 0 ? len : 0);
	        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
	      },
	      end: function () {
	        return this.prevObject || this.constructor();
	      },
	      // For internal use only.
	      // Behaves like an Array's method, not like a jQuery method.
	      push: push,
	      sort: arr.sort,
	      splice: arr.splice
	    };

	    jQuery.extend = jQuery.fn.extend = function () {
	      var options,
	          name,
	          src,
	          copy,
	          copyIsArray,
	          clone,
	          target = arguments[0] || {},
	          i = 1,
	          length = arguments.length,
	          deep = false; // Handle a deep copy situation

	      if (typeof target === "boolean") {
	        deep = target; // Skip the boolean and the target

	        target = arguments[i] || {};
	        i++;
	      } // Handle case when target is a string or something (possible in deep copy)


	      if (typeof target !== "object" && !isFunction(target)) {
	        target = {};
	      } // Extend jQuery itself if only one argument is passed


	      if (i === length) {
	        target = this;
	        i--;
	      }

	      for (; i < length; i++) {
	        // Only deal with non-null/undefined values
	        if ((options = arguments[i]) != null) {
	          // Extend the base object
	          for (name in options) {
	            copy = options[name]; // Prevent Object.prototype pollution
	            // Prevent never-ending loop

	            if (name === "__proto__" || target === copy) {
	              continue;
	            } // Recurse if we're merging plain objects or arrays


	            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
	              src = target[name]; // Ensure proper type for the source value

	              if (copyIsArray && !Array.isArray(src)) {
	                clone = [];
	              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
	                clone = {};
	              } else {
	                clone = src;
	              }

	              copyIsArray = false; // Never move original objects, clone them

	              target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
	            } else if (copy !== undefined) {
	              target[name] = copy;
	            }
	          }
	        }
	      } // Return the modified object


	      return target;
	    };

	    jQuery.extend({
	      // Unique for each copy of jQuery on the page
	      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
	      // Assume jQuery is ready without the ready module
	      isReady: true,
	      error: function (msg) {
	        throw new Error(msg);
	      },
	      noop: function () {},
	      isPlainObject: function (obj) {
	        var proto, Ctor; // Detect obvious negatives
	        // Use toString instead of jQuery.type to catch host objects

	        if (!obj || toString.call(obj) !== "[object Object]") {
	          return false;
	        }

	        proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

	        if (!proto) {
	          return true;
	        } // Objects with prototype are plain iff they were constructed by a global Object function


	        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
	        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
	      },
	      isEmptyObject: function (obj) {
	        var name;

	        for (name in obj) {
	          return false;
	        }

	        return true;
	      },
	      // Evaluates a script in a provided context; falls back to the global one
	      // if not specified.
	      globalEval: function (code, options, doc) {
	        DOMEval(code, {
	          nonce: options && options.nonce
	        }, doc);
	      },
	      each: function (obj, callback) {
	        var length,
	            i = 0;

	        if (isArrayLike(obj)) {
	          length = obj.length;

	          for (; i < length; i++) {
	            if (callback.call(obj[i], i, obj[i]) === false) {
	              break;
	            }
	          }
	        } else {
	          for (i in obj) {
	            if (callback.call(obj[i], i, obj[i]) === false) {
	              break;
	            }
	          }
	        }

	        return obj;
	      },
	      // results is for internal usage only
	      makeArray: function (arr, results) {
	        var ret = results || [];

	        if (arr != null) {
	          if (isArrayLike(Object(arr))) {
	            jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
	          } else {
	            push.call(ret, arr);
	          }
	        }

	        return ret;
	      },
	      inArray: function (elem, arr, i) {
	        return arr == null ? -1 : indexOf.call(arr, elem, i);
	      },
	      // Support: Android <=4.0 only, PhantomJS 1 only
	      // push.apply(_, arraylike) throws on ancient WebKit
	      merge: function (first, second) {
	        var len = +second.length,
	            j = 0,
	            i = first.length;

	        for (; j < len; j++) {
	          first[i++] = second[j];
	        }

	        first.length = i;
	        return first;
	      },
	      grep: function (elems, callback, invert) {
	        var callbackInverse,
	            matches = [],
	            i = 0,
	            length = elems.length,
	            callbackExpect = !invert; // Go through the array, only saving the items
	        // that pass the validator function

	        for (; i < length; i++) {
	          callbackInverse = !callback(elems[i], i);

	          if (callbackInverse !== callbackExpect) {
	            matches.push(elems[i]);
	          }
	        }

	        return matches;
	      },
	      // arg is for internal usage only
	      map: function (elems, callback, arg) {
	        var length,
	            value,
	            i = 0,
	            ret = []; // Go through the array, translating each of the items to their new values

	        if (isArrayLike(elems)) {
	          length = elems.length;

	          for (; i < length; i++) {
	            value = callback(elems[i], i, arg);

	            if (value != null) {
	              ret.push(value);
	            }
	          } // Go through every key on the object,

	        } else {
	          for (i in elems) {
	            value = callback(elems[i], i, arg);

	            if (value != null) {
	              ret.push(value);
	            }
	          }
	        } // Flatten any nested arrays


	        return flat(ret);
	      },
	      // A global GUID counter for objects
	      guid: 1,
	      // jQuery.support is not used in Core but other projects attach their
	      // properties to it so it needs to exist.
	      support: support
	    });

	    if (typeof Symbol === "function") {
	      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	    } // Populate the class2type map


	    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
	      class2type["[object " + name + "]"] = name.toLowerCase();
	    });

	    function isArrayLike(obj) {
	      // Support: real iOS 8.2 only (not reproducible in simulator)
	      // `in` check used to prevent JIT error (gh-2145)
	      // hasOwn isn't used here due to false negatives
	      // regarding Nodelist length in IE
	      var length = !!obj && "length" in obj && obj.length,
	          type = toType(obj);

	      if (isFunction(obj) || isWindow(obj)) {
	        return false;
	      }

	      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	    }

	    var Sizzle =
	    /*!
	     * Sizzle CSS Selector Engine v2.3.5
	     * https://sizzlejs.com/
	     *
	     * Copyright JS Foundation and other contributors
	     * Released under the MIT license
	     * https://js.foundation/
	     *
	     * Date: 2020-03-14
	     */
	    function (window) {
	      var i,
	          support,
	          Expr,
	          getText,
	          isXML,
	          tokenize,
	          compile,
	          select,
	          outermostContext,
	          sortInput,
	          hasDuplicate,
	          // Local document vars
	      setDocument,
	          document,
	          docElem,
	          documentIsHTML,
	          rbuggyQSA,
	          rbuggyMatches,
	          matches,
	          contains,
	          // Instance-specific data
	      expando = "sizzle" + 1 * new Date(),
	          preferredDoc = window.document,
	          dirruns = 0,
	          done = 0,
	          classCache = createCache(),
	          tokenCache = createCache(),
	          compilerCache = createCache(),
	          nonnativeSelectorCache = createCache(),
	          sortOrder = function (a, b) {
	        if (a === b) {
	          hasDuplicate = true;
	        }

	        return 0;
	      },
	          // Instance methods
	      hasOwn = {}.hasOwnProperty,
	          arr = [],
	          pop = arr.pop,
	          pushNative = arr.push,
	          push = arr.push,
	          slice = arr.slice,
	          // Use a stripped-down indexOf as it's faster than native
	      // https://jsperf.com/thor-indexof-vs-for/5
	      indexOf = function (list, elem) {
	        var i = 0,
	            len = list.length;

	        for (; i < len; i++) {
	          if (list[i] === elem) {
	            return i;
	          }
	        }

	        return -1;
	      },
	          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
	          // Regular expressions
	      // http://www.w3.org/TR/css3-selectors/#whitespace
	      whitespace = "[\\x20\\t\\r\\n\\f]",
	          // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	      identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
	          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
	      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
	      // or strings [capture 3 or capture 4]"
	      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
	          pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	      // 1. quoted (capture 3; capture 4 or capture 5)
	      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
	      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
	      ".*" + ")\\)|)",
	          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	      rwhitespace = new RegExp(whitespace + "+", "g"),
	          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
	          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
	          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
	          rdescend = new RegExp(whitespace + "|>"),
	          rpseudo = new RegExp(pseudos),
	          ridentifier = new RegExp("^" + identifier + "$"),
	          matchExpr = {
	        ID: new RegExp("^#(" + identifier + ")"),
	        CLASS: new RegExp("^\\.(" + identifier + ")"),
	        TAG: new RegExp("^(" + identifier + "|[*])"),
	        ATTR: new RegExp("^" + attributes),
	        PSEUDO: new RegExp("^" + pseudos),
	        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
	        bool: new RegExp("^(?:" + booleans + ")$", "i"),
	        // For use in libraries implementing .is()
	        // We use this for POS matching in `select`
	        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
	      },
	          rhtml = /HTML$/i,
	          rinputs = /^(?:input|select|textarea|button)$/i,
	          rheader = /^h\d$/i,
	          rnative = /^[^{]+\{\s*\[native \w/,
	          // Easily-parseable/retrievable ID or TAG or CLASS selectors
	      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	          rsibling = /[+~]/,
	          // CSS escapes
	      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	      runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
	          funescape = function (escape, nonHex) {
	        var high = "0x" + escape.slice(1) - 0x10000;
	        return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
	        nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
	        // Support: IE <=11+
	        // For values outside the Basic Multilingual Plane (BMP), manually construct a
	        // surrogate pair
	        high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
	      },
	          // CSS string/identifier serialization
	      // https://drafts.csswg.org/cssom/#common-serializing-idioms
	      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	          fcssescape = function (ch, asCodePoint) {
	        if (asCodePoint) {
	          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
	          if (ch === "\0") {
	            return "\uFFFD";
	          } // Control characters and (dependent upon position) numbers get escaped as code points


	          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
	        } // Other potentially-special ASCII characters get backslash-escaped


	        return "\\" + ch;
	      },
	          // Used for iframes
	      // See setDocument()
	      // Removing the function wrapper causes a "Permission Denied"
	      // error in IE
	      unloadHandler = function () {
	        setDocument();
	      },
	          inDisabledFieldset = addCombinator(function (elem) {
	        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
	      }, {
	        dir: "parentNode",
	        next: "legend"
	      }); // Optimize for push.apply( _, NodeList )


	      try {
	        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
	        // Detect silently failing push.apply
	        // eslint-disable-next-line no-unused-expressions

	        arr[preferredDoc.childNodes.length].nodeType;
	      } catch (e) {
	        push = {
	          apply: arr.length ? // Leverage slice if possible
	          function (target, els) {
	            pushNative.apply(target, slice.call(els));
	          } : // Support: IE<9
	          // Otherwise append directly
	          function (target, els) {
	            var j = target.length,
	                i = 0; // Can't trust NodeList.length

	            while (target[j++] = els[i++]) {}

	            target.length = j - 1;
	          }
	        };
	      }

	      function Sizzle(selector, context, results, seed) {
	        var m,
	            i,
	            elem,
	            nid,
	            match,
	            groups,
	            newSelector,
	            newContext = context && context.ownerDocument,
	            // nodeType defaults to 9, since context defaults to document
	        nodeType = context ? context.nodeType : 9;
	        results = results || []; // Return early from calls with invalid selector or context

	        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
	          return results;
	        } // Try to shortcut find operations (as opposed to filters) in HTML documents


	        if (!seed) {
	          setDocument(context);
	          context = context || document;

	          if (documentIsHTML) {
	            // If the selector is sufficiently simple, try using a "get*By*" DOM method
	            // (excepting DocumentFragment context, where the methods don't exist)
	            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
	              // ID selector
	              if (m = match[1]) {
	                // Document context
	                if (nodeType === 9) {
	                  if (elem = context.getElementById(m)) {
	                    // Support: IE, Opera, Webkit
	                    // TODO: identify versions
	                    // getElementById can match elements by name instead of ID
	                    if (elem.id === m) {
	                      results.push(elem);
	                      return results;
	                    }
	                  } else {
	                    return results;
	                  } // Element context

	                } else {
	                  // Support: IE, Opera, Webkit
	                  // TODO: identify versions
	                  // getElementById can match elements by name instead of ID
	                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
	                    results.push(elem);
	                    return results;
	                  }
	                } // Type selector

	              } else if (match[2]) {
	                push.apply(results, context.getElementsByTagName(selector));
	                return results; // Class selector
	              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
	                push.apply(results, context.getElementsByClassName(m));
	                return results;
	              }
	            } // Take advantage of querySelectorAll


	            if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
	            // Exclude object elements
	            nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
	              newSelector = selector;
	              newContext = context; // qSA considers elements outside a scoping root when evaluating child or
	              // descendant combinators, which is not what we want.
	              // In such cases, we work around the behavior by prefixing every selector in the
	              // list with an ID selector referencing the scope context.
	              // The technique has to be used as well when a leading combinator is used
	              // as such selectors are not recognized by querySelectorAll.
	              // Thanks to Andrew Dupont for this technique.

	              if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
	                // Expand context for sibling selectors
	                newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
	                // supports it & if we're not changing the context.

	                if (newContext !== context || !support.scope) {
	                  // Capture the context ID, setting it first if necessary
	                  if (nid = context.getAttribute("id")) {
	                    nid = nid.replace(rcssescape, fcssescape);
	                  } else {
	                    context.setAttribute("id", nid = expando);
	                  }
	                } // Prefix every selector in the list


	                groups = tokenize(selector);
	                i = groups.length;

	                while (i--) {
	                  groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
	                }

	                newSelector = groups.join(",");
	              }

	              try {
	                push.apply(results, newContext.querySelectorAll(newSelector));
	                return results;
	              } catch (qsaError) {
	                nonnativeSelectorCache(selector, true);
	              } finally {
	                if (nid === expando) {
	                  context.removeAttribute("id");
	                }
	              }
	            }
	          }
	        } // All others


	        return select(selector.replace(rtrim, "$1"), context, results, seed);
	      }
	      /**
	       * Create key-value caches of limited size
	       * @returns {function(string, object)} Returns the Object data after storing it on itself with
	       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	       *	deleting the oldest entry
	       */


	      function createCache() {
	        var keys = [];

	        function cache(key, value) {
	          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	          if (keys.push(key + " ") > Expr.cacheLength) {
	            // Only keep the most recent entries
	            delete cache[keys.shift()];
	          }

	          return cache[key + " "] = value;
	        }

	        return cache;
	      }
	      /**
	       * Mark a function for special use by Sizzle
	       * @param {Function} fn The function to mark
	       */


	      function markFunction(fn) {
	        fn[expando] = true;
	        return fn;
	      }
	      /**
	       * Support testing using an element
	       * @param {Function} fn Passed the created element and returns a boolean result
	       */


	      function assert(fn) {
	        var el = document.createElement("fieldset");

	        try {
	          return !!fn(el);
	        } catch (e) {
	          return false;
	        } finally {
	          // Remove from its parent by default
	          if (el.parentNode) {
	            el.parentNode.removeChild(el);
	          } // release memory in IE


	          el = null;
	        }
	      }
	      /**
	       * Adds the same handler for all of the specified attrs
	       * @param {String} attrs Pipe-separated list of attributes
	       * @param {Function} handler The method that will be applied
	       */


	      function addHandle(attrs, handler) {
	        var arr = attrs.split("|"),
	            i = arr.length;

	        while (i--) {
	          Expr.attrHandle[arr[i]] = handler;
	        }
	      }
	      /**
	       * Checks document order of two siblings
	       * @param {Element} a
	       * @param {Element} b
	       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	       */


	      function siblingCheck(a, b) {
	        var cur = b && a,
	            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

	        if (diff) {
	          return diff;
	        } // Check if b follows a


	        if (cur) {
	          while (cur = cur.nextSibling) {
	            if (cur === b) {
	              return -1;
	            }
	          }
	        }

	        return a ? 1 : -1;
	      }
	      /**
	       * Returns a function to use in pseudos for input types
	       * @param {String} type
	       */


	      function createInputPseudo(type) {
	        return function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return name === "input" && elem.type === type;
	        };
	      }
	      /**
	       * Returns a function to use in pseudos for buttons
	       * @param {String} type
	       */


	      function createButtonPseudo(type) {
	        return function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return (name === "input" || name === "button") && elem.type === type;
	        };
	      }
	      /**
	       * Returns a function to use in pseudos for :enabled/:disabled
	       * @param {Boolean} disabled true for :disabled; false for :enabled
	       */


	      function createDisabledPseudo(disabled) {
	        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	        return function (elem) {
	          // Only certain elements can match :enabled or :disabled
	          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
	          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
	          if ("form" in elem) {
	            // Check for inherited disabledness on relevant non-disabled elements:
	            // * listed form-associated elements in a disabled fieldset
	            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
	            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
	            // * option elements in a disabled optgroup
	            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
	            // All such elements have a "form" property.
	            if (elem.parentNode && elem.disabled === false) {
	              // Option elements defer to a parent optgroup if present
	              if ("label" in elem) {
	                if ("label" in elem.parentNode) {
	                  return elem.parentNode.disabled === disabled;
	                } else {
	                  return elem.disabled === disabled;
	                }
	              } // Support: IE 6 - 11
	              // Use the isDisabled shortcut property to check for disabled fieldset ancestors


	              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

	              /* jshint -W018 */
	              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
	            }

	            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
	            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
	            // even exist on them, let alone have a boolean value.
	          } else if ("label" in elem) {
	            return elem.disabled === disabled;
	          } // Remaining elements are neither :enabled nor :disabled


	          return false;
	        };
	      }
	      /**
	       * Returns a function to use in pseudos for positionals
	       * @param {Function} fn
	       */


	      function createPositionalPseudo(fn) {
	        return markFunction(function (argument) {
	          argument = +argument;
	          return markFunction(function (seed, matches) {
	            var j,
	                matchIndexes = fn([], seed.length, argument),
	                i = matchIndexes.length; // Match elements found at the specified indexes

	            while (i--) {
	              if (seed[j = matchIndexes[i]]) {
	                seed[j] = !(matches[j] = seed[j]);
	              }
	            }
	          });
	        });
	      }
	      /**
	       * Checks a node for validity as a Sizzle context
	       * @param {Element|Object=} context
	       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	       */


	      function testContext(context) {
	        return context && typeof context.getElementsByTagName !== "undefined" && context;
	      } // Expose support vars for convenience


	      support = Sizzle.support = {};
	      /**
	       * Detects XML nodes
	       * @param {Element|Object} elem An element or a document
	       * @returns {Boolean} True iff elem is a non-HTML XML node
	       */

	      isXML = Sizzle.isXML = function (elem) {
	        var namespace = elem.namespaceURI,
	            docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8
	        // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	        // https://bugs.jquery.com/ticket/4833

	        return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
	      };
	      /**
	       * Sets document-related variables once based on the current document
	       * @param {Element|Object} [doc] An element or document object to use to set the document
	       * @returns {Object} Returns the current document
	       */


	      setDocument = Sizzle.setDocument = function (node) {
	        var hasCompare,
	            subWindow,
	            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.
	        // eslint-disable-next-line eqeqeq

	        if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
	          return document;
	        } // Update global variables


	        document = doc;
	        docElem = document.documentElement;
	        documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
	        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.
	        // eslint-disable-next-line eqeqeq

	        if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
	          // Support: IE 11, Edge
	          if (subWindow.addEventListener) {
	            subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
	          } else if (subWindow.attachEvent) {
	            subWindow.attachEvent("onunload", unloadHandler);
	          }
	        } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	        // Safari 4 - 5 only, Opera <=11.6 - 12.x only
	        // IE/Edge & older browsers don't support the :scope pseudo-class.
	        // Support: Safari 6.0 only
	        // Safari 6.0 supports :scope but it's an alias of :root there.


	        support.scope = assert(function (el) {
	          docElem.appendChild(el).appendChild(document.createElement("div"));
	          return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
	        });
	        /* Attributes
	        ---------------------------------------------------------------------- */
	        // Support: IE<8
	        // Verify that getAttribute really returns attributes and not properties
	        // (excepting IE8 booleans)

	        support.attributes = assert(function (el) {
	          el.className = "i";
	          return !el.getAttribute("className");
	        });
	        /* getElement(s)By*
	        ---------------------------------------------------------------------- */
	        // Check if getElementsByTagName("*") returns only elements

	        support.getElementsByTagName = assert(function (el) {
	          el.appendChild(document.createComment(""));
	          return !el.getElementsByTagName("*").length;
	        }); // Support: IE<9

	        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
	        // Check if getElementById returns elements by name
	        // The broken getElementById methods don't pick up programmatically-set names,
	        // so use a roundabout getElementsByName test

	        support.getById = assert(function (el) {
	          docElem.appendChild(el).id = expando;
	          return !document.getElementsByName || !document.getElementsByName(expando).length;
	        }); // ID filter and find

	        if (support.getById) {
	          Expr.filter["ID"] = function (id) {
	            var attrId = id.replace(runescape, funescape);
	            return function (elem) {
	              return elem.getAttribute("id") === attrId;
	            };
	          };

	          Expr.find["ID"] = function (id, context) {
	            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	              var elem = context.getElementById(id);
	              return elem ? [elem] : [];
	            }
	          };
	        } else {
	          Expr.filter["ID"] = function (id) {
	            var attrId = id.replace(runescape, funescape);
	            return function (elem) {
	              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
	              return node && node.value === attrId;
	            };
	          }; // Support: IE 6 - 7 only
	          // getElementById is not reliable as a find shortcut


	          Expr.find["ID"] = function (id, context) {
	            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	              var node,
	                  i,
	                  elems,
	                  elem = context.getElementById(id);

	              if (elem) {
	                // Verify the id attribute
	                node = elem.getAttributeNode("id");

	                if (node && node.value === id) {
	                  return [elem];
	                } // Fall back on getElementsByName


	                elems = context.getElementsByName(id);
	                i = 0;

	                while (elem = elems[i++]) {
	                  node = elem.getAttributeNode("id");

	                  if (node && node.value === id) {
	                    return [elem];
	                  }
	                }
	              }

	              return [];
	            }
	          };
	        } // Tag


	        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
	          if (typeof context.getElementsByTagName !== "undefined") {
	            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
	          } else if (support.qsa) {
	            return context.querySelectorAll(tag);
	          }
	        } : function (tag, context) {
	          var elem,
	              tmp = [],
	              i = 0,
	              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
	          results = context.getElementsByTagName(tag); // Filter out possible comments

	          if (tag === "*") {
	            while (elem = results[i++]) {
	              if (elem.nodeType === 1) {
	                tmp.push(elem);
	              }
	            }

	            return tmp;
	          }

	          return results;
	        }; // Class

	        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
	          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
	            return context.getElementsByClassName(className);
	          }
	        };
	        /* QSA/matchesSelector
	        ---------------------------------------------------------------------- */
	        // QSA and matchesSelector support
	        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


	        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
	        // We allow this because of a bug in IE8/9 that throws an error
	        // whenever `document.activeElement` is accessed on an iframe
	        // So, we allow :focus to pass through QSA all the time to avoid the IE error
	        // See https://bugs.jquery.com/ticket/13378

	        rbuggyQSA = [];

	        if (support.qsa = rnative.test(document.querySelectorAll)) {
	          // Build QSA regex
	          // Regex strategy adopted from Diego Perini
	          assert(function (el) {
	            var input; // Select is set to empty string on purpose
	            // This is to test IE's treatment of not explicitly
	            // setting a boolean content attribute,
	            // since its presence should be enough
	            // https://bugs.jquery.com/ticket/12359

	            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
	            // Nothing should be selected when empty strings follow ^= or $= or *=
	            // The test attribute must be unknown in Opera but "safe" for WinRT
	            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

	            if (el.querySelectorAll("[msallowcapture^='']").length) {
	              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
	            } // Support: IE8
	            // Boolean attributes and "value" are not treated correctly


	            if (!el.querySelectorAll("[selected]").length) {
	              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
	            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


	            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
	              rbuggyQSA.push("~=");
	            } // Support: IE 11+, Edge 15 - 18+
	            // IE 11/Edge don't find elements on a `[name='']` query in some cases.
	            // Adding a temporary attribute to the document before the selection works
	            // around the issue.
	            // Interestingly, IE 10 & older don't seem to have the issue.


	            input = document.createElement("input");
	            input.setAttribute("name", "");
	            el.appendChild(input);

	            if (!el.querySelectorAll("[name='']").length) {
	              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
	            } // Webkit/Opera - :checked should return selected option elements
	            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	            // IE8 throws error here and will not see later tests


	            if (!el.querySelectorAll(":checked").length) {
	              rbuggyQSA.push(":checked");
	            } // Support: Safari 8+, iOS 8+
	            // https://bugs.webkit.org/show_bug.cgi?id=136851
	            // In-page `selector#id sibling-combinator selector` fails


	            if (!el.querySelectorAll("a#" + expando + "+*").length) {
	              rbuggyQSA.push(".#.+[+~]");
	            } // Support: Firefox <=3.6 - 5 only
	            // Old Firefox doesn't throw on a badly-escaped identifier.


	            el.querySelectorAll("\\\f");
	            rbuggyQSA.push("[\\r\\n\\f]");
	          });
	          assert(function (el) {
	            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
	            // The type and name attributes are restricted during .innerHTML assignment

	            var input = document.createElement("input");
	            input.setAttribute("type", "hidden");
	            el.appendChild(input).setAttribute("name", "D"); // Support: IE8
	            // Enforce case-sensitivity of name attribute

	            if (el.querySelectorAll("[name=d]").length) {
	              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
	            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	            // IE8 throws error here and will not see later tests


	            if (el.querySelectorAll(":enabled").length !== 2) {
	              rbuggyQSA.push(":enabled", ":disabled");
	            } // Support: IE9-11+
	            // IE's :disabled selector does not pick up the children of disabled fieldsets


	            docElem.appendChild(el).disabled = true;

	            if (el.querySelectorAll(":disabled").length !== 2) {
	              rbuggyQSA.push(":enabled", ":disabled");
	            } // Support: Opera 10 - 11 only
	            // Opera 10-11 does not throw on post-comma invalid pseudos


	            el.querySelectorAll("*,:x");
	            rbuggyQSA.push(",.*:");
	          });
	        }

	        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
	          assert(function (el) {
	            // Check to see if it's possible to do matchesSelector
	            // on a disconnected node (IE 9)
	            support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
	            // Gecko does not error, returns false instead

	            matches.call(el, "[s!='']:x");
	            rbuggyMatches.push("!=", pseudos);
	          });
	        }

	        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
	        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
	        /* Contains
	        ---------------------------------------------------------------------- */

	        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
	        // Purposefully self-exclusive
	        // As in, an element does not contain itself

	        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
	          var adown = a.nodeType === 9 ? a.documentElement : a,
	              bup = b && b.parentNode;
	          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
	        } : function (a, b) {
	          if (b) {
	            while (b = b.parentNode) {
	              if (b === a) {
	                return true;
	              }
	            }
	          }

	          return false;
	        };
	        /* Sorting
	        ---------------------------------------------------------------------- */
	        // Document order sorting

	        sortOrder = hasCompare ? function (a, b) {
	          // Flag for duplicate removal
	          if (a === b) {
	            hasDuplicate = true;
	            return 0;
	          } // Sort on method existence if only one input has compareDocumentPosition


	          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

	          if (compare) {
	            return compare;
	          } // Calculate position if both inputs belong to the same document
	          // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.
	          // eslint-disable-next-line eqeqeq


	          compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
	          1; // Disconnected nodes

	          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
	            // Choose the first element that is related to our preferred document
	            // Support: IE 11+, Edge 17 - 18+
	            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	            // two documents; shallow comparisons work.
	            // eslint-disable-next-line eqeqeq
	            if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
	              return -1;
	            } // Support: IE 11+, Edge 17 - 18+
	            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	            // two documents; shallow comparisons work.
	            // eslint-disable-next-line eqeqeq


	            if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
	              return 1;
	            } // Maintain original order


	            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
	          }

	          return compare & 4 ? -1 : 1;
	        } : function (a, b) {
	          // Exit early if the nodes are identical
	          if (a === b) {
	            hasDuplicate = true;
	            return 0;
	          }

	          var cur,
	              i = 0,
	              aup = a.parentNode,
	              bup = b.parentNode,
	              ap = [a],
	              bp = [b]; // Parentless nodes are either documents or disconnected

	          if (!aup || !bup) {
	            // Support: IE 11+, Edge 17 - 18+
	            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	            // two documents; shallow comparisons work.

	            /* eslint-disable eqeqeq */
	            return a == document ? -1 : b == document ? 1 :
	            /* eslint-enable eqeqeq */
	            aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
	          } else if (aup === bup) {
	            return siblingCheck(a, b);
	          } // Otherwise we need full lists of their ancestors for comparison


	          cur = a;

	          while (cur = cur.parentNode) {
	            ap.unshift(cur);
	          }

	          cur = b;

	          while (cur = cur.parentNode) {
	            bp.unshift(cur);
	          } // Walk down the tree looking for a discrepancy


	          while (ap[i] === bp[i]) {
	            i++;
	          }

	          return i ? // Do a sibling check if the nodes have a common ancestor
	          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
	          // Support: IE 11+, Edge 17 - 18+
	          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	          // two documents; shallow comparisons work.

	          /* eslint-disable eqeqeq */
	          ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
	          /* eslint-enable eqeqeq */
	          0;
	        };
	        return document;
	      };

	      Sizzle.matches = function (expr, elements) {
	        return Sizzle(expr, null, null, elements);
	      };

	      Sizzle.matchesSelector = function (elem, expr) {
	        setDocument(elem);

	        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
	          try {
	            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

	            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
	            // fragment in IE 9
	            elem.document && elem.document.nodeType !== 11) {
	              return ret;
	            }
	          } catch (e) {
	            nonnativeSelectorCache(expr, true);
	          }
	        }

	        return Sizzle(expr, document, null, [elem]).length > 0;
	      };

	      Sizzle.contains = function (context, elem) {
	        // Set document vars if needed
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.
	        // eslint-disable-next-line eqeqeq
	        if ((context.ownerDocument || context) != document) {
	          setDocument(context);
	        }

	        return contains(context, elem);
	      };

	      Sizzle.attr = function (elem, name) {
	        // Set document vars if needed
	        // Support: IE 11+, Edge 17 - 18+
	        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	        // two documents; shallow comparisons work.
	        // eslint-disable-next-line eqeqeq
	        if ((elem.ownerDocument || elem) != document) {
	          setDocument(elem);
	        }

	        var fn = Expr.attrHandle[name.toLowerCase()],
	            // Don't get fooled by Object.prototype properties (jQuery #13807)
	        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
	        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	      };

	      Sizzle.escape = function (sel) {
	        return (sel + "").replace(rcssescape, fcssescape);
	      };

	      Sizzle.error = function (msg) {
	        throw new Error("Syntax error, unrecognized expression: " + msg);
	      };
	      /**
	       * Document sorting and removing duplicates
	       * @param {ArrayLike} results
	       */


	      Sizzle.uniqueSort = function (results) {
	        var elem,
	            duplicates = [],
	            j = 0,
	            i = 0; // Unless we *know* we can detect duplicates, assume their presence

	        hasDuplicate = !support.detectDuplicates;
	        sortInput = !support.sortStable && results.slice(0);
	        results.sort(sortOrder);

	        if (hasDuplicate) {
	          while (elem = results[i++]) {
	            if (elem === results[i]) {
	              j = duplicates.push(i);
	            }
	          }

	          while (j--) {
	            results.splice(duplicates[j], 1);
	          }
	        } // Clear input after sorting to release objects
	        // See https://github.com/jquery/sizzle/pull/225


	        sortInput = null;
	        return results;
	      };
	      /**
	       * Utility function for retrieving the text value of an array of DOM nodes
	       * @param {Array|Element} elem
	       */


	      getText = Sizzle.getText = function (elem) {
	        var node,
	            ret = "",
	            i = 0,
	            nodeType = elem.nodeType;

	        if (!nodeType) {
	          // If no nodeType, this is expected to be an array
	          while (node = elem[i++]) {
	            // Do not traverse comment nodes
	            ret += getText(node);
	          }
	        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
	          // Use textContent for elements
	          // innerText usage removed for consistency of new lines (jQuery #11153)
	          if (typeof elem.textContent === "string") {
	            return elem.textContent;
	          } else {
	            // Traverse its children
	            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	              ret += getText(elem);
	            }
	          }
	        } else if (nodeType === 3 || nodeType === 4) {
	          return elem.nodeValue;
	        } // Do not include comment or processing instruction nodes


	        return ret;
	      };

	      Expr = Sizzle.selectors = {
	        // Can be adjusted by the user
	        cacheLength: 50,
	        createPseudo: markFunction,
	        match: matchExpr,
	        attrHandle: {},
	        find: {},
	        relative: {
	          ">": {
	            dir: "parentNode",
	            first: true
	          },
	          " ": {
	            dir: "parentNode"
	          },
	          "+": {
	            dir: "previousSibling",
	            first: true
	          },
	          "~": {
	            dir: "previousSibling"
	          }
	        },
	        preFilter: {
	          ATTR: function (match) {
	            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

	            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

	            if (match[2] === "~=") {
	              match[3] = " " + match[3] + " ";
	            }

	            return match.slice(0, 4);
	          },
	          CHILD: function (match) {
	            /* matches from matchExpr["CHILD"]
	            1 type (only|nth|...)
	            2 what (child|of-type)
	            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	            4 xn-component of xn+y argument ([+-]?\d*n|)
	            5 sign of xn-component
	            6 x of xn-component
	            7 sign of y-component
	            8 y of y-component
	            */
	            match[1] = match[1].toLowerCase();

	            if (match[1].slice(0, 3) === "nth") {
	              // nth-* requires argument
	              if (!match[3]) {
	                Sizzle.error(match[0]);
	              } // numeric x and y parameters for Expr.filter.CHILD
	              // remember that false/true cast respectively to 0/1


	              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
	              match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
	            } else if (match[3]) {
	              Sizzle.error(match[0]);
	            }

	            return match;
	          },
	          PSEUDO: function (match) {
	            var excess,
	                unquoted = !match[6] && match[2];

	            if (matchExpr["CHILD"].test(match[0])) {
	              return null;
	            } // Accept quoted arguments as-is


	            if (match[3]) {
	              match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
	            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
	            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
	            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
	              // excess is a negative index
	              match[0] = match[0].slice(0, excess);
	              match[2] = unquoted.slice(0, excess);
	            } // Return only captures needed by the pseudo filter method (type and argument)


	            return match.slice(0, 3);
	          }
	        },
	        filter: {
	          TAG: function (nodeNameSelector) {
	            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
	            return nodeNameSelector === "*" ? function () {
	              return true;
	            } : function (elem) {
	              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	            };
	          },
	          CLASS: function (className) {
	            var pattern = classCache[className + " "];
	            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
	              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
	            });
	          },
	          ATTR: function (name, operator, check) {
	            return function (elem) {
	              var result = Sizzle.attr(elem, name);

	              if (result == null) {
	                return operator === "!=";
	              }

	              if (!operator) {
	                return true;
	              }

	              result += "";
	              /* eslint-disable max-len */

	              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
	              /* eslint-enable max-len */
	            };
	          },
	          CHILD: function (type, what, _argument, first, last) {
	            var simple = type.slice(0, 3) !== "nth",
	                forward = type.slice(-4) !== "last",
	                ofType = what === "of-type";
	            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
	            function (elem) {
	              return !!elem.parentNode;
	            } : function (elem, _context, xml) {
	              var cache,
	                  uniqueCache,
	                  outerCache,
	                  node,
	                  nodeIndex,
	                  start,
	                  dir = simple !== forward ? "nextSibling" : "previousSibling",
	                  parent = elem.parentNode,
	                  name = ofType && elem.nodeName.toLowerCase(),
	                  useCache = !xml && !ofType,
	                  diff = false;

	              if (parent) {
	                // :(first|last|only)-(child|of-type)
	                if (simple) {
	                  while (dir) {
	                    node = elem;

	                    while (node = node[dir]) {
	                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	                        return false;
	                      }
	                    } // Reverse direction for :only-* (if we haven't yet done so)


	                    start = dir = type === "only" && !start && "nextSibling";
	                  }

	                  return true;
	                }

	                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

	                if (forward && useCache) {
	                  // Seek `elem` from a previously-cached index
	                  // ...in a gzip-friendly way
	                  node = parent;
	                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                  // Defend against cloned attroperties (jQuery gh-1709)

	                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                  cache = uniqueCache[type] || [];
	                  nodeIndex = cache[0] === dirruns && cache[1];
	                  diff = nodeIndex && cache[2];
	                  node = nodeIndex && parent.childNodes[nodeIndex];

	                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
	                  diff = nodeIndex = 0) || start.pop()) {
	                    // When found, cache indexes on `parent` and break
	                    if (node.nodeType === 1 && ++diff && node === elem) {
	                      uniqueCache[type] = [dirruns, nodeIndex, diff];
	                      break;
	                    }
	                  }
	                } else {
	                  // Use previously-cached element index if available
	                  if (useCache) {
	                    // ...in a gzip-friendly way
	                    node = elem;
	                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                    // Defend against cloned attroperties (jQuery gh-1709)

	                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                    cache = uniqueCache[type] || [];
	                    nodeIndex = cache[0] === dirruns && cache[1];
	                    diff = nodeIndex;
	                  } // xml :nth-child(...)
	                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)


	                  if (diff === false) {
	                    // Use the same loop as above to seek `elem` from the start
	                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	                        // Cache the index of each encountered element
	                        if (useCache) {
	                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
	                          // Defend against cloned attroperties (jQuery gh-1709)

	                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                          uniqueCache[type] = [dirruns, diff];
	                        }

	                        if (node === elem) {
	                          break;
	                        }
	                      }
	                    }
	                  }
	                } // Incorporate the offset, then check against cycle size


	                diff -= last;
	                return diff === first || diff % first === 0 && diff / first >= 0;
	              }
	            };
	          },
	          PSEUDO: function (pseudo, argument) {
	            // pseudo-class names are case-insensitive
	            // http://www.w3.org/TR/selectors/#pseudo-classes
	            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	            // Remember that setFilters inherits from pseudos
	            var args,
	                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
	            // arguments are needed to create the filter function
	            // just as Sizzle does

	            if (fn[expando]) {
	              return fn(argument);
	            } // But maintain support for old signatures


	            if (fn.length > 1) {
	              args = [pseudo, pseudo, "", argument];
	              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
	                var idx,
	                    matched = fn(seed, argument),
	                    i = matched.length;

	                while (i--) {
	                  idx = indexOf(seed, matched[i]);
	                  seed[idx] = !(matches[idx] = matched[i]);
	                }
	              }) : function (elem) {
	                return fn(elem, 0, args);
	              };
	            }

	            return fn;
	          }
	        },
	        pseudos: {
	          // Potentially complex pseudos
	          not: markFunction(function (selector) {
	            // Trim the selector passed to compile
	            // to avoid treating leading and trailing
	            // spaces as combinators
	            var input = [],
	                results = [],
	                matcher = compile(selector.replace(rtrim, "$1"));
	            return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
	              var elem,
	                  unmatched = matcher(seed, null, xml, []),
	                  i = seed.length; // Match elements unmatched by `matcher`

	              while (i--) {
	                if (elem = unmatched[i]) {
	                  seed[i] = !(matches[i] = elem);
	                }
	              }
	            }) : function (elem, _context, xml) {
	              input[0] = elem;
	              matcher(input, null, xml, results); // Don't keep the element (issue #299)

	              input[0] = null;
	              return !results.pop();
	            };
	          }),
	          has: markFunction(function (selector) {
	            return function (elem) {
	              return Sizzle(selector, elem).length > 0;
	            };
	          }),
	          contains: markFunction(function (text) {
	            text = text.replace(runescape, funescape);
	            return function (elem) {
	              return (elem.textContent || getText(elem)).indexOf(text) > -1;
	            };
	          }),
	          // "Whether an element is represented by a :lang() selector
	          // is based solely on the element's language value
	          // being equal to the identifier C,
	          // or beginning with the identifier C immediately followed by "-".
	          // The matching of C against the element's language value is performed case-insensitively.
	          // The identifier C does not have to be a valid language name."
	          // http://www.w3.org/TR/selectors/#lang-pseudo
	          lang: markFunction(function (lang) {
	            // lang value must be a valid identifier
	            if (!ridentifier.test(lang || "")) {
	              Sizzle.error("unsupported lang: " + lang);
	            }

	            lang = lang.replace(runescape, funescape).toLowerCase();
	            return function (elem) {
	              var elemLang;

	              do {
	                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
	                  elemLang = elemLang.toLowerCase();
	                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
	                }
	              } while ((elem = elem.parentNode) && elem.nodeType === 1);

	              return false;
	            };
	          }),
	          // Miscellaneous
	          target: function (elem) {
	            var hash = window.location && window.location.hash;
	            return hash && hash.slice(1) === elem.id;
	          },
	          root: function (elem) {
	            return elem === docElem;
	          },
	          focus: function (elem) {
	            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	          },
	          // Boolean properties
	          enabled: createDisabledPseudo(false),
	          disabled: createDisabledPseudo(true),
	          checked: function (elem) {
	            // In CSS3, :checked should return both checked and selected elements
	            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	            var nodeName = elem.nodeName.toLowerCase();
	            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
	          },
	          selected: function (elem) {
	            // Accessing this property makes selected-by-default
	            // options in Safari work properly
	            if (elem.parentNode) {
	              // eslint-disable-next-line no-unused-expressions
	              elem.parentNode.selectedIndex;
	            }

	            return elem.selected === true;
	          },
	          // Contents
	          empty: function (elem) {
	            // http://www.w3.org/TR/selectors/#empty-pseudo
	            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	            //   but not by others (comment: 8; processing instruction: 7; etc.)
	            // nodeType < 6 works because attributes (2) do not appear as children
	            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	              if (elem.nodeType < 6) {
	                return false;
	              }
	            }

	            return true;
	          },
	          parent: function (elem) {
	            return !Expr.pseudos["empty"](elem);
	          },
	          // Element/input types
	          header: function (elem) {
	            return rheader.test(elem.nodeName);
	          },
	          input: function (elem) {
	            return rinputs.test(elem.nodeName);
	          },
	          button: function (elem) {
	            var name = elem.nodeName.toLowerCase();
	            return name === "input" && elem.type === "button" || name === "button";
	          },
	          text: function (elem) {
	            var attr;
	            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
	            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	            (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
	          },
	          // Position-in-collection
	          first: createPositionalPseudo(function () {
	            return [0];
	          }),
	          last: createPositionalPseudo(function (_matchIndexes, length) {
	            return [length - 1];
	          }),
	          eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
	            return [argument < 0 ? argument + length : argument];
	          }),
	          even: createPositionalPseudo(function (matchIndexes, length) {
	            var i = 0;

	            for (; i < length; i += 2) {
	              matchIndexes.push(i);
	            }

	            return matchIndexes;
	          }),
	          odd: createPositionalPseudo(function (matchIndexes, length) {
	            var i = 1;

	            for (; i < length; i += 2) {
	              matchIndexes.push(i);
	            }

	            return matchIndexes;
	          }),
	          lt: createPositionalPseudo(function (matchIndexes, length, argument) {
	            var i = argument < 0 ? argument + length : argument > length ? length : argument;

	            for (; --i >= 0;) {
	              matchIndexes.push(i);
	            }

	            return matchIndexes;
	          }),
	          gt: createPositionalPseudo(function (matchIndexes, length, argument) {
	            var i = argument < 0 ? argument + length : argument;

	            for (; ++i < length;) {
	              matchIndexes.push(i);
	            }

	            return matchIndexes;
	          })
	        }
	      };
	      Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

	      for (i in {
	        radio: true,
	        checkbox: true,
	        file: true,
	        password: true,
	        image: true
	      }) {
	        Expr.pseudos[i] = createInputPseudo(i);
	      }

	      for (i in {
	        submit: true,
	        reset: true
	      }) {
	        Expr.pseudos[i] = createButtonPseudo(i);
	      } // Easy API for creating new setFilters


	      function setFilters() {}

	      setFilters.prototype = Expr.filters = Expr.pseudos;
	      Expr.setFilters = new setFilters();

	      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	        var matched,
	            match,
	            tokens,
	            type,
	            soFar,
	            groups,
	            preFilters,
	            cached = tokenCache[selector + " "];

	        if (cached) {
	          return parseOnly ? 0 : cached.slice(0);
	        }

	        soFar = selector;
	        groups = [];
	        preFilters = Expr.preFilter;

	        while (soFar) {
	          // Comma and first run
	          if (!matched || (match = rcomma.exec(soFar))) {
	            if (match) {
	              // Don't consume trailing commas as valid
	              soFar = soFar.slice(match[0].length) || soFar;
	            }

	            groups.push(tokens = []);
	          }

	          matched = false; // Combinators

	          if (match = rcombinators.exec(soFar)) {
	            matched = match.shift();
	            tokens.push({
	              value: matched,
	              // Cast descendant combinators to space
	              type: match[0].replace(rtrim, " ")
	            });
	            soFar = soFar.slice(matched.length);
	          } // Filters


	          for (type in Expr.filter) {
	            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
	              matched = match.shift();
	              tokens.push({
	                value: matched,
	                type: type,
	                matches: match
	              });
	              soFar = soFar.slice(matched.length);
	            }
	          }

	          if (!matched) {
	            break;
	          }
	        } // Return the length of the invalid excess
	        // if we're just parsing
	        // Otherwise, throw an error or return tokens


	        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
	        tokenCache(selector, groups).slice(0);
	      };

	      function toSelector(tokens) {
	        var i = 0,
	            len = tokens.length,
	            selector = "";

	        for (; i < len; i++) {
	          selector += tokens[i].value;
	        }

	        return selector;
	      }

	      function addCombinator(matcher, combinator, base) {
	        var dir = combinator.dir,
	            skip = combinator.next,
	            key = skip || dir,
	            checkNonElements = base && key === "parentNode",
	            doneName = done++;
	        return combinator.first ? // Check against closest ancestor/preceding element
	        function (elem, context, xml) {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              return matcher(elem, context, xml);
	            }
	          }

	          return false;
	        } : // Check against all ancestor/preceding elements
	        function (elem, context, xml) {
	          var oldCache,
	              uniqueCache,
	              outerCache,
	              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

	          if (xml) {
	            while (elem = elem[dir]) {
	              if (elem.nodeType === 1 || checkNonElements) {
	                if (matcher(elem, context, xml)) {
	                  return true;
	                }
	              }
	            }
	          } else {
	            while (elem = elem[dir]) {
	              if (elem.nodeType === 1 || checkNonElements) {
	                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
	                // Defend against cloned attroperties (jQuery gh-1709)

	                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

	                if (skip && skip === elem.nodeName.toLowerCase()) {
	                  elem = elem[dir] || elem;
	                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
	                  // Assign to newCache so results back-propagate to previous elements
	                  return newCache[2] = oldCache[2];
	                } else {
	                  // Reuse newcache so results back-propagate to previous elements
	                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

	                  if (newCache[2] = matcher(elem, context, xml)) {
	                    return true;
	                  }
	                }
	              }
	            }
	          }

	          return false;
	        };
	      }

	      function elementMatcher(matchers) {
	        return matchers.length > 1 ? function (elem, context, xml) {
	          var i = matchers.length;

	          while (i--) {
	            if (!matchers[i](elem, context, xml)) {
	              return false;
	            }
	          }

	          return true;
	        } : matchers[0];
	      }

	      function multipleContexts(selector, contexts, results) {
	        var i = 0,
	            len = contexts.length;

	        for (; i < len; i++) {
	          Sizzle(selector, contexts[i], results);
	        }

	        return results;
	      }

	      function condense(unmatched, map, filter, context, xml) {
	        var elem,
	            newUnmatched = [],
	            i = 0,
	            len = unmatched.length,
	            mapped = map != null;

	        for (; i < len; i++) {
	          if (elem = unmatched[i]) {
	            if (!filter || filter(elem, context, xml)) {
	              newUnmatched.push(elem);

	              if (mapped) {
	                map.push(i);
	              }
	            }
	          }
	        }

	        return newUnmatched;
	      }

	      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	        if (postFilter && !postFilter[expando]) {
	          postFilter = setMatcher(postFilter);
	        }

	        if (postFinder && !postFinder[expando]) {
	          postFinder = setMatcher(postFinder, postSelector);
	        }

	        return markFunction(function (seed, results, context, xml) {
	          var temp,
	              i,
	              elem,
	              preMap = [],
	              postMap = [],
	              preexisting = results.length,
	              // Get initial elements from seed or context
	          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
	              // Prefilter to get matcher input, preserving a map for seed-results synchronization
	          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
	              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
	          [] : // ...otherwise use results directly
	          results : matcherIn; // Find primary matches

	          if (matcher) {
	            matcher(matcherIn, matcherOut, context, xml);
	          } // Apply postFilter


	          if (postFilter) {
	            temp = condense(matcherOut, postMap);
	            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

	            i = temp.length;

	            while (i--) {
	              if (elem = temp[i]) {
	                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
	              }
	            }
	          }

	          if (seed) {
	            if (postFinder || preFilter) {
	              if (postFinder) {
	                // Get the final matcherOut by condensing this intermediate into postFinder contexts
	                temp = [];
	                i = matcherOut.length;

	                while (i--) {
	                  if (elem = matcherOut[i]) {
	                    // Restore matcherIn since elem is not yet a final match
	                    temp.push(matcherIn[i] = elem);
	                  }
	                }

	                postFinder(null, matcherOut = [], temp, xml);
	              } // Move matched elements from seed to results to keep them synchronized


	              i = matcherOut.length;

	              while (i--) {
	                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
	                  seed[temp] = !(results[temp] = elem);
	                }
	              }
	            } // Add elements to results, through postFinder if defined

	          } else {
	            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

	            if (postFinder) {
	              postFinder(null, results, matcherOut, xml);
	            } else {
	              push.apply(results, matcherOut);
	            }
	          }
	        });
	      }

	      function matcherFromTokens(tokens) {
	        var checkContext,
	            matcher,
	            j,
	            len = tokens.length,
	            leadingRelative = Expr.relative[tokens[0].type],
	            implicitRelative = leadingRelative || Expr.relative[" "],
	            i = leadingRelative ? 1 : 0,
	            // The foundational matcher ensures that elements are reachable from top-level context(s)
	        matchContext = addCombinator(function (elem) {
	          return elem === checkContext;
	        }, implicitRelative, true),
	            matchAnyContext = addCombinator(function (elem) {
	          return indexOf(checkContext, elem) > -1;
	        }, implicitRelative, true),
	            matchers = [function (elem, context, xml) {
	          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

	          checkContext = null;
	          return ret;
	        }];

	        for (; i < len; i++) {
	          if (matcher = Expr.relative[tokens[i].type]) {
	            matchers = [addCombinator(elementMatcher(matchers), matcher)];
	          } else {
	            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

	            if (matcher[expando]) {
	              // Find the next relative operator (if any) for proper handling
	              j = ++i;

	              for (; j < len; j++) {
	                if (Expr.relative[tokens[j].type]) {
	                  break;
	                }
	              }

	              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	              tokens.slice(0, i - 1).concat({
	                value: tokens[i - 2].type === " " ? "*" : ""
	              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
	            }

	            matchers.push(matcher);
	          }
	        }

	        return elementMatcher(matchers);
	      }

	      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
	        var bySet = setMatchers.length > 0,
	            byElement = elementMatchers.length > 0,
	            superMatcher = function (seed, context, xml, results, outermost) {
	          var elem,
	              j,
	              matcher,
	              matchedCount = 0,
	              i = "0",
	              unmatched = seed && [],
	              setMatched = [],
	              contextBackup = outermostContext,
	              // We must always have either seed elements or outermost context
	          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
	              // Use integer dirruns iff this is the outermost matcher
	          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
	              len = elems.length;

	          if (outermost) {
	            // Support: IE 11+, Edge 17 - 18+
	            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	            // two documents; shallow comparisons work.
	            // eslint-disable-next-line eqeqeq
	            outermostContext = context == document || context || outermost;
	          } // Add elements passing elementMatchers directly to results
	          // Support: IE<9, Safari
	          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


	          for (; i !== len && (elem = elems[i]) != null; i++) {
	            if (byElement && elem) {
	              j = 0; // Support: IE 11+, Edge 17 - 18+
	              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	              // two documents; shallow comparisons work.
	              // eslint-disable-next-line eqeqeq

	              if (!context && elem.ownerDocument != document) {
	                setDocument(elem);
	                xml = !documentIsHTML;
	              }

	              while (matcher = elementMatchers[j++]) {
	                if (matcher(elem, context || document, xml)) {
	                  results.push(elem);
	                  break;
	                }
	              }

	              if (outermost) {
	                dirruns = dirrunsUnique;
	              }
	            } // Track unmatched elements for set filters


	            if (bySet) {
	              // They will have gone through all possible matchers
	              if (elem = !matcher && elem) {
	                matchedCount--;
	              } // Lengthen the array for every element, matched or not


	              if (seed) {
	                unmatched.push(elem);
	              }
	            }
	          } // `i` is now the count of elements visited above, and adding it to `matchedCount`
	          // makes the latter nonnegative.


	          matchedCount += i; // Apply set filters to unmatched elements
	          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
	          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
	          // no element matchers and no seed.
	          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
	          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
	          // numerically zero.

	          if (bySet && i !== matchedCount) {
	            j = 0;

	            while (matcher = setMatchers[j++]) {
	              matcher(unmatched, setMatched, context, xml);
	            }

	            if (seed) {
	              // Reintegrate element matches to eliminate the need for sorting
	              if (matchedCount > 0) {
	                while (i--) {
	                  if (!(unmatched[i] || setMatched[i])) {
	                    setMatched[i] = pop.call(results);
	                  }
	                }
	              } // Discard index placeholder values to get only actual matches


	              setMatched = condense(setMatched);
	            } // Add matches to results


	            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

	            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
	              Sizzle.uniqueSort(results);
	            }
	          } // Override manipulation of globals by nested matchers


	          if (outermost) {
	            dirruns = dirrunsUnique;
	            outermostContext = contextBackup;
	          }

	          return unmatched;
	        };

	        return bySet ? markFunction(superMatcher) : superMatcher;
	      }

	      compile = Sizzle.compile = function (selector, match
	      /* Internal Use Only */
	      ) {
	        var i,
	            setMatchers = [],
	            elementMatchers = [],
	            cached = compilerCache[selector + " "];

	        if (!cached) {
	          // Generate a function of recursive functions that can be used to check each element
	          if (!match) {
	            match = tokenize(selector);
	          }

	          i = match.length;

	          while (i--) {
	            cached = matcherFromTokens(match[i]);

	            if (cached[expando]) {
	              setMatchers.push(cached);
	            } else {
	              elementMatchers.push(cached);
	            }
	          } // Cache the compiled function


	          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

	          cached.selector = selector;
	        }

	        return cached;
	      };
	      /**
	       * A low-level selection function that works with Sizzle's compiled
	       *  selector functions
	       * @param {String|Function} selector A selector or a pre-compiled
	       *  selector function built with Sizzle.compile
	       * @param {Element} context
	       * @param {Array} [results]
	       * @param {Array} [seed] A set of elements to match against
	       */


	      select = Sizzle.select = function (selector, context, results, seed) {
	        var i,
	            tokens,
	            token,
	            type,
	            find,
	            compiled = typeof selector === "function" && selector,
	            match = !seed && tokenize(selector = compiled.selector || selector);
	        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
	        // (the latter of which guarantees us context)

	        if (match.length === 1) {
	          // Reduce context if the leading compound selector is an ID
	          tokens = match[0] = match[0].slice(0);

	          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
	            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

	            if (!context) {
	              return results; // Precompiled matchers will still verify ancestry, so step up a level
	            } else if (compiled) {
	              context = context.parentNode;
	            }

	            selector = selector.slice(tokens.shift().value.length);
	          } // Fetch a seed set for right-to-left matching


	          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

	          while (i--) {
	            token = tokens[i]; // Abort if we hit a combinator

	            if (Expr.relative[type = token.type]) {
	              break;
	            }

	            if (find = Expr.find[type]) {
	              // Search, expanding context for leading sibling combinators
	              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
	                // If seed is empty or no tokens remain, we can return early
	                tokens.splice(i, 1);
	                selector = seed.length && toSelector(tokens);

	                if (!selector) {
	                  push.apply(results, seed);
	                  return results;
	                }

	                break;
	              }
	            }
	          }
	        } // Compile and execute a filtering function if one is not provided
	        // Provide `match` to avoid retokenization if we modified the selector above


	        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
	        return results;
	      }; // One-time assignments
	      // Sort stability


	      support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
	      // Always assume duplicates if they aren't passed to the comparison function

	      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

	      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	      // Detached nodes confoundingly follow *each other*

	      support.sortDetached = assert(function (el) {
	        // Should return 1, but returns 4 (following)
	        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
	      }); // Support: IE<8
	      // Prevent attribute/property "interpolation"
	      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

	      if (!assert(function (el) {
	        el.innerHTML = "<a href='#'></a>";
	        return el.firstChild.getAttribute("href") === "#";
	      })) {
	        addHandle("type|href|height|width", function (elem, name, isXML) {
	          if (!isXML) {
	            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
	          }
	        });
	      } // Support: IE<9
	      // Use defaultValue in place of getAttribute("value")


	      if (!support.attributes || !assert(function (el) {
	        el.innerHTML = "<input/>";
	        el.firstChild.setAttribute("value", "");
	        return el.firstChild.getAttribute("value") === "";
	      })) {
	        addHandle("value", function (elem, _name, isXML) {
	          if (!isXML && elem.nodeName.toLowerCase() === "input") {
	            return elem.defaultValue;
	          }
	        });
	      } // Support: IE<9
	      // Use getAttributeNode to fetch booleans when getAttribute lies


	      if (!assert(function (el) {
	        return el.getAttribute("disabled") == null;
	      })) {
	        addHandle(booleans, function (elem, name, isXML) {
	          var val;

	          if (!isXML) {
	            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	          }
	        });
	      }

	      return Sizzle;
	    }(window);

	    jQuery.find = Sizzle;
	    jQuery.expr = Sizzle.selectors; // Deprecated

	    jQuery.expr[":"] = jQuery.expr.pseudos;
	    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	    jQuery.text = Sizzle.getText;
	    jQuery.isXMLDoc = Sizzle.isXML;
	    jQuery.contains = Sizzle.contains;
	    jQuery.escapeSelector = Sizzle.escape;

	    var dir = function (elem, dir, until) {
	      var matched = [],
	          truncate = until !== undefined;

	      while ((elem = elem[dir]) && elem.nodeType !== 9) {
	        if (elem.nodeType === 1) {
	          if (truncate && jQuery(elem).is(until)) {
	            break;
	          }

	          matched.push(elem);
	        }
	      }

	      return matched;
	    };

	    var siblings = function (n, elem) {
	      var matched = [];

	      for (; n; n = n.nextSibling) {
	        if (n.nodeType === 1 && n !== elem) {
	          matched.push(n);
	        }
	      }

	      return matched;
	    };

	    var rneedsContext = jQuery.expr.match.needsContext;

	    function nodeName(elem, name) {
	      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	    }

	    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

	    function winnow(elements, qualifier, not) {
	      if (isFunction(qualifier)) {
	        return jQuery.grep(elements, function (elem, i) {
	          return !!qualifier.call(elem, i, elem) !== not;
	        });
	      } // Single element


	      if (qualifier.nodeType) {
	        return jQuery.grep(elements, function (elem) {
	          return elem === qualifier !== not;
	        });
	      } // Arraylike of elements (jQuery, arguments, Array)


	      if (typeof qualifier !== "string") {
	        return jQuery.grep(elements, function (elem) {
	          return indexOf.call(qualifier, elem) > -1 !== not;
	        });
	      } // Filtered directly for both simple and complex selectors


	      return jQuery.filter(qualifier, elements, not);
	    }

	    jQuery.filter = function (expr, elems, not) {
	      var elem = elems[0];

	      if (not) {
	        expr = ":not(" + expr + ")";
	      }

	      if (elems.length === 1 && elem.nodeType === 1) {
	        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
	      }

	      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
	        return elem.nodeType === 1;
	      }));
	    };

	    jQuery.fn.extend({
	      find: function (selector) {
	        var i,
	            ret,
	            len = this.length,
	            self = this;

	        if (typeof selector !== "string") {
	          return this.pushStack(jQuery(selector).filter(function () {
	            for (i = 0; i < len; i++) {
	              if (jQuery.contains(self[i], this)) {
	                return true;
	              }
	            }
	          }));
	        }

	        ret = this.pushStack([]);

	        for (i = 0; i < len; i++) {
	          jQuery.find(selector, self[i], ret);
	        }

	        return len > 1 ? jQuery.uniqueSort(ret) : ret;
	      },
	      filter: function (selector) {
	        return this.pushStack(winnow(this, selector || [], false));
	      },
	      not: function (selector) {
	        return this.pushStack(winnow(this, selector || [], true));
	      },
	      is: function (selector) {
	        return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
	        // so $("p:first").is("p:last") won't return true for a doc with two "p".
	        typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
	      }
	    }); // Initialize a jQuery object
	    // A central reference to the root jQuery(document)

	    var rootjQuery,
	        // A simple way to check for HTML strings
	    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	    // Strict HTML recognition (#11290: must start with <)
	    // Shortcut simple #id case for speed
	    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	        init = jQuery.fn.init = function (selector, context, root) {
	      var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

	      if (!selector) {
	        return this;
	      } // Method init() accepts an alternate rootjQuery
	      // so migrate can support jQuery.sub (gh-2101)


	      root = root || rootjQuery; // Handle HTML strings

	      if (typeof selector === "string") {
	        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
	          // Assume that strings that start and end with <> are HTML and skip the regex check
	          match = [null, selector, null];
	        } else {
	          match = rquickExpr.exec(selector);
	        } // Match html or make sure no context is specified for #id


	        if (match && (match[1] || !context)) {
	          // HANDLE: $(html) -> $(array)
	          if (match[1]) {
	            context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
	            // Intentionally let the error be thrown if parseHTML is not present

	            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

	            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
	              for (match in context) {
	                // Properties of context are called as methods if possible
	                if (isFunction(this[match])) {
	                  this[match](context[match]); // ...and otherwise set as attributes
	                } else {
	                  this.attr(match, context[match]);
	                }
	              }
	            }

	            return this; // HANDLE: $(#id)
	          } else {
	            elem = document.getElementById(match[2]);

	            if (elem) {
	              // Inject the element directly into the jQuery object
	              this[0] = elem;
	              this.length = 1;
	            }

	            return this;
	          } // HANDLE: $(expr, $(...))

	        } else if (!context || context.jquery) {
	          return (context || root).find(selector); // HANDLE: $(expr, context)
	          // (which is just equivalent to: $(context).find(expr)
	        } else {
	          return this.constructor(context).find(selector);
	        } // HANDLE: $(DOMElement)

	      } else if (selector.nodeType) {
	        this[0] = selector;
	        this.length = 1;
	        return this; // HANDLE: $(function)
	        // Shortcut for document ready
	      } else if (isFunction(selector)) {
	        return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
	        selector(jQuery);
	      }

	      return jQuery.makeArray(selector, this);
	    }; // Give the init function the jQuery prototype for later instantiation


	    init.prototype = jQuery.fn; // Initialize central reference

	    rootjQuery = jQuery(document);
	    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	        // Methods guaranteed to produce a unique set when starting from a unique set
	    guaranteedUnique = {
	      children: true,
	      contents: true,
	      next: true,
	      prev: true
	    };
	    jQuery.fn.extend({
	      has: function (target) {
	        var targets = jQuery(target, this),
	            l = targets.length;
	        return this.filter(function () {
	          var i = 0;

	          for (; i < l; i++) {
	            if (jQuery.contains(this, targets[i])) {
	              return true;
	            }
	          }
	        });
	      },
	      closest: function (selectors, context) {
	        var cur,
	            i = 0,
	            l = this.length,
	            matched = [],
	            targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

	        if (!rneedsContext.test(selectors)) {
	          for (; i < l; i++) {
	            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
	              // Always skip document fragments
	              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
	              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
	                matched.push(cur);
	                break;
	              }
	            }
	          }
	        }

	        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
	      },
	      // Determine the position of an element within the set
	      index: function (elem) {
	        // No argument, return index in parent
	        if (!elem) {
	          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	        } // Index in selector


	        if (typeof elem === "string") {
	          return indexOf.call(jQuery(elem), this[0]);
	        } // Locate the position of the desired element


	        return indexOf.call(this, // If it receives a jQuery object, the first element is used
	        elem.jquery ? elem[0] : elem);
	      },
	      add: function (selector, context) {
	        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
	      },
	      addBack: function (selector) {
	        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
	      }
	    });

	    function sibling(cur, dir) {
	      while ((cur = cur[dir]) && cur.nodeType !== 1) {}

	      return cur;
	    }

	    jQuery.each({
	      parent: function (elem) {
	        var parent = elem.parentNode;
	        return parent && parent.nodeType !== 11 ? parent : null;
	      },
	      parents: function (elem) {
	        return dir(elem, "parentNode");
	      },
	      parentsUntil: function (elem, _i, until) {
	        return dir(elem, "parentNode", until);
	      },
	      next: function (elem) {
	        return sibling(elem, "nextSibling");
	      },
	      prev: function (elem) {
	        return sibling(elem, "previousSibling");
	      },
	      nextAll: function (elem) {
	        return dir(elem, "nextSibling");
	      },
	      prevAll: function (elem) {
	        return dir(elem, "previousSibling");
	      },
	      nextUntil: function (elem, _i, until) {
	        return dir(elem, "nextSibling", until);
	      },
	      prevUntil: function (elem, _i, until) {
	        return dir(elem, "previousSibling", until);
	      },
	      siblings: function (elem) {
	        return siblings((elem.parentNode || {}).firstChild, elem);
	      },
	      children: function (elem) {
	        return siblings(elem.firstChild);
	      },
	      contents: function (elem) {
	        if (elem.contentDocument != null && // Support: IE 11+
	        // <object> elements with no `data` attribute has an object
	        // `contentDocument` with a `null` prototype.
	        getProto(elem.contentDocument)) {
	          return elem.contentDocument;
	        } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.


	        if (nodeName(elem, "template")) {
	          elem = elem.content || elem;
	        }

	        return jQuery.merge([], elem.childNodes);
	      }
	    }, function (name, fn) {
	      jQuery.fn[name] = function (until, selector) {
	        var matched = jQuery.map(this, fn, until);

	        if (name.slice(-5) !== "Until") {
	          selector = until;
	        }

	        if (selector && typeof selector === "string") {
	          matched = jQuery.filter(selector, matched);
	        }

	        if (this.length > 1) {
	          // Remove duplicates
	          if (!guaranteedUnique[name]) {
	            jQuery.uniqueSort(matched);
	          } // Reverse order for parents* and prev-derivatives


	          if (rparentsprev.test(name)) {
	            matched.reverse();
	          }
	        }

	        return this.pushStack(matched);
	      };
	    });
	    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

	    function createOptions(options) {
	      var object = {};
	      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
	        object[flag] = true;
	      });
	      return object;
	    }
	    /*
	     * Create a callback list using the following parameters:
	     *
	     *	options: an optional list of space-separated options that will change how
	     *			the callback list behaves or a more traditional option object
	     *
	     * By default a callback list will act like an event callback list and can be
	     * "fired" multiple times.
	     *
	     * Possible options:
	     *
	     *	once:			will ensure the callback list can only be fired once (like a Deferred)
	     *
	     *	memory:			will keep track of previous values and will call any callback added
	     *					after the list has been fired right away with the latest "memorized"
	     *					values (like a Deferred)
	     *
	     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	     *
	     *	stopOnFalse:	interrupt callings when a callback returns false
	     *
	     */


	    jQuery.Callbacks = function (options) {
	      // Convert options from String-formatted to Object-formatted if needed
	      // (we check in cache first)
	      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

	      var // Flag to know if list is currently firing
	      firing,
	          // Last fire value for non-forgettable lists
	      memory,
	          // Flag to know if list was already fired
	      fired,
	          // Flag to prevent firing
	      locked,
	          // Actual callback list
	      list = [],
	          // Queue of execution data for repeatable lists
	      queue = [],
	          // Index of currently firing callback (modified by add/remove as needed)
	      firingIndex = -1,
	          // Fire callbacks
	      fire = function () {
	        // Enforce single-firing
	        locked = locked || options.once; // Execute callbacks for all pending executions,
	        // respecting firingIndex overrides and runtime changes

	        fired = firing = true;

	        for (; queue.length; firingIndex = -1) {
	          memory = queue.shift();

	          while (++firingIndex < list.length) {
	            // Run callback and check for early termination
	            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
	              // Jump to end and forget the data so .add doesn't re-fire
	              firingIndex = list.length;
	              memory = false;
	            }
	          }
	        } // Forget the data if we're done with it


	        if (!options.memory) {
	          memory = false;
	        }

	        firing = false; // Clean up if we're done firing for good

	        if (locked) {
	          // Keep an empty list if we have data for future add calls
	          if (memory) {
	            list = []; // Otherwise, this object is spent
	          } else {
	            list = "";
	          }
	        }
	      },
	          // Actual Callbacks object
	      self = {
	        // Add a callback or a collection of callbacks to the list
	        add: function () {
	          if (list) {
	            // If we have memory from a past run, we should fire after adding
	            if (memory && !firing) {
	              firingIndex = list.length - 1;
	              queue.push(memory);
	            }

	            (function add(args) {
	              jQuery.each(args, function (_, arg) {
	                if (isFunction(arg)) {
	                  if (!options.unique || !self.has(arg)) {
	                    list.push(arg);
	                  }
	                } else if (arg && arg.length && toType(arg) !== "string") {
	                  // Inspect recursively
	                  add(arg);
	                }
	              });
	            })(arguments);

	            if (memory && !firing) {
	              fire();
	            }
	          }

	          return this;
	        },
	        // Remove a callback from the list
	        remove: function () {
	          jQuery.each(arguments, function (_, arg) {
	            var index;

	            while ((index = jQuery.inArray(arg, list, index)) > -1) {
	              list.splice(index, 1); // Handle firing indexes

	              if (index <= firingIndex) {
	                firingIndex--;
	              }
	            }
	          });
	          return this;
	        },
	        // Check if a given callback is in the list.
	        // If no argument is given, return whether or not list has callbacks attached.
	        has: function (fn) {
	          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
	        },
	        // Remove all callbacks from the list
	        empty: function () {
	          if (list) {
	            list = [];
	          }

	          return this;
	        },
	        // Disable .fire and .add
	        // Abort any current/pending executions
	        // Clear all callbacks and values
	        disable: function () {
	          locked = queue = [];
	          list = memory = "";
	          return this;
	        },
	        disabled: function () {
	          return !list;
	        },
	        // Disable .fire
	        // Also disable .add unless we have memory (since it would have no effect)
	        // Abort any pending executions
	        lock: function () {
	          locked = queue = [];

	          if (!memory && !firing) {
	            list = memory = "";
	          }

	          return this;
	        },
	        locked: function () {
	          return !!locked;
	        },
	        // Call all callbacks with the given context and arguments
	        fireWith: function (context, args) {
	          if (!locked) {
	            args = args || [];
	            args = [context, args.slice ? args.slice() : args];
	            queue.push(args);

	            if (!firing) {
	              fire();
	            }
	          }

	          return this;
	        },
	        // Call all the callbacks with the given arguments
	        fire: function () {
	          self.fireWith(this, arguments);
	          return this;
	        },
	        // To know if the callbacks have already been called at least once
	        fired: function () {
	          return !!fired;
	        }
	      };

	      return self;
	    };

	    function Identity(v) {
	      return v;
	    }

	    function Thrower(ex) {
	      throw ex;
	    }

	    function adoptValue(value, resolve, reject, noValue) {
	      var method;

	      try {
	        // Check for promise aspect first to privilege synchronous behavior
	        if (value && isFunction(method = value.promise)) {
	          method.call(value).done(resolve).fail(reject); // Other thenables
	        } else if (value && isFunction(method = value.then)) {
	          method.call(value, resolve, reject); // Other non-thenables
	        } else {
	          // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
	          // * false: [ value ].slice( 0 ) => resolve( value )
	          // * true: [ value ].slice( 1 ) => resolve()
	          resolve.apply(undefined, [value].slice(noValue));
	        } // For Promises/A+, convert exceptions into rejections
	        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	        // Deferred#then to conditionally suppress rejection.

	      } catch (value) {
	        // Support: Android 4.0 only
	        // Strict mode functions invoked without .call/.apply get global-object context
	        reject.apply(undefined, [value]);
	      }
	    }

	    jQuery.extend({
	      Deferred: function (func) {
	        var tuples = [// action, add listener, callbacks,
	        // ... .then handlers, argument index, [final state]
	        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
	            state = "pending",
	            promise = {
	          state: function () {
	            return state;
	          },
	          always: function () {
	            deferred.done(arguments).fail(arguments);
	            return this;
	          },
	          catch: function (fn) {
	            return promise.then(null, fn);
	          },
	          // Keep pipe for back-compat
	          pipe: function ()
	          /* fnDone, fnFail, fnProgress */
	          {
	            var fns = arguments;
	            return jQuery.Deferred(function (newDefer) {
	              jQuery.each(tuples, function (_i, tuple) {
	                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
	                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
	                // deferred.done(function() { bind to newDefer or newDefer.resolve })
	                // deferred.fail(function() { bind to newDefer or newDefer.reject })

	                deferred[tuple[1]](function () {
	                  var returned = fn && fn.apply(this, arguments);

	                  if (returned && isFunction(returned.promise)) {
	                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
	                  } else {
	                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
	                  }
	                });
	              });
	              fns = null;
	            }).promise();
	          },
	          then: function (onFulfilled, onRejected, onProgress) {
	            var maxDepth = 0;

	            function resolve(depth, deferred, handler, special) {
	              return function () {
	                var that = this,
	                    args = arguments,
	                    mightThrow = function () {
	                  var returned, then; // Support: Promises/A+ section 2.3.3.3.3
	                  // https://promisesaplus.com/#point-59
	                  // Ignore double-resolution attempts

	                  if (depth < maxDepth) {
	                    return;
	                  }

	                  returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
	                  // https://promisesaplus.com/#point-48

	                  if (returned === deferred.promise()) {
	                    throw new TypeError("Thenable self-resolution");
	                  } // Support: Promises/A+ sections 2.3.3.1, 3.5
	                  // https://promisesaplus.com/#point-54
	                  // https://promisesaplus.com/#point-75
	                  // Retrieve `then` only once


	                  then = returned && ( // Support: Promises/A+ section 2.3.4
	                  // https://promisesaplus.com/#point-64
	                  // Only check objects and functions for thenability
	                  typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

	                  if (isFunction(then)) {
	                    // Special processors (notify) just wait for resolution
	                    if (special) {
	                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
	                    } else {
	                      // ...and disregard older resolution values
	                      maxDepth++;
	                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
	                    } // Handle all other returned values

	                  } else {
	                    // Only substitute handlers pass on context
	                    // and multiple values (non-spec behavior)
	                    if (handler !== Identity) {
	                      that = undefined;
	                      args = [returned];
	                    } // Process the value(s)
	                    // Default process is resolve


	                    (special || deferred.resolveWith)(that, args);
	                  }
	                },
	                    // Only normal processors (resolve) catch and reject exceptions
	                process = special ? mightThrow : function () {
	                  try {
	                    mightThrow();
	                  } catch (e) {
	                    if (jQuery.Deferred.exceptionHook) {
	                      jQuery.Deferred.exceptionHook(e, process.stackTrace);
	                    } // Support: Promises/A+ section 2.3.3.3.4.1
	                    // https://promisesaplus.com/#point-61
	                    // Ignore post-resolution exceptions


	                    if (depth + 1 >= maxDepth) {
	                      // Only substitute handlers pass on context
	                      // and multiple values (non-spec behavior)
	                      if (handler !== Thrower) {
	                        that = undefined;
	                        args = [e];
	                      }

	                      deferred.rejectWith(that, args);
	                    }
	                  }
	                }; // Support: Promises/A+ section 2.3.3.3.1
	                // https://promisesaplus.com/#point-57
	                // Re-resolve promises immediately to dodge false rejection from
	                // subsequent errors


	                if (depth) {
	                  process();
	                } else {
	                  // Call an optional hook to record the stack, in case of exception
	                  // since it's otherwise lost when execution goes async
	                  if (jQuery.Deferred.getStackHook) {
	                    process.stackTrace = jQuery.Deferred.getStackHook();
	                  }

	                  window.setTimeout(process);
	                }
	              };
	            }

	            return jQuery.Deferred(function (newDefer) {
	              // progress_handlers.add( ... )
	              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

	              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

	              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
	            }).promise();
	          },
	          // Get a promise for this deferred
	          // If obj is provided, the promise aspect is added to the object
	          promise: function (obj) {
	            return obj != null ? jQuery.extend(obj, promise) : promise;
	          }
	        },
	            deferred = {}; // Add list-specific methods

	        jQuery.each(tuples, function (i, tuple) {
	          var list = tuple[2],
	              stateString = tuple[5]; // promise.progress = list.add
	          // promise.done = list.add
	          // promise.fail = list.add

	          promise[tuple[1]] = list.add; // Handle state

	          if (stateString) {
	            list.add(function () {
	              // state = "resolved" (i.e., fulfilled)
	              // state = "rejected"
	              state = stateString;
	            }, // rejected_callbacks.disable
	            // fulfilled_callbacks.disable
	            tuples[3 - i][2].disable, // rejected_handlers.disable
	            // fulfilled_handlers.disable
	            tuples[3 - i][3].disable, // progress_callbacks.lock
	            tuples[0][2].lock, // progress_handlers.lock
	            tuples[0][3].lock);
	          } // progress_handlers.fire
	          // fulfilled_handlers.fire
	          // rejected_handlers.fire


	          list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
	          // deferred.resolve = function() { deferred.resolveWith(...) }
	          // deferred.reject = function() { deferred.rejectWith(...) }

	          deferred[tuple[0]] = function () {
	            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
	            return this;
	          }; // deferred.notifyWith = list.fireWith
	          // deferred.resolveWith = list.fireWith
	          // deferred.rejectWith = list.fireWith


	          deferred[tuple[0] + "With"] = list.fireWith;
	        }); // Make the deferred a promise

	        promise.promise(deferred); // Call given func if any

	        if (func) {
	          func.call(deferred, deferred);
	        } // All done!


	        return deferred;
	      },
	      // Deferred helper
	      when: function (singleValue) {
	        var // count of uncompleted subordinates
	        remaining = arguments.length,
	            // count of unprocessed arguments
	        i = remaining,
	            // subordinate fulfillment data
	        resolveContexts = Array(i),
	            resolveValues = slice.call(arguments),
	            // the master Deferred
	        master = jQuery.Deferred(),
	            // subordinate callback factory
	        updateFunc = function (i) {
	          return function (value) {
	            resolveContexts[i] = this;
	            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

	            if (! --remaining) {
	              master.resolveWith(resolveContexts, resolveValues);
	            }
	          };
	        }; // Single- and empty arguments are adopted like Promise.resolve


	        if (remaining <= 1) {
	          adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

	          if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
	            return master.then();
	          }
	        } // Multiple arguments are aggregated like Promise.all array elements


	        while (i--) {
	          adoptValue(resolveValues[i], updateFunc(i), master.reject);
	        }

	        return master.promise();
	      }
	    }); // These usually indicate a programmer mistake during development,
	    // warn about them ASAP rather than swallowing them by default.

	    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	    jQuery.Deferred.exceptionHook = function (error, stack) {
	      // Support: IE 8 - 9 only
	      // Console exists when dev tools are open, which can happen at any time
	      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
	        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
	      }
	    };

	    jQuery.readyException = function (error) {
	      window.setTimeout(function () {
	        throw error;
	      });
	    }; // The deferred used on DOM ready


	    var readyList = jQuery.Deferred();

	    jQuery.fn.ready = function (fn) {
	      readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
	      // happens at the time of error handling instead of callback
	      // registration.
	      .catch(function (error) {
	        jQuery.readyException(error);
	      });
	      return this;
	    };

	    jQuery.extend({
	      // Is the DOM ready to be used? Set to true once it occurs.
	      isReady: false,
	      // A counter to track how many items to wait for before
	      // the ready event fires. See #6781
	      readyWait: 1,
	      // Handle when the DOM is ready
	      ready: function (wait) {
	        // Abort if there are pending holds or we're already ready
	        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
	          return;
	        } // Remember that the DOM is ready


	        jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

	        if (wait !== true && --jQuery.readyWait > 0) {
	          return;
	        } // If there are functions bound, to execute


	        readyList.resolveWith(document, [jQuery]);
	      }
	    });
	    jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

	    function completed() {
	      document.removeEventListener("DOMContentLoaded", completed);
	      window.removeEventListener("load", completed);
	      jQuery.ready();
	    } // Catch cases where $(document).ready() is called
	    // after the browser event has already occurred.
	    // Support: IE <=9 - 10 only
	    // Older IE sometimes signals "interactive" too soon


	    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
	      // Handle it asynchronously to allow scripts the opportunity to delay ready
	      window.setTimeout(jQuery.ready);
	    } else {
	      // Use the handy event callback
	      document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

	      window.addEventListener("load", completed);
	    } // Multifunctional method to get and set values of a collection
	    // The value/s can optionally be executed if it's a function


	    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
	      var i = 0,
	          len = elems.length,
	          bulk = key == null; // Sets many values

	      if (toType(key) === "object") {
	        chainable = true;

	        for (i in key) {
	          access(elems, fn, i, key[i], true, emptyGet, raw);
	        } // Sets one value

	      } else if (value !== undefined) {
	        chainable = true;

	        if (!isFunction(value)) {
	          raw = true;
	        }

	        if (bulk) {
	          // Bulk operations run against the entire set
	          if (raw) {
	            fn.call(elems, value);
	            fn = null; // ...except when executing function values
	          } else {
	            bulk = fn;

	            fn = function (elem, _key, value) {
	              return bulk.call(jQuery(elem), value);
	            };
	          }
	        }

	        if (fn) {
	          for (; i < len; i++) {
	            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
	          }
	        }
	      }

	      if (chainable) {
	        return elems;
	      } // Gets


	      if (bulk) {
	        return fn.call(elems);
	      }

	      return len ? fn(elems[0], key) : emptyGet;
	    }; // Matches dashed string for camelizing


	    var rmsPrefix = /^-ms-/,
	        rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

	    function fcamelCase(_all, letter) {
	      return letter.toUpperCase();
	    } // Convert dashed to camelCase; used by the css and data modules
	    // Support: IE <=9 - 11, Edge 12 - 15
	    // Microsoft forgot to hump their vendor prefix (#9572)


	    function camelCase(string) {
	      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
	    }

	    var acceptData = function (owner) {
	      // Accepts only:
	      //  - Node
	      //    - Node.ELEMENT_NODE
	      //    - Node.DOCUMENT_NODE
	      //  - Object
	      //    - Any
	      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	    };

	    function Data() {
	      this.expando = jQuery.expando + Data.uid++;
	    }

	    Data.uid = 1;
	    Data.prototype = {
	      cache: function (owner) {
	        // Check if the owner object already has a cache
	        var value = owner[this.expando]; // If not, create one

	        if (!value) {
	          value = {}; // We can accept data for non-element nodes in modern browsers,
	          // but we should not, see #8335.
	          // Always return an empty object.

	          if (acceptData(owner)) {
	            // If it is a node unlikely to be stringify-ed or looped over
	            // use plain assignment
	            if (owner.nodeType) {
	              owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
	              // configurable must be true to allow the property to be
	              // deleted when data is removed
	            } else {
	              Object.defineProperty(owner, this.expando, {
	                value: value,
	                configurable: true
	              });
	            }
	          }
	        }

	        return value;
	      },
	      set: function (owner, data, value) {
	        var prop,
	            cache = this.cache(owner); // Handle: [ owner, key, value ] args
	        // Always use camelCase key (gh-2257)

	        if (typeof data === "string") {
	          cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
	        } else {
	          // Copy the properties one-by-one to the cache object
	          for (prop in data) {
	            cache[camelCase(prop)] = data[prop];
	          }
	        }

	        return cache;
	      },
	      get: function (owner, key) {
	        return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
	        owner[this.expando] && owner[this.expando][camelCase(key)];
	      },
	      access: function (owner, key, value) {
	        // In cases where either:
	        //
	        //   1. No key was specified
	        //   2. A string key was specified, but no value provided
	        //
	        // Take the "read" path and allow the get method to determine
	        // which value to return, respectively either:
	        //
	        //   1. The entire cache object
	        //   2. The data stored at the key
	        //
	        if (key === undefined || key && typeof key === "string" && value === undefined) {
	          return this.get(owner, key);
	        } // When the key is not a string, or both a key and value
	        // are specified, set or extend (existing objects) with either:
	        //
	        //   1. An object of properties
	        //   2. A key and value
	        //


	        this.set(owner, key, value); // Since the "set" path can have two possible entry points
	        // return the expected data based on which path was taken[*]

	        return value !== undefined ? value : key;
	      },
	      remove: function (owner, key) {
	        var i,
	            cache = owner[this.expando];

	        if (cache === undefined) {
	          return;
	        }

	        if (key !== undefined) {
	          // Support array or space separated string of keys
	          if (Array.isArray(key)) {
	            // If key is an array of keys...
	            // We always set camelCase keys, so remove that.
	            key = key.map(camelCase);
	          } else {
	            key = camelCase(key); // If a key with the spaces exists, use it.
	            // Otherwise, create an array by matching non-whitespace

	            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
	          }

	          i = key.length;

	          while (i--) {
	            delete cache[key[i]];
	          }
	        } // Remove the expando if there's no more data


	        if (key === undefined || jQuery.isEmptyObject(cache)) {
	          // Support: Chrome <=35 - 45
	          // Webkit & Blink performance suffers when deleting properties
	          // from DOM nodes, so set to undefined instead
	          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
	          if (owner.nodeType) {
	            owner[this.expando] = undefined;
	          } else {
	            delete owner[this.expando];
	          }
	        }
	      },
	      hasData: function (owner) {
	        var cache = owner[this.expando];
	        return cache !== undefined && !jQuery.isEmptyObject(cache);
	      }
	    };
	    var dataPriv = new Data();
	    var dataUser = new Data(); //	Implementation Summary
	    //
	    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
	    //	2. Improve the module's maintainability by reducing the storage
	    //		paths to a single mechanism.
	    //	3. Use the same single mechanism to support "private" and "user" data.
	    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
	    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	        rmultiDash = /[A-Z]/g;

	    function getData(data) {
	      if (data === "true") {
	        return true;
	      }

	      if (data === "false") {
	        return false;
	      }

	      if (data === "null") {
	        return null;
	      } // Only convert to a number if it doesn't change the string


	      if (data === +data + "") {
	        return +data;
	      }

	      if (rbrace.test(data)) {
	        return JSON.parse(data);
	      }

	      return data;
	    }

	    function dataAttr(elem, key, data) {
	      var name; // If nothing was found internally, try to fetch any
	      // data from the HTML5 data-* attribute

	      if (data === undefined && elem.nodeType === 1) {
	        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
	        data = elem.getAttribute(name);

	        if (typeof data === "string") {
	          try {
	            data = getData(data);
	          } catch (e) {} // Make sure we set the data so it isn't changed later


	          dataUser.set(elem, key, data);
	        } else {
	          data = undefined;
	        }
	      }

	      return data;
	    }

	    jQuery.extend({
	      hasData: function (elem) {
	        return dataUser.hasData(elem) || dataPriv.hasData(elem);
	      },
	      data: function (elem, name, data) {
	        return dataUser.access(elem, name, data);
	      },
	      removeData: function (elem, name) {
	        dataUser.remove(elem, name);
	      },
	      // TODO: Now that all calls to _data and _removeData have been replaced
	      // with direct calls to dataPriv methods, these can be deprecated.
	      _data: function (elem, name, data) {
	        return dataPriv.access(elem, name, data);
	      },
	      _removeData: function (elem, name) {
	        dataPriv.remove(elem, name);
	      }
	    });
	    jQuery.fn.extend({
	      data: function (key, value) {
	        var i,
	            name,
	            data,
	            elem = this[0],
	            attrs = elem && elem.attributes; // Gets all values

	        if (key === undefined) {
	          if (this.length) {
	            data = dataUser.get(elem);

	            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
	              i = attrs.length;

	              while (i--) {
	                // Support: IE 11 only
	                // The attrs elements can be null (#14894)
	                if (attrs[i]) {
	                  name = attrs[i].name;

	                  if (name.indexOf("data-") === 0) {
	                    name = camelCase(name.slice(5));
	                    dataAttr(elem, name, data[name]);
	                  }
	                }
	              }

	              dataPriv.set(elem, "hasDataAttrs", true);
	            }
	          }

	          return data;
	        } // Sets multiple values


	        if (typeof key === "object") {
	          return this.each(function () {
	            dataUser.set(this, key);
	          });
	        }

	        return access(this, function (value) {
	          var data; // The calling jQuery object (element matches) is not empty
	          // (and therefore has an element appears at this[ 0 ]) and the
	          // `value` parameter was not undefined. An empty jQuery object
	          // will result in `undefined` for elem = this[ 0 ] which will
	          // throw an exception if an attempt to read a data cache is made.

	          if (elem && value === undefined) {
	            // Attempt to get data from the cache
	            // The key will always be camelCased in Data
	            data = dataUser.get(elem, key);

	            if (data !== undefined) {
	              return data;
	            } // Attempt to "discover" the data in
	            // HTML5 custom data-* attrs


	            data = dataAttr(elem, key);

	            if (data !== undefined) {
	              return data;
	            } // We tried really hard, but the data doesn't exist.


	            return;
	          } // Set the data...


	          this.each(function () {
	            // We always store the camelCased key
	            dataUser.set(this, key, value);
	          });
	        }, null, value, arguments.length > 1, null, true);
	      },
	      removeData: function (key) {
	        return this.each(function () {
	          dataUser.remove(this, key);
	        });
	      }
	    });
	    jQuery.extend({
	      queue: function (elem, type, data) {
	        var queue;

	        if (elem) {
	          type = (type || "fx") + "queue";
	          queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

	          if (data) {
	            if (!queue || Array.isArray(data)) {
	              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
	            } else {
	              queue.push(data);
	            }
	          }

	          return queue || [];
	        }
	      },
	      dequeue: function (elem, type) {
	        type = type || "fx";

	        var queue = jQuery.queue(elem, type),
	            startLength = queue.length,
	            fn = queue.shift(),
	            hooks = jQuery._queueHooks(elem, type),
	            next = function () {
	          jQuery.dequeue(elem, type);
	        }; // If the fx queue is dequeued, always remove the progress sentinel


	        if (fn === "inprogress") {
	          fn = queue.shift();
	          startLength--;
	        }

	        if (fn) {
	          // Add a progress sentinel to prevent the fx queue from being
	          // automatically dequeued
	          if (type === "fx") {
	            queue.unshift("inprogress");
	          } // Clear up the last queue stop function


	          delete hooks.stop;
	          fn.call(elem, next, hooks);
	        }

	        if (!startLength && hooks) {
	          hooks.empty.fire();
	        }
	      },
	      // Not public - generate a queueHooks object, or return the current one
	      _queueHooks: function (elem, type) {
	        var key = type + "queueHooks";
	        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
	          empty: jQuery.Callbacks("once memory").add(function () {
	            dataPriv.remove(elem, [type + "queue", key]);
	          })
	        });
	      }
	    });
	    jQuery.fn.extend({
	      queue: function (type, data) {
	        var setter = 2;

	        if (typeof type !== "string") {
	          data = type;
	          type = "fx";
	          setter--;
	        }

	        if (arguments.length < setter) {
	          return jQuery.queue(this[0], type);
	        }

	        return data === undefined ? this : this.each(function () {
	          var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

	          jQuery._queueHooks(this, type);

	          if (type === "fx" && queue[0] !== "inprogress") {
	            jQuery.dequeue(this, type);
	          }
	        });
	      },
	      dequeue: function (type) {
	        return this.each(function () {
	          jQuery.dequeue(this, type);
	        });
	      },
	      clearQueue: function (type) {
	        return this.queue(type || "fx", []);
	      },
	      // Get a promise resolved when queues of a certain type
	      // are emptied (fx is the type by default)
	      promise: function (type, obj) {
	        var tmp,
	            count = 1,
	            defer = jQuery.Deferred(),
	            elements = this,
	            i = this.length,
	            resolve = function () {
	          if (! --count) {
	            defer.resolveWith(elements, [elements]);
	          }
	        };

	        if (typeof type !== "string") {
	          obj = type;
	          type = undefined;
	        }

	        type = type || "fx";

	        while (i--) {
	          tmp = dataPriv.get(elements[i], type + "queueHooks");

	          if (tmp && tmp.empty) {
	            count++;
	            tmp.empty.add(resolve);
	          }
	        }

	        resolve();
	        return defer.promise(obj);
	      }
	    });
	    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
	    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
	    var cssExpand = ["Top", "Right", "Bottom", "Left"];
	    var documentElement = document.documentElement;

	    var isAttached = function (elem) {
	      return jQuery.contains(elem.ownerDocument, elem);
	    },
	        composed = {
	      composed: true
	    }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	    // Check attachment across shadow DOM boundaries when possible (gh-3504)
	    // Support: iOS 10.0-10.2 only
	    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	    // leading to errors. We need to check for `getRootNode`.


	    if (documentElement.getRootNode) {
	      isAttached = function (elem) {
	        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
	      };
	    }

	    var isHiddenWithinTree = function (elem, el) {
	      // isHiddenWithinTree might be called from jQuery#filter function;
	      // in that case, element will be second argument
	      elem = el || elem; // Inline style trumps all

	      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
	      // Support: Firefox <=43 - 45
	      // Disconnected elements can have computed display: none, so first confirm that elem is
	      // in the document.
	      isAttached(elem) && jQuery.css(elem, "display") === "none";
	    };

	    function adjustCSS(elem, prop, valueParts, tween) {
	      var adjusted,
	          scale,
	          maxIterations = 20,
	          currentValue = tween ? function () {
	        return tween.cur();
	      } : function () {
	        return jQuery.css(elem, prop, "");
	      },
	          initial = currentValue(),
	          unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
	          // Starting value computation is required for potential unit mismatches
	      initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

	      if (initialInUnit && initialInUnit[3] !== unit) {
	        // Support: Firefox <=54
	        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
	        initial = initial / 2; // Trust units reported by jQuery.css

	        unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

	        initialInUnit = +initial || 1;

	        while (maxIterations--) {
	          // Evaluate and update our best guess (doubling guesses that zero out).
	          // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
	          jQuery.style(elem, prop, initialInUnit + unit);

	          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
	            maxIterations = 0;
	          }

	          initialInUnit = initialInUnit / scale;
	        }

	        initialInUnit = initialInUnit * 2;
	        jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

	        valueParts = valueParts || [];
	      }

	      if (valueParts) {
	        initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

	        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

	        if (tween) {
	          tween.unit = unit;
	          tween.start = initialInUnit;
	          tween.end = adjusted;
	        }
	      }

	      return adjusted;
	    }

	    var defaultDisplayMap = {};

	    function getDefaultDisplay(elem) {
	      var temp,
	          doc = elem.ownerDocument,
	          nodeName = elem.nodeName,
	          display = defaultDisplayMap[nodeName];

	      if (display) {
	        return display;
	      }

	      temp = doc.body.appendChild(doc.createElement(nodeName));
	      display = jQuery.css(temp, "display");
	      temp.parentNode.removeChild(temp);

	      if (display === "none") {
	        display = "block";
	      }

	      defaultDisplayMap[nodeName] = display;
	      return display;
	    }

	    function showHide(elements, show) {
	      var display,
	          elem,
	          values = [],
	          index = 0,
	          length = elements.length; // Determine new display value for elements that need to change

	      for (; index < length; index++) {
	        elem = elements[index];

	        if (!elem.style) {
	          continue;
	        }

	        display = elem.style.display;

	        if (show) {
	          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
	          // check is required in this first loop unless we have a nonempty display value (either
	          // inline or about-to-be-restored)
	          if (display === "none") {
	            values[index] = dataPriv.get(elem, "display") || null;

	            if (!values[index]) {
	              elem.style.display = "";
	            }
	          }

	          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
	            values[index] = getDefaultDisplay(elem);
	          }
	        } else {
	          if (display !== "none") {
	            values[index] = "none"; // Remember what we're overwriting

	            dataPriv.set(elem, "display", display);
	          }
	        }
	      } // Set the display of the elements in a second loop to avoid constant reflow


	      for (index = 0; index < length; index++) {
	        if (values[index] != null) {
	          elements[index].style.display = values[index];
	        }
	      }

	      return elements;
	    }

	    jQuery.fn.extend({
	      show: function () {
	        return showHide(this, true);
	      },
	      hide: function () {
	        return showHide(this);
	      },
	      toggle: function (state) {
	        if (typeof state === "boolean") {
	          return state ? this.show() : this.hide();
	        }

	        return this.each(function () {
	          if (isHiddenWithinTree(this)) {
	            jQuery(this).show();
	          } else {
	            jQuery(this).hide();
	          }
	        });
	      }
	    });
	    var rcheckableType = /^(?:checkbox|radio)$/i;
	    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
	    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

	    (function () {
	      var fragment = document.createDocumentFragment(),
	          div = fragment.appendChild(document.createElement("div")),
	          input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
	      // Check state lost if the name is set (#11217)
	      // Support: Windows Web Apps (WWA)
	      // `name` and `type` must use .setAttribute for WWA (#14901)

	      input.setAttribute("type", "radio");
	      input.setAttribute("checked", "checked");
	      input.setAttribute("name", "t");
	      div.appendChild(input); // Support: Android <=4.1 only
	      // Older WebKit doesn't clone checked state correctly in fragments

	      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
	      // Make sure textarea (and checkbox) defaultValue is properly cloned

	      div.innerHTML = "<textarea>x</textarea>";
	      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
	      // IE <=9 replaces <option> tags with their contents when inserted outside of
	      // the select element.

	      div.innerHTML = "<option></option>";
	      support.option = !!div.lastChild;
	    })(); // We have to close these tags to support XHTML (#13200)


	    var wrapMap = {
	      // XHTML parsers do not magically insert elements in the
	      // same way that tag soup parsers do. So we cannot shorten
	      // this by omitting <tbody> or other required elements.
	      thead: [1, "<table>", "</table>"],
	      col: [2, "<table><colgroup>", "</colgroup></table>"],
	      tr: [2, "<table><tbody>", "</tbody></table>"],
	      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	      _default: [0, "", ""]
	    };
	    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	    wrapMap.th = wrapMap.td; // Support: IE <=9 only

	    if (!support.option) {
	      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
	    }

	    function getAll(context, tag) {
	      // Support: IE <=9 - 11 only
	      // Use typeof to avoid zero-argument method invocation on host objects (#15151)
	      var ret;

	      if (typeof context.getElementsByTagName !== "undefined") {
	        ret = context.getElementsByTagName(tag || "*");
	      } else if (typeof context.querySelectorAll !== "undefined") {
	        ret = context.querySelectorAll(tag || "*");
	      } else {
	        ret = [];
	      }

	      if (tag === undefined || tag && nodeName(context, tag)) {
	        return jQuery.merge([context], ret);
	      }

	      return ret;
	    } // Mark scripts as having already been evaluated


	    function setGlobalEval(elems, refElements) {
	      var i = 0,
	          l = elems.length;

	      for (; i < l; i++) {
	        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
	      }
	    }

	    var rhtml = /<|&#?\w+;/;

	    function buildFragment(elems, context, scripts, selection, ignored) {
	      var elem,
	          tmp,
	          tag,
	          wrap,
	          attached,
	          j,
	          fragment = context.createDocumentFragment(),
	          nodes = [],
	          i = 0,
	          l = elems.length;

	      for (; i < l; i++) {
	        elem = elems[i];

	        if (elem || elem === 0) {
	          // Add nodes directly
	          if (toType(elem) === "object") {
	            // Support: Android <=4.0 only, PhantomJS 1 only
	            // push.apply(_, arraylike) throws on ancient WebKit
	            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
	          } else if (!rhtml.test(elem)) {
	            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
	          } else {
	            tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

	            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
	            wrap = wrapMap[tag] || wrapMap._default;
	            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

	            j = wrap[0];

	            while (j--) {
	              tmp = tmp.lastChild;
	            } // Support: Android <=4.0 only, PhantomJS 1 only
	            // push.apply(_, arraylike) throws on ancient WebKit


	            jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

	            tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

	            tmp.textContent = "";
	          }
	        }
	      } // Remove wrapper from fragment


	      fragment.textContent = "";
	      i = 0;

	      while (elem = nodes[i++]) {
	        // Skip elements already in the context collection (trac-4087)
	        if (selection && jQuery.inArray(elem, selection) > -1) {
	          if (ignored) {
	            ignored.push(elem);
	          }

	          continue;
	        }

	        attached = isAttached(elem); // Append to fragment

	        tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

	        if (attached) {
	          setGlobalEval(tmp);
	        } // Capture executables


	        if (scripts) {
	          j = 0;

	          while (elem = tmp[j++]) {
	            if (rscriptType.test(elem.type || "")) {
	              scripts.push(elem);
	            }
	          }
	        }
	      }

	      return fragment;
	    }

	    var rkeyEvent = /^key/,
	        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	    function returnTrue() {
	      return true;
	    }

	    function returnFalse() {
	      return false;
	    } // Support: IE <=9 - 11+
	    // focus() and blur() are asynchronous, except when they are no-op.
	    // So expect focus to be synchronous when the element is already active,
	    // and blur to be synchronous when the element is not already active.
	    // (focus and blur are always synchronous in other supported browsers,
	    // this just defines when we can count on it).


	    function expectSync(elem, type) {
	      return elem === safeActiveElement() === (type === "focus");
	    } // Support: IE <=9 only
	    // Accessing document.activeElement can throw unexpectedly
	    // https://bugs.jquery.com/ticket/13393


	    function safeActiveElement() {
	      try {
	        return document.activeElement;
	      } catch (err) {}
	    }

	    function on(elem, types, selector, data, fn, one) {
	      var origFn, type; // Types can be a map of types/handlers

	      if (typeof types === "object") {
	        // ( types-Object, selector, data )
	        if (typeof selector !== "string") {
	          // ( types-Object, data )
	          data = data || selector;
	          selector = undefined;
	        }

	        for (type in types) {
	          on(elem, type, selector, data, types[type], one);
	        }

	        return elem;
	      }

	      if (data == null && fn == null) {
	        // ( types, fn )
	        fn = selector;
	        data = selector = undefined;
	      } else if (fn == null) {
	        if (typeof selector === "string") {
	          // ( types, selector, fn )
	          fn = data;
	          data = undefined;
	        } else {
	          // ( types, data, fn )
	          fn = data;
	          data = selector;
	          selector = undefined;
	        }
	      }

	      if (fn === false) {
	        fn = returnFalse;
	      } else if (!fn) {
	        return elem;
	      }

	      if (one === 1) {
	        origFn = fn;

	        fn = function (event) {
	          // Can use an empty set, since event contains the info
	          jQuery().off(event);
	          return origFn.apply(this, arguments);
	        }; // Use same guid so caller can remove using origFn


	        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
	      }

	      return elem.each(function () {
	        jQuery.event.add(this, types, fn, data, selector);
	      });
	    }
	    /*
	     * Helper functions for managing events -- not part of the public interface.
	     * Props to Dean Edwards' addEvent library for many of the ideas.
	     */


	    jQuery.event = {
	      global: {},
	      add: function (elem, types, handler, data, selector) {
	        var handleObjIn,
	            eventHandle,
	            tmp,
	            events,
	            t,
	            handleObj,
	            special,
	            handlers,
	            type,
	            namespaces,
	            origType,
	            elemData = dataPriv.get(elem); // Only attach events to objects that accept data

	        if (!acceptData(elem)) {
	          return;
	        } // Caller can pass in an object of custom data in lieu of the handler


	        if (handler.handler) {
	          handleObjIn = handler;
	          handler = handleObjIn.handler;
	          selector = handleObjIn.selector;
	        } // Ensure that invalid selectors throw exceptions at attach time
	        // Evaluate against documentElement in case elem is a non-element node (e.g., document)


	        if (selector) {
	          jQuery.find.matchesSelector(documentElement, selector);
	        } // Make sure that the handler has a unique ID, used to find/remove it later


	        if (!handler.guid) {
	          handler.guid = jQuery.guid++;
	        } // Init the element's event structure and main handler, if this is the first


	        if (!(events = elemData.events)) {
	          events = elemData.events = Object.create(null);
	        }

	        if (!(eventHandle = elemData.handle)) {
	          eventHandle = elemData.handle = function (e) {
	            // Discard the second event of a jQuery.event.trigger() and
	            // when an event is called after a page has unloaded
	            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
	          };
	        } // Handle multiple events separated by a space


	        types = (types || "").match(rnothtmlwhite) || [""];
	        t = types.length;

	        while (t--) {
	          tmp = rtypenamespace.exec(types[t]) || [];
	          type = origType = tmp[1];
	          namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

	          if (!type) {
	            continue;
	          } // If event changes its type, use the special event handlers for the changed type


	          special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

	          type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

	          special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

	          handleObj = jQuery.extend({
	            type: type,
	            origType: origType,
	            data: data,
	            handler: handler,
	            guid: handler.guid,
	            selector: selector,
	            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
	            namespace: namespaces.join(".")
	          }, handleObjIn); // Init the event handler queue if we're the first

	          if (!(handlers = events[type])) {
	            handlers = events[type] = [];
	            handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

	            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	              if (elem.addEventListener) {
	                elem.addEventListener(type, eventHandle);
	              }
	            }
	          }

	          if (special.add) {
	            special.add.call(elem, handleObj);

	            if (!handleObj.handler.guid) {
	              handleObj.handler.guid = handler.guid;
	            }
	          } // Add to the element's handler list, delegates in front


	          if (selector) {
	            handlers.splice(handlers.delegateCount++, 0, handleObj);
	          } else {
	            handlers.push(handleObj);
	          } // Keep track of which events have ever been used, for event optimization


	          jQuery.event.global[type] = true;
	        }
	      },
	      // Detach an event or set of events from an element
	      remove: function (elem, types, handler, selector, mappedTypes) {
	        var j,
	            origCount,
	            tmp,
	            events,
	            t,
	            handleObj,
	            special,
	            handlers,
	            type,
	            namespaces,
	            origType,
	            elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

	        if (!elemData || !(events = elemData.events)) {
	          return;
	        } // Once for each type.namespace in types; type may be omitted


	        types = (types || "").match(rnothtmlwhite) || [""];
	        t = types.length;

	        while (t--) {
	          tmp = rtypenamespace.exec(types[t]) || [];
	          type = origType = tmp[1];
	          namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

	          if (!type) {
	            for (type in events) {
	              jQuery.event.remove(elem, type + types[t], handler, selector, true);
	            }

	            continue;
	          }

	          special = jQuery.event.special[type] || {};
	          type = (selector ? special.delegateType : special.bindType) || type;
	          handlers = events[type] || [];
	          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

	          origCount = j = handlers.length;

	          while (j--) {
	            handleObj = handlers[j];

	            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
	              handlers.splice(j, 1);

	              if (handleObj.selector) {
	                handlers.delegateCount--;
	              }

	              if (special.remove) {
	                special.remove.call(elem, handleObj);
	              }
	            }
	          } // Remove generic event handler if we removed something and no more handlers exist
	          // (avoids potential for endless recursion during removal of special event handlers)


	          if (origCount && !handlers.length) {
	            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	              jQuery.removeEvent(elem, type, elemData.handle);
	            }

	            delete events[type];
	          }
	        } // Remove data and the expando if it's no longer used


	        if (jQuery.isEmptyObject(events)) {
	          dataPriv.remove(elem, "handle events");
	        }
	      },
	      dispatch: function (nativeEvent) {
	        var i,
	            j,
	            ret,
	            matched,
	            handleObj,
	            handlerQueue,
	            args = new Array(arguments.length),
	            // Make a writable jQuery.Event from the native event object
	        event = jQuery.event.fix(nativeEvent),
	            handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
	            special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

	        args[0] = event;

	        for (i = 1; i < arguments.length; i++) {
	          args[i] = arguments[i];
	        }

	        event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

	        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
	          return;
	        } // Determine handlers


	        handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

	        i = 0;

	        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
	          event.currentTarget = matched.elem;
	          j = 0;

	          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
	            // If the event is namespaced, then each handler is only invoked if it is
	            // specially universal or its namespaces are a superset of the event's.
	            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
	              event.handleObj = handleObj;
	              event.data = handleObj.data;
	              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

	              if (ret !== undefined) {
	                if ((event.result = ret) === false) {
	                  event.preventDefault();
	                  event.stopPropagation();
	                }
	              }
	            }
	          }
	        } // Call the postDispatch hook for the mapped type


	        if (special.postDispatch) {
	          special.postDispatch.call(this, event);
	        }

	        return event.result;
	      },
	      handlers: function (event, handlers) {
	        var i,
	            handleObj,
	            sel,
	            matchedHandlers,
	            matchedSelectors,
	            handlerQueue = [],
	            delegateCount = handlers.delegateCount,
	            cur = event.target; // Find delegate handlers

	        if (delegateCount && // Support: IE <=9
	        // Black-hole SVG <use> instance trees (trac-13180)
	        cur.nodeType && // Support: Firefox <=42
	        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
	        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
	        // Support: IE 11 only
	        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
	        !(event.type === "click" && event.button >= 1)) {
	          for (; cur !== this; cur = cur.parentNode || this) {
	            // Don't check non-elements (#13208)
	            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
	              matchedHandlers = [];
	              matchedSelectors = {};

	              for (i = 0; i < delegateCount; i++) {
	                handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

	                sel = handleObj.selector + " ";

	                if (matchedSelectors[sel] === undefined) {
	                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
	                }

	                if (matchedSelectors[sel]) {
	                  matchedHandlers.push(handleObj);
	                }
	              }

	              if (matchedHandlers.length) {
	                handlerQueue.push({
	                  elem: cur,
	                  handlers: matchedHandlers
	                });
	              }
	            }
	          }
	        } // Add the remaining (directly-bound) handlers


	        cur = this;

	        if (delegateCount < handlers.length) {
	          handlerQueue.push({
	            elem: cur,
	            handlers: handlers.slice(delegateCount)
	          });
	        }

	        return handlerQueue;
	      },
	      addProp: function (name, hook) {
	        Object.defineProperty(jQuery.Event.prototype, name, {
	          enumerable: true,
	          configurable: true,
	          get: isFunction(hook) ? function () {
	            if (this.originalEvent) {
	              return hook(this.originalEvent);
	            }
	          } : function () {
	            if (this.originalEvent) {
	              return this.originalEvent[name];
	            }
	          },
	          set: function (value) {
	            Object.defineProperty(this, name, {
	              enumerable: true,
	              configurable: true,
	              writable: true,
	              value: value
	            });
	          }
	        });
	      },
	      fix: function (originalEvent) {
	        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
	      },
	      special: {
	        load: {
	          // Prevent triggered image.load events from bubbling to window.load
	          noBubble: true
	        },
	        click: {
	          // Utilize native event to ensure correct state for checkable inputs
	          setup: function (data) {
	            // For mutual compressibility with _default, replace `this` access with a local var.
	            // `|| data` is dead code meant only to preserve the variable through minification.
	            var el = this || data; // Claim the first handler

	            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
	              // dataPriv.set( el, "click", ... )
	              leverageNative(el, "click", returnTrue);
	            } // Return false to allow normal processing in the caller


	            return false;
	          },
	          trigger: function (data) {
	            // For mutual compressibility with _default, replace `this` access with a local var.
	            // `|| data` is dead code meant only to preserve the variable through minification.
	            var el = this || data; // Force setup before triggering a click

	            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
	              leverageNative(el, "click");
	            } // Return non-false to allow normal event-path propagation


	            return true;
	          },
	          // For cross-browser consistency, suppress native .click() on links
	          // Also prevent it if we're currently inside a leveraged native-event stack
	          _default: function (event) {
	            var target = event.target;
	            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
	          }
	        },
	        beforeunload: {
	          postDispatch: function (event) {
	            // Support: Firefox 20+
	            // Firefox doesn't alert if the returnValue field is not set.
	            if (event.result !== undefined && event.originalEvent) {
	              event.originalEvent.returnValue = event.result;
	            }
	          }
	        }
	      }
	    }; // Ensure the presence of an event listener that handles manually-triggered
	    // synthetic events by interrupting progress until reinvoked in response to
	    // *native* events that it fires directly, ensuring that state changes have
	    // already occurred before other listeners are invoked.

	    function leverageNative(el, type, expectSync) {
	      // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	      if (!expectSync) {
	        if (dataPriv.get(el, type) === undefined) {
	          jQuery.event.add(el, type, returnTrue);
	        }

	        return;
	      } // Register the controller as a special universal handler for all event namespaces


	      dataPriv.set(el, type, false);
	      jQuery.event.add(el, type, {
	        namespace: false,
	        handler: function (event) {
	          var notAsync,
	              result,
	              saved = dataPriv.get(this, type);

	          if (event.isTrigger & 1 && this[type]) {
	            // Interrupt processing of the outer synthetic .trigger()ed event
	            // Saved data should be false in such cases, but might be a leftover capture object
	            // from an async native handler (gh-4350)
	            if (!saved.length) {
	              // Store arguments for use when handling the inner native event
	              // There will always be at least one argument (an event object), so this array
	              // will not be confused with a leftover capture object.
	              saved = slice.call(arguments);
	              dataPriv.set(this, type, saved); // Trigger the native event and capture its result
	              // Support: IE <=9 - 11+
	              // focus() and blur() are asynchronous

	              notAsync = expectSync(this, type);
	              this[type]();
	              result = dataPriv.get(this, type);

	              if (saved !== result || notAsync) {
	                dataPriv.set(this, type, false);
	              } else {
	                result = {};
	              }

	              if (saved !== result) {
	                // Cancel the outer synthetic event
	                event.stopImmediatePropagation();
	                event.preventDefault();
	                return result.value;
	              } // If this is an inner synthetic event for an event with a bubbling surrogate
	              // (focus or blur), assume that the surrogate already propagated from triggering the
	              // native event and prevent that from happening again here.
	              // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
	              // bubbling surrogate propagates *after* the non-bubbling base), but that seems
	              // less bad than duplication.

	            } else if ((jQuery.event.special[type] || {}).delegateType) {
	              event.stopPropagation();
	            } // If this is a native event triggered above, everything is now in order
	            // Fire an inner synthetic event with the original arguments

	          } else if (saved.length) {
	            // ...and capture the result
	            dataPriv.set(this, type, {
	              value: jQuery.event.trigger( // Support: IE <=9 - 11+
	              // Extend with the prototype to reset the above stopImmediatePropagation()
	              jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
	            }); // Abort handling of the native event

	            event.stopImmediatePropagation();
	          }
	        }
	      });
	    }

	    jQuery.removeEvent = function (elem, type, handle) {
	      // This "if" is needed for plain objects
	      if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle);
	      }
	    };

	    jQuery.Event = function (src, props) {
	      // Allow instantiation without the 'new' keyword
	      if (!(this instanceof jQuery.Event)) {
	        return new jQuery.Event(src, props);
	      } // Event object


	      if (src && src.type) {
	        this.originalEvent = src;
	        this.type = src.type; // Events bubbling up the document may have been marked as prevented
	        // by a handler lower down the tree; reflect the correct value.

	        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
	        src.returnValue === false ? returnTrue : returnFalse; // Create target properties
	        // Support: Safari <=6 - 7 only
	        // Target should not be a text node (#504, #13143)

	        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
	        this.currentTarget = src.currentTarget;
	        this.relatedTarget = src.relatedTarget; // Event type
	      } else {
	        this.type = src;
	      } // Put explicitly provided properties onto the event object


	      if (props) {
	        jQuery.extend(this, props);
	      } // Create a timestamp if incoming event doesn't have one


	      this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

	      this[jQuery.expando] = true;
	    }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


	    jQuery.Event.prototype = {
	      constructor: jQuery.Event,
	      isDefaultPrevented: returnFalse,
	      isPropagationStopped: returnFalse,
	      isImmediatePropagationStopped: returnFalse,
	      isSimulated: false,
	      preventDefault: function () {
	        var e = this.originalEvent;
	        this.isDefaultPrevented = returnTrue;

	        if (e && !this.isSimulated) {
	          e.preventDefault();
	        }
	      },
	      stopPropagation: function () {
	        var e = this.originalEvent;
	        this.isPropagationStopped = returnTrue;

	        if (e && !this.isSimulated) {
	          e.stopPropagation();
	        }
	      },
	      stopImmediatePropagation: function () {
	        var e = this.originalEvent;
	        this.isImmediatePropagationStopped = returnTrue;

	        if (e && !this.isSimulated) {
	          e.stopImmediatePropagation();
	        }

	        this.stopPropagation();
	      }
	    }; // Includes all common event props including KeyEvent and MouseEvent specific props

	    jQuery.each({
	      altKey: true,
	      bubbles: true,
	      cancelable: true,
	      changedTouches: true,
	      ctrlKey: true,
	      detail: true,
	      eventPhase: true,
	      metaKey: true,
	      pageX: true,
	      pageY: true,
	      shiftKey: true,
	      view: true,
	      char: true,
	      code: true,
	      charCode: true,
	      key: true,
	      keyCode: true,
	      button: true,
	      buttons: true,
	      clientX: true,
	      clientY: true,
	      offsetX: true,
	      offsetY: true,
	      pointerId: true,
	      pointerType: true,
	      screenX: true,
	      screenY: true,
	      targetTouches: true,
	      toElement: true,
	      touches: true,
	      which: function (event) {
	        var button = event.button; // Add which for key events

	        if (event.which == null && rkeyEvent.test(event.type)) {
	          return event.charCode != null ? event.charCode : event.keyCode;
	        } // Add which for click: 1 === left; 2 === middle; 3 === right


	        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
	          if (button & 1) {
	            return 1;
	          }

	          if (button & 2) {
	            return 3;
	          }

	          if (button & 4) {
	            return 2;
	          }

	          return 0;
	        }

	        return event.which;
	      }
	    }, jQuery.event.addProp);
	    jQuery.each({
	      focus: "focusin",
	      blur: "focusout"
	    }, function (type, delegateType) {
	      jQuery.event.special[type] = {
	        // Utilize native event if possible so blur/focus sequence is correct
	        setup: function () {
	          // Claim the first handler
	          // dataPriv.set( this, "focus", ... )
	          // dataPriv.set( this, "blur", ... )
	          leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

	          return false;
	        },
	        trigger: function () {
	          // Force setup before trigger
	          leverageNative(this, type); // Return non-false to allow normal event-path propagation

	          return true;
	        },
	        delegateType: delegateType
	      };
	    }); // Create mouseenter/leave events using mouseover/out and event-time checks
	    // so that event delegation works in jQuery.
	    // Do the same for pointerenter/pointerleave and pointerover/pointerout
	    //
	    // Support: Safari 7 only
	    // Safari sends mouseenter too often; see:
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	    // for the description of the bug (it existed in older Chrome versions as well).

	    jQuery.each({
	      mouseenter: "mouseover",
	      mouseleave: "mouseout",
	      pointerenter: "pointerover",
	      pointerleave: "pointerout"
	    }, function (orig, fix) {
	      jQuery.event.special[orig] = {
	        delegateType: fix,
	        bindType: fix,
	        handle: function (event) {
	          var ret,
	              target = this,
	              related = event.relatedTarget,
	              handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
	          // NB: No relatedTarget if the mouse left/entered the browser window

	          if (!related || related !== target && !jQuery.contains(target, related)) {
	            event.type = handleObj.origType;
	            ret = handleObj.handler.apply(this, arguments);
	            event.type = fix;
	          }

	          return ret;
	        }
	      };
	    });
	    jQuery.fn.extend({
	      on: function (types, selector, data, fn) {
	        return on(this, types, selector, data, fn);
	      },
	      one: function (types, selector, data, fn) {
	        return on(this, types, selector, data, fn, 1);
	      },
	      off: function (types, selector, fn) {
	        var handleObj, type;

	        if (types && types.preventDefault && types.handleObj) {
	          // ( event )  dispatched jQuery.Event
	          handleObj = types.handleObj;
	          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
	          return this;
	        }

	        if (typeof types === "object") {
	          // ( types-object [, selector] )
	          for (type in types) {
	            this.off(type, selector, types[type]);
	          }

	          return this;
	        }

	        if (selector === false || typeof selector === "function") {
	          // ( types [, fn] )
	          fn = selector;
	          selector = undefined;
	        }

	        if (fn === false) {
	          fn = returnFalse;
	        }

	        return this.each(function () {
	          jQuery.event.remove(this, types, fn, selector);
	        });
	      }
	    });
	    var // Support: IE <=10 - 11, Edge 12 - 13 only
	    // In IE/Edge using regex groups here causes severe slowdowns.
	    // See https://connect.microsoft.com/IE/feedback/details/1736512/
	    rnoInnerhtml = /<script|<style|<link/i,
	        // checked="checked" or checked
	    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

	    function manipulationTarget(elem, content) {
	      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
	        return jQuery(elem).children("tbody")[0] || elem;
	      }

	      return elem;
	    } // Replace/restore the type attribute of script elements for safe DOM manipulation


	    function disableScript(elem) {
	      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	      return elem;
	    }

	    function restoreScript(elem) {
	      if ((elem.type || "").slice(0, 5) === "true/") {
	        elem.type = elem.type.slice(5);
	      } else {
	        elem.removeAttribute("type");
	      }

	      return elem;
	    }

	    function cloneCopyEvent(src, dest) {
	      var i, l, type, pdataOld, udataOld, udataCur, events;

	      if (dest.nodeType !== 1) {
	        return;
	      } // 1. Copy private data: events, handlers, etc.


	      if (dataPriv.hasData(src)) {
	        pdataOld = dataPriv.get(src);
	        events = pdataOld.events;

	        if (events) {
	          dataPriv.remove(dest, "handle events");

	          for (type in events) {
	            for (i = 0, l = events[type].length; i < l; i++) {
	              jQuery.event.add(dest, type, events[type][i]);
	            }
	          }
	        }
	      } // 2. Copy user data


	      if (dataUser.hasData(src)) {
	        udataOld = dataUser.access(src);
	        udataCur = jQuery.extend({}, udataOld);
	        dataUser.set(dest, udataCur);
	      }
	    } // Fix IE bugs, see support tests


	    function fixInput(src, dest) {
	      var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

	      if (nodeName === "input" && rcheckableType.test(src.type)) {
	        dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
	      } else if (nodeName === "input" || nodeName === "textarea") {
	        dest.defaultValue = src.defaultValue;
	      }
	    }

	    function domManip(collection, args, callback, ignored) {
	      // Flatten any nested arrays
	      args = flat(args);
	      var fragment,
	          first,
	          scripts,
	          hasScripts,
	          node,
	          doc,
	          i = 0,
	          l = collection.length,
	          iNoClone = l - 1,
	          value = args[0],
	          valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

	      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
	        return collection.each(function (index) {
	          var self = collection.eq(index);

	          if (valueIsFunction) {
	            args[0] = value.call(this, index, self.html());
	          }

	          domManip(self, args, callback, ignored);
	        });
	      }

	      if (l) {
	        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
	        first = fragment.firstChild;

	        if (fragment.childNodes.length === 1) {
	          fragment = first;
	        } // Require either new content or an interest in ignored elements to invoke the callback


	        if (first || ignored) {
	          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
	          hasScripts = scripts.length; // Use the original fragment for the last item
	          // instead of the first because it can end up
	          // being emptied incorrectly in certain situations (#8070).

	          for (; i < l; i++) {
	            node = fragment;

	            if (i !== iNoClone) {
	              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

	              if (hasScripts) {
	                // Support: Android <=4.0 only, PhantomJS 1 only
	                // push.apply(_, arraylike) throws on ancient WebKit
	                jQuery.merge(scripts, getAll(node, "script"));
	              }
	            }

	            callback.call(collection[i], node, i);
	          }

	          if (hasScripts) {
	            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

	            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

	            for (i = 0; i < hasScripts; i++) {
	              node = scripts[i];

	              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
	                if (node.src && (node.type || "").toLowerCase() !== "module") {
	                  // Optional AJAX dependency, but won't run scripts if not present
	                  if (jQuery._evalUrl && !node.noModule) {
	                    jQuery._evalUrl(node.src, {
	                      nonce: node.nonce || node.getAttribute("nonce")
	                    }, doc);
	                  }
	                } else {
	                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
	                }
	              }
	            }
	          }
	        }
	      }

	      return collection;
	    }

	    function remove(elem, selector, keepData) {
	      var node,
	          nodes = selector ? jQuery.filter(selector, elem) : elem,
	          i = 0;

	      for (; (node = nodes[i]) != null; i++) {
	        if (!keepData && node.nodeType === 1) {
	          jQuery.cleanData(getAll(node));
	        }

	        if (node.parentNode) {
	          if (keepData && isAttached(node)) {
	            setGlobalEval(getAll(node, "script"));
	          }

	          node.parentNode.removeChild(node);
	        }
	      }

	      return elem;
	    }

	    jQuery.extend({
	      htmlPrefilter: function (html) {
	        return html;
	      },
	      clone: function (elem, dataAndEvents, deepDataAndEvents) {
	        var i,
	            l,
	            srcElements,
	            destElements,
	            clone = elem.cloneNode(true),
	            inPage = isAttached(elem); // Fix IE cloning issues

	        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
	          // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
	          destElements = getAll(clone);
	          srcElements = getAll(elem);

	          for (i = 0, l = srcElements.length; i < l; i++) {
	            fixInput(srcElements[i], destElements[i]);
	          }
	        } // Copy the events from the original to the clone


	        if (dataAndEvents) {
	          if (deepDataAndEvents) {
	            srcElements = srcElements || getAll(elem);
	            destElements = destElements || getAll(clone);

	            for (i = 0, l = srcElements.length; i < l; i++) {
	              cloneCopyEvent(srcElements[i], destElements[i]);
	            }
	          } else {
	            cloneCopyEvent(elem, clone);
	          }
	        } // Preserve script evaluation history


	        destElements = getAll(clone, "script");

	        if (destElements.length > 0) {
	          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
	        } // Return the cloned set


	        return clone;
	      },
	      cleanData: function (elems) {
	        var data,
	            elem,
	            type,
	            special = jQuery.event.special,
	            i = 0;

	        for (; (elem = elems[i]) !== undefined; i++) {
	          if (acceptData(elem)) {
	            if (data = elem[dataPriv.expando]) {
	              if (data.events) {
	                for (type in data.events) {
	                  if (special[type]) {
	                    jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
	                  } else {
	                    jQuery.removeEvent(elem, type, data.handle);
	                  }
	                }
	              } // Support: Chrome <=35 - 45+
	              // Assign undefined instead of using delete, see Data#remove


	              elem[dataPriv.expando] = undefined;
	            }

	            if (elem[dataUser.expando]) {
	              // Support: Chrome <=35 - 45+
	              // Assign undefined instead of using delete, see Data#remove
	              elem[dataUser.expando] = undefined;
	            }
	          }
	        }
	      }
	    });
	    jQuery.fn.extend({
	      detach: function (selector) {
	        return remove(this, selector, true);
	      },
	      remove: function (selector) {
	        return remove(this, selector);
	      },
	      text: function (value) {
	        return access(this, function (value) {
	          return value === undefined ? jQuery.text(this) : this.empty().each(function () {
	            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	              this.textContent = value;
	            }
	          });
	        }, null, value, arguments.length);
	      },
	      append: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	            var target = manipulationTarget(this, elem);
	            target.appendChild(elem);
	          }
	        });
	      },
	      prepend: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	            var target = manipulationTarget(this, elem);
	            target.insertBefore(elem, target.firstChild);
	          }
	        });
	      },
	      before: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.parentNode) {
	            this.parentNode.insertBefore(elem, this);
	          }
	        });
	      },
	      after: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.parentNode) {
	            this.parentNode.insertBefore(elem, this.nextSibling);
	          }
	        });
	      },
	      empty: function () {
	        var elem,
	            i = 0;

	        for (; (elem = this[i]) != null; i++) {
	          if (elem.nodeType === 1) {
	            // Prevent memory leaks
	            jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

	            elem.textContent = "";
	          }
	        }

	        return this;
	      },
	      clone: function (dataAndEvents, deepDataAndEvents) {
	        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
	        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	        return this.map(function () {
	          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
	        });
	      },
	      html: function (value) {
	        return access(this, function (value) {
	          var elem = this[0] || {},
	              i = 0,
	              l = this.length;

	          if (value === undefined && elem.nodeType === 1) {
	            return elem.innerHTML;
	          } // See if we can take a shortcut and just use innerHTML


	          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
	            value = jQuery.htmlPrefilter(value);

	            try {
	              for (; i < l; i++) {
	                elem = this[i] || {}; // Remove element nodes and prevent memory leaks

	                if (elem.nodeType === 1) {
	                  jQuery.cleanData(getAll(elem, false));
	                  elem.innerHTML = value;
	                }
	              }

	              elem = 0; // If using innerHTML throws an exception, use the fallback method
	            } catch (e) {}
	          }

	          if (elem) {
	            this.empty().append(value);
	          }
	        }, null, value, arguments.length);
	      },
	      replaceWith: function () {
	        var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

	        return domManip(this, arguments, function (elem) {
	          var parent = this.parentNode;

	          if (jQuery.inArray(this, ignored) < 0) {
	            jQuery.cleanData(getAll(this));

	            if (parent) {
	              parent.replaceChild(elem, this);
	            }
	          } // Force callback invocation

	        }, ignored);
	      }
	    });
	    jQuery.each({
	      appendTo: "append",
	      prependTo: "prepend",
	      insertBefore: "before",
	      insertAfter: "after",
	      replaceAll: "replaceWith"
	    }, function (name, original) {
	      jQuery.fn[name] = function (selector) {
	        var elems,
	            ret = [],
	            insert = jQuery(selector),
	            last = insert.length - 1,
	            i = 0;

	        for (; i <= last; i++) {
	          elems = i === last ? this : this.clone(true);
	          jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
	          // .get() because push.apply(_, arraylike) throws on ancient WebKit

	          push.apply(ret, elems.get());
	        }

	        return this.pushStack(ret);
	      };
	    });
	    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	    var getStyles = function (elem) {
	      // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
	      // IE throws on elements created in popups
	      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
	      var view = elem.ownerDocument.defaultView;

	      if (!view || !view.opener) {
	        view = window;
	      }

	      return view.getComputedStyle(elem);
	    };

	    var swap = function (elem, options, callback) {
	      var ret,
	          name,
	          old = {}; // Remember the old values, and insert the new ones

	      for (name in options) {
	        old[name] = elem.style[name];
	        elem.style[name] = options[name];
	      }

	      ret = callback.call(elem); // Revert the old values

	      for (name in options) {
	        elem.style[name] = old[name];
	      }

	      return ret;
	    };

	    var rboxStyle = new RegExp(cssExpand.join("|"), "i");

	    (function () {
	      // Executing both pixelPosition & boxSizingReliable tests require only one layout
	      // so they're executed at the same time to save the second computation.
	      function computeStyleTests() {
	        // This is a singleton, we need to execute it only once
	        if (!div) {
	          return;
	        }

	        container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
	        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
	        documentElement.appendChild(container).appendChild(div);
	        var divStyle = window.getComputedStyle(div);
	        pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

	        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
	        // Some styles come back with percentage values, even though they shouldn't

	        div.style.right = "60%";
	        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
	        // Detect misreporting of content dimensions for box-sizing:border-box elements

	        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
	        // Detect overflow:scroll screwiness (gh-3699)
	        // Support: Chrome <=64
	        // Don't get tricked when zoom affects offsetWidth (gh-4029)

	        div.style.position = "absolute";
	        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
	        documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
	        // it will also be a sign that checks already performed

	        div = null;
	      }

	      function roundPixelMeasures(measure) {
	        return Math.round(parseFloat(measure));
	      }

	      var pixelPositionVal,
	          boxSizingReliableVal,
	          scrollboxSizeVal,
	          pixelBoxStylesVal,
	          reliableTrDimensionsVal,
	          reliableMarginLeftVal,
	          container = document.createElement("div"),
	          div = document.createElement("div"); // Finish early in limited (non-browser) environments

	      if (!div.style) {
	        return;
	      } // Support: IE <=9 - 11 only
	      // Style of cloned element affects source element cloned (#8908)


	      div.style.backgroundClip = "content-box";
	      div.cloneNode(true).style.backgroundClip = "";
	      support.clearCloneStyle = div.style.backgroundClip === "content-box";
	      jQuery.extend(support, {
	        boxSizingReliable: function () {
	          computeStyleTests();
	          return boxSizingReliableVal;
	        },
	        pixelBoxStyles: function () {
	          computeStyleTests();
	          return pixelBoxStylesVal;
	        },
	        pixelPosition: function () {
	          computeStyleTests();
	          return pixelPositionVal;
	        },
	        reliableMarginLeft: function () {
	          computeStyleTests();
	          return reliableMarginLeftVal;
	        },
	        scrollboxSize: function () {
	          computeStyleTests();
	          return scrollboxSizeVal;
	        },
	        // Support: IE 9 - 11+, Edge 15 - 18+
	        // IE/Edge misreport `getComputedStyle` of table rows with width/height
	        // set in CSS while `offset*` properties report correct values.
	        // Behavior in IE 9 is more subtle than in newer versions & it passes
	        // some versions of this test; make sure not to make it pass there!
	        reliableTrDimensions: function () {
	          var table, tr, trChild, trStyle;

	          if (reliableTrDimensionsVal == null) {
	            table = document.createElement("table");
	            tr = document.createElement("tr");
	            trChild = document.createElement("div");
	            table.style.cssText = "position:absolute;left:-11111px";
	            tr.style.height = "1px";
	            trChild.style.height = "9px";
	            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
	            trStyle = window.getComputedStyle(tr);
	            reliableTrDimensionsVal = parseInt(trStyle.height) > 3;
	            documentElement.removeChild(table);
	          }

	          return reliableTrDimensionsVal;
	        }
	      });
	    })();

	    function curCSS(elem, name, computed) {
	      var width,
	          minWidth,
	          maxWidth,
	          ret,
	          // Support: Firefox 51+
	      // Retrieving style before computed somehow
	      // fixes an issue with getting wrong values
	      // on detached elements
	      style = elem.style;
	      computed = computed || getStyles(elem); // getPropertyValue is needed for:
	      //   .css('filter') (IE 9 only, #12537)
	      //   .css('--customProperty) (#3144)

	      if (computed) {
	        ret = computed.getPropertyValue(name) || computed[name];

	        if (ret === "" && !isAttached(elem)) {
	          ret = jQuery.style(elem, name);
	        } // A tribute to the "awesome hack by Dean Edwards"
	        // Android Browser returns percentage for some values,
	        // but width seems to be reliably pixels.
	        // This is against the CSSOM draft spec:
	        // https://drafts.csswg.org/cssom/#resolved-values


	        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
	          // Remember the original values
	          width = style.width;
	          minWidth = style.minWidth;
	          maxWidth = style.maxWidth; // Put in the new values to get a computed value out

	          style.minWidth = style.maxWidth = style.width = ret;
	          ret = computed.width; // Revert the changed values

	          style.width = width;
	          style.minWidth = minWidth;
	          style.maxWidth = maxWidth;
	        }
	      }

	      return ret !== undefined ? // Support: IE <=9 - 11 only
	      // IE returns zIndex value as an integer.
	      ret + "" : ret;
	    }

	    function addGetHookIf(conditionFn, hookFn) {
	      // Define the hook, we'll check on the first run if it's really needed.
	      return {
	        get: function () {
	          if (conditionFn()) {
	            // Hook not needed (or it's not possible to use it due
	            // to missing dependency), remove it.
	            delete this.get;
	            return;
	          } // Hook needed; redefine it so that the support test is not executed again.


	          return (this.get = hookFn).apply(this, arguments);
	        }
	      };
	    }

	    var cssPrefixes = ["Webkit", "Moz", "ms"],
	        emptyStyle = document.createElement("div").style,
	        vendorProps = {}; // Return a vendor-prefixed property or undefined

	    function vendorPropName(name) {
	      // Check for vendor prefixed names
	      var capName = name[0].toUpperCase() + name.slice(1),
	          i = cssPrefixes.length;

	      while (i--) {
	        name = cssPrefixes[i] + capName;

	        if (name in emptyStyle) {
	          return name;
	        }
	      }
	    } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


	    function finalPropName(name) {
	      var final = jQuery.cssProps[name] || vendorProps[name];

	      if (final) {
	        return final;
	      }

	      if (name in emptyStyle) {
	        return name;
	      }

	      return vendorProps[name] = vendorPropName(name) || name;
	    }

	    var // Swappable if display is none or starts with table
	    // except "table", "table-cell", or "table-caption"
	    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	        rcustomProp = /^--/,
	        cssShow = {
	      position: "absolute",
	      visibility: "hidden",
	      display: "block"
	    },
	        cssNormalTransform = {
	      letterSpacing: "0",
	      fontWeight: "400"
	    };

	    function setPositiveNumber(_elem, value, subtract) {
	      // Any relative (+/-) values have already been
	      // normalized at this point
	      var matches = rcssNum.exec(value);
	      return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
	      Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	    }

	    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
	      var i = dimension === "width" ? 1 : 0,
	          extra = 0,
	          delta = 0; // Adjustment may not be necessary

	      if (box === (isBorderBox ? "border" : "content")) {
	        return 0;
	      }

	      for (; i < 4; i += 2) {
	        // Both box models exclude margin
	        if (box === "margin") {
	          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
	        } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


	        if (!isBorderBox) {
	          // Add padding
	          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

	          if (box !== "padding") {
	            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
	          } else {
	            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	          } // If we get here with a border-box (content + padding + border), we're seeking "content" or
	          // "padding" or "margin"

	        } else {
	          // For "content", subtract padding
	          if (box === "content") {
	            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
	          } // For "content" or "padding", subtract border


	          if (box !== "margin") {
	            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	          }
	        }
	      } // Account for positive content-box scroll gutter when requested by providing computedVal


	      if (!isBorderBox && computedVal >= 0) {
	        // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
	        // Assuming integer scroll gutter, subtract the rest and round down
	        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
	        // Use an explicit zero to avoid NaN (gh-3964)
	        )) || 0;
	      }

	      return delta;
	    }

	    function getWidthOrHeight(elem, dimension, extra) {
	      // Start with computed style
	      var styles = getStyles(elem),
	          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
	      // Fake content-box until we know it's needed to know the true value.
	      boxSizingNeeded = !support.boxSizingReliable() || extra,
	          isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
	          valueIsBorderBox = isBorderBox,
	          val = curCSS(elem, dimension, styles),
	          offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
	      // Return a confounding non-pixel value or feign ignorance, as appropriate.

	      if (rnumnonpx.test(val)) {
	        if (!extra) {
	          return val;
	        }

	        val = "auto";
	      } // Support: IE 9 - 11 only
	      // Use offsetWidth/offsetHeight for when box sizing is unreliable.
	      // In those cases, the computed value can be trusted to be border-box.


	      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
	      // IE/Edge misreport `getComputedStyle` of table rows with width/height
	      // set in CSS while `offset*` properties report correct values.
	      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
	      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
	      // This happens for inline elements with no explicit setting (gh-3571)
	      val === "auto" || // Support: Android <=4.1 - 4.3 only
	      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	      !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
	      elem.getClientRects().length) {
	        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
	        // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
	        // retrieved value as a content box dimension.

	        valueIsBorderBox = offsetProp in elem;

	        if (valueIsBorderBox) {
	          val = elem[offsetProp];
	        }
	      } // Normalize "" and auto


	      val = parseFloat(val) || 0; // Adjust for the element's box model

	      return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
	      val) + "px";
	    }

	    jQuery.extend({
	      // Add in style property hooks for overriding the default
	      // behavior of getting and setting a style property
	      cssHooks: {
	        opacity: {
	          get: function (elem, computed) {
	            if (computed) {
	              // We should always get a number back from opacity
	              var ret = curCSS(elem, "opacity");
	              return ret === "" ? "1" : ret;
	            }
	          }
	        }
	      },
	      // Don't automatically add "px" to these possibly-unitless properties
	      cssNumber: {
	        animationIterationCount: true,
	        columnCount: true,
	        fillOpacity: true,
	        flexGrow: true,
	        flexShrink: true,
	        fontWeight: true,
	        gridArea: true,
	        gridColumn: true,
	        gridColumnEnd: true,
	        gridColumnStart: true,
	        gridRow: true,
	        gridRowEnd: true,
	        gridRowStart: true,
	        lineHeight: true,
	        opacity: true,
	        order: true,
	        orphans: true,
	        widows: true,
	        zIndex: true,
	        zoom: true
	      },
	      // Add in properties whose names you wish to fix before
	      // setting or getting the value
	      cssProps: {},
	      // Get and set the style property on a DOM Node
	      style: function (elem, name, value, extra) {
	        // Don't set styles on text and comment nodes
	        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
	          return;
	        } // Make sure that we're working with the right name


	        var ret,
	            type,
	            hooks,
	            origName = camelCase(name),
	            isCustomProp = rcustomProp.test(name),
	            style = elem.style; // Make sure that we're working with the right name. We don't
	        // want to query the value if it is a CSS custom property
	        // since they are user-defined.

	        if (!isCustomProp) {
	          name = finalPropName(origName);
	        } // Gets hook for the prefixed version, then unprefixed version


	        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

	        if (value !== undefined) {
	          type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

	          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
	            value = adjustCSS(elem, name, ret); // Fixes bug #9237

	            type = "number";
	          } // Make sure that null and NaN values aren't set (#7116)


	          if (value == null || value !== value) {
	            return;
	          } // If a number was passed in, add the unit (except for certain CSS properties)
	          // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
	          // "px" to a few hardcoded values.


	          if (type === "number" && !isCustomProp) {
	            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
	          } // background-* props affect original clone's values


	          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
	            style[name] = "inherit";
	          } // If a hook was provided, use that value, otherwise just set the specified value


	          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
	            if (isCustomProp) {
	              style.setProperty(name, value);
	            } else {
	              style[name] = value;
	            }
	          }
	        } else {
	          // If a hook was provided get the non-computed value from there
	          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
	            return ret;
	          } // Otherwise just get the value from the style object


	          return style[name];
	        }
	      },
	      css: function (elem, name, extra, styles) {
	        var val,
	            num,
	            hooks,
	            origName = camelCase(name),
	            isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
	        // want to modify the value if it is a CSS custom property
	        // since they are user-defined.

	        if (!isCustomProp) {
	          name = finalPropName(origName);
	        } // Try prefixed name followed by the unprefixed name


	        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

	        if (hooks && "get" in hooks) {
	          val = hooks.get(elem, true, extra);
	        } // Otherwise, if a way to get the computed value exists, use that


	        if (val === undefined) {
	          val = curCSS(elem, name, styles);
	        } // Convert "normal" to computed value


	        if (val === "normal" && name in cssNormalTransform) {
	          val = cssNormalTransform[name];
	        } // Make numeric if forced or a qualifier was provided and val looks numeric


	        if (extra === "" || extra) {
	          num = parseFloat(val);
	          return extra === true || isFinite(num) ? num || 0 : val;
	        }

	        return val;
	      }
	    });
	    jQuery.each(["height", "width"], function (_i, dimension) {
	      jQuery.cssHooks[dimension] = {
	        get: function (elem, computed, extra) {
	          if (computed) {
	            // Certain elements can have dimension info if we invisibly show them
	            // but it must have a current display style that would benefit
	            return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
	            // Table columns in Safari have non-zero offsetWidth & zero
	            // getBoundingClientRect().width unless display is changed.
	            // Support: IE <=11 only
	            // Running getBoundingClientRect on a disconnected node
	            // in IE throws an error.
	            !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
	              return getWidthOrHeight(elem, dimension, extra);
	            }) : getWidthOrHeight(elem, dimension, extra);
	          }
	        },
	        set: function (elem, value, extra) {
	          var matches,
	              styles = getStyles(elem),
	              // Only read styles.position if the test has a chance to fail
	          // to avoid forcing a reflow.
	          scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
	              // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
	          boxSizingNeeded = scrollboxSizeBuggy || extra,
	              isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
	              subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
	          // faking a content-box to get border and padding (gh-3699)

	          if (isBorderBox && scrollboxSizeBuggy) {
	            subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
	          } // Convert to pixels if value adjustment is needed


	          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
	            elem.style[dimension] = value;
	            value = jQuery.css(elem, dimension);
	          }

	          return setPositiveNumber(elem, value, subtract);
	        }
	      };
	    });
	    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
	      if (computed) {
	        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
	          marginLeft: 0
	        }, function () {
	          return elem.getBoundingClientRect().left;
	        })) + "px";
	      }
	    }); // These hooks are used by animate to expand properties

	    jQuery.each({
	      margin: "",
	      padding: "",
	      border: "Width"
	    }, function (prefix, suffix) {
	      jQuery.cssHooks[prefix + suffix] = {
	        expand: function (value) {
	          var i = 0,
	              expanded = {},
	              // Assumes a single number if not a string
	          parts = typeof value === "string" ? value.split(" ") : [value];

	          for (; i < 4; i++) {
	            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
	          }

	          return expanded;
	        }
	      };

	      if (prefix !== "margin") {
	        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
	      }
	    });
	    jQuery.fn.extend({
	      css: function (name, value) {
	        return access(this, function (elem, name, value) {
	          var styles,
	              len,
	              map = {},
	              i = 0;

	          if (Array.isArray(name)) {
	            styles = getStyles(elem);
	            len = name.length;

	            for (; i < len; i++) {
	              map[name[i]] = jQuery.css(elem, name[i], false, styles);
	            }

	            return map;
	          }

	          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
	        }, name, value, arguments.length > 1);
	      }
	    });

	    function Tween(elem, options, prop, end, easing) {
	      return new Tween.prototype.init(elem, options, prop, end, easing);
	    }

	    jQuery.Tween = Tween;
	    Tween.prototype = {
	      constructor: Tween,
	      init: function (elem, options, prop, end, easing, unit) {
	        this.elem = elem;
	        this.prop = prop;
	        this.easing = easing || jQuery.easing._default;
	        this.options = options;
	        this.start = this.now = this.cur();
	        this.end = end;
	        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
	      },
	      cur: function () {
	        var hooks = Tween.propHooks[this.prop];
	        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
	      },
	      run: function (percent) {
	        var eased,
	            hooks = Tween.propHooks[this.prop];

	        if (this.options.duration) {
	          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
	        } else {
	          this.pos = eased = percent;
	        }

	        this.now = (this.end - this.start) * eased + this.start;

	        if (this.options.step) {
	          this.options.step.call(this.elem, this.now, this);
	        }

	        if (hooks && hooks.set) {
	          hooks.set(this);
	        } else {
	          Tween.propHooks._default.set(this);
	        }

	        return this;
	      }
	    };
	    Tween.prototype.init.prototype = Tween.prototype;
	    Tween.propHooks = {
	      _default: {
	        get: function (tween) {
	          var result; // Use a property on the element directly when it is not a DOM element,
	          // or when there is no matching style property that exists.

	          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
	            return tween.elem[tween.prop];
	          } // Passing an empty string as a 3rd parameter to .css will automatically
	          // attempt a parseFloat and fallback to a string if the parse fails.
	          // Simple values such as "10px" are parsed to Float;
	          // complex values such as "rotate(1rad)" are returned as-is.


	          result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

	          return !result || result === "auto" ? 0 : result;
	        },
	        set: function (tween) {
	          // Use step hook for back compat.
	          // Use cssHook if its there.
	          // Use .style if available and use plain properties where available.
	          if (jQuery.fx.step[tween.prop]) {
	            jQuery.fx.step[tween.prop](tween);
	          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
	            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
	          } else {
	            tween.elem[tween.prop] = tween.now;
	          }
	        }
	      }
	    }; // Support: IE <=9 only
	    // Panic based approach to setting things on disconnected nodes

	    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	      set: function (tween) {
	        if (tween.elem.nodeType && tween.elem.parentNode) {
	          tween.elem[tween.prop] = tween.now;
	        }
	      }
	    };
	    jQuery.easing = {
	      linear: function (p) {
	        return p;
	      },
	      swing: function (p) {
	        return 0.5 - Math.cos(p * Math.PI) / 2;
	      },
	      _default: "swing"
	    };
	    jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

	    jQuery.fx.step = {};
	    var fxNow,
	        inProgress,
	        rfxtypes = /^(?:toggle|show|hide)$/,
	        rrun = /queueHooks$/;

	    function schedule() {
	      if (inProgress) {
	        if (document.hidden === false && window.requestAnimationFrame) {
	          window.requestAnimationFrame(schedule);
	        } else {
	          window.setTimeout(schedule, jQuery.fx.interval);
	        }

	        jQuery.fx.tick();
	      }
	    } // Animations created synchronously will run synchronously


	    function createFxNow() {
	      window.setTimeout(function () {
	        fxNow = undefined;
	      });
	      return fxNow = Date.now();
	    } // Generate parameters to create a standard animation


	    function genFx(type, includeWidth) {
	      var which,
	          i = 0,
	          attrs = {
	        height: type
	      }; // If we include width, step value is 1 to do all cssExpand values,
	      // otherwise step value is 2 to skip over Left and Right

	      includeWidth = includeWidth ? 1 : 0;

	      for (; i < 4; i += 2 - includeWidth) {
	        which = cssExpand[i];
	        attrs["margin" + which] = attrs["padding" + which] = type;
	      }

	      if (includeWidth) {
	        attrs.opacity = attrs.width = type;
	      }

	      return attrs;
	    }

	    function createTween(value, prop, animation) {
	      var tween,
	          collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
	          index = 0,
	          length = collection.length;

	      for (; index < length; index++) {
	        if (tween = collection[index].call(animation, prop, value)) {
	          // We're done with this property
	          return tween;
	        }
	      }
	    }

	    function defaultPrefilter(elem, props, opts) {
	      var prop,
	          value,
	          toggle,
	          hooks,
	          oldfire,
	          propTween,
	          restoreDisplay,
	          display,
	          isBox = "width" in props || "height" in props,
	          anim = this,
	          orig = {},
	          style = elem.style,
	          hidden = elem.nodeType && isHiddenWithinTree(elem),
	          dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

	      if (!opts.queue) {
	        hooks = jQuery._queueHooks(elem, "fx");

	        if (hooks.unqueued == null) {
	          hooks.unqueued = 0;
	          oldfire = hooks.empty.fire;

	          hooks.empty.fire = function () {
	            if (!hooks.unqueued) {
	              oldfire();
	            }
	          };
	        }

	        hooks.unqueued++;
	        anim.always(function () {
	          // Ensure the complete handler is called before this completes
	          anim.always(function () {
	            hooks.unqueued--;

	            if (!jQuery.queue(elem, "fx").length) {
	              hooks.empty.fire();
	            }
	          });
	        });
	      } // Detect show/hide animations


	      for (prop in props) {
	        value = props[prop];

	        if (rfxtypes.test(value)) {
	          delete props[prop];
	          toggle = toggle || value === "toggle";

	          if (value === (hidden ? "hide" : "show")) {
	            // Pretend to be hidden if this is a "show" and
	            // there is still data from a stopped show/hide
	            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
	              hidden = true; // Ignore all other no-op show/hide data
	            } else {
	              continue;
	            }
	          }

	          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
	        }
	      } // Bail out if this is a no-op like .hide().hide()


	      propTween = !jQuery.isEmptyObject(props);

	      if (!propTween && jQuery.isEmptyObject(orig)) {
	        return;
	      } // Restrict "overflow" and "display" styles during box animations


	      if (isBox && elem.nodeType === 1) {
	        // Support: IE <=9 - 11, Edge 12 - 15
	        // Record all 3 overflow attributes because IE does not infer the shorthand
	        // from identically-valued overflowX and overflowY and Edge just mirrors
	        // the overflowX value there.
	        opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

	        restoreDisplay = dataShow && dataShow.display;

	        if (restoreDisplay == null) {
	          restoreDisplay = dataPriv.get(elem, "display");
	        }

	        display = jQuery.css(elem, "display");

	        if (display === "none") {
	          if (restoreDisplay) {
	            display = restoreDisplay;
	          } else {
	            // Get nonempty value(s) by temporarily forcing visibility
	            showHide([elem], true);
	            restoreDisplay = elem.style.display || restoreDisplay;
	            display = jQuery.css(elem, "display");
	            showHide([elem]);
	          }
	        } // Animate inline elements as inline-block


	        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
	          if (jQuery.css(elem, "float") === "none") {
	            // Restore the original display value at the end of pure show/hide animations
	            if (!propTween) {
	              anim.done(function () {
	                style.display = restoreDisplay;
	              });

	              if (restoreDisplay == null) {
	                display = style.display;
	                restoreDisplay = display === "none" ? "" : display;
	              }
	            }

	            style.display = "inline-block";
	          }
	        }
	      }

	      if (opts.overflow) {
	        style.overflow = "hidden";
	        anim.always(function () {
	          style.overflow = opts.overflow[0];
	          style.overflowX = opts.overflow[1];
	          style.overflowY = opts.overflow[2];
	        });
	      } // Implement show/hide animations


	      propTween = false;

	      for (prop in orig) {
	        // General show/hide setup for this element animation
	        if (!propTween) {
	          if (dataShow) {
	            if ("hidden" in dataShow) {
	              hidden = dataShow.hidden;
	            }
	          } else {
	            dataShow = dataPriv.access(elem, "fxshow", {
	              display: restoreDisplay
	            });
	          } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


	          if (toggle) {
	            dataShow.hidden = !hidden;
	          } // Show elements before animating them


	          if (hidden) {
	            showHide([elem], true);
	          }
	          /* eslint-disable no-loop-func */


	          anim.done(function () {
	            /* eslint-enable no-loop-func */
	            // The final step of a "hide" animation is actually hiding the element
	            if (!hidden) {
	              showHide([elem]);
	            }

	            dataPriv.remove(elem, "fxshow");

	            for (prop in orig) {
	              jQuery.style(elem, prop, orig[prop]);
	            }
	          });
	        } // Per-property setup


	        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

	        if (!(prop in dataShow)) {
	          dataShow[prop] = propTween.start;

	          if (hidden) {
	            propTween.end = propTween.start;
	            propTween.start = 0;
	          }
	        }
	      }
	    }

	    function propFilter(props, specialEasing) {
	      var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

	      for (index in props) {
	        name = camelCase(index);
	        easing = specialEasing[name];
	        value = props[index];

	        if (Array.isArray(value)) {
	          easing = value[1];
	          value = props[index] = value[0];
	        }

	        if (index !== name) {
	          props[name] = value;
	          delete props[index];
	        }

	        hooks = jQuery.cssHooks[name];

	        if (hooks && "expand" in hooks) {
	          value = hooks.expand(value);
	          delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
	          // Reusing 'index' because we have the correct "name"

	          for (index in value) {
	            if (!(index in props)) {
	              props[index] = value[index];
	              specialEasing[index] = easing;
	            }
	          }
	        } else {
	          specialEasing[name] = easing;
	        }
	      }
	    }

	    function Animation(elem, properties, options) {
	      var result,
	          stopped,
	          index = 0,
	          length = Animation.prefilters.length,
	          deferred = jQuery.Deferred().always(function () {
	        // Don't match elem in the :animated selector
	        delete tick.elem;
	      }),
	          tick = function () {
	        if (stopped) {
	          return false;
	        }

	        var currentTime = fxNow || createFxNow(),
	            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
	            // Support: Android 2.3 only
	        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
	        temp = remaining / animation.duration || 0,
	            percent = 1 - temp,
	            index = 0,
	            length = animation.tweens.length;

	        for (; index < length; index++) {
	          animation.tweens[index].run(percent);
	        }

	        deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

	        if (percent < 1 && length) {
	          return remaining;
	        } // If this was an empty animation, synthesize a final progress notification


	        if (!length) {
	          deferred.notifyWith(elem, [animation, 1, 0]);
	        } // Resolve the animation and report its conclusion


	        deferred.resolveWith(elem, [animation]);
	        return false;
	      },
	          animation = deferred.promise({
	        elem: elem,
	        props: jQuery.extend({}, properties),
	        opts: jQuery.extend(true, {
	          specialEasing: {},
	          easing: jQuery.easing._default
	        }, options),
	        originalProperties: properties,
	        originalOptions: options,
	        startTime: fxNow || createFxNow(),
	        duration: options.duration,
	        tweens: [],
	        createTween: function (prop, end) {
	          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
	          animation.tweens.push(tween);
	          return tween;
	        },
	        stop: function (gotoEnd) {
	          var index = 0,
	              // If we are going to the end, we want to run all the tweens
	          // otherwise we skip this part
	          length = gotoEnd ? animation.tweens.length : 0;

	          if (stopped) {
	            return this;
	          }

	          stopped = true;

	          for (; index < length; index++) {
	            animation.tweens[index].run(1);
	          } // Resolve when we played the last frame; otherwise, reject


	          if (gotoEnd) {
	            deferred.notifyWith(elem, [animation, 1, 0]);
	            deferred.resolveWith(elem, [animation, gotoEnd]);
	          } else {
	            deferred.rejectWith(elem, [animation, gotoEnd]);
	          }

	          return this;
	        }
	      }),
	          props = animation.props;

	      propFilter(props, animation.opts.specialEasing);

	      for (; index < length; index++) {
	        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

	        if (result) {
	          if (isFunction(result.stop)) {
	            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
	          }

	          return result;
	        }
	      }

	      jQuery.map(props, createTween, animation);

	      if (isFunction(animation.opts.start)) {
	        animation.opts.start.call(elem, animation);
	      } // Attach callbacks from options


	      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	      jQuery.fx.timer(jQuery.extend(tick, {
	        elem: elem,
	        anim: animation,
	        queue: animation.opts.queue
	      }));
	      return animation;
	    }

	    jQuery.Animation = jQuery.extend(Animation, {
	      tweeners: {
	        "*": [function (prop, value) {
	          var tween = this.createTween(prop, value);
	          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
	          return tween;
	        }]
	      },
	      tweener: function (props, callback) {
	        if (isFunction(props)) {
	          callback = props;
	          props = ["*"];
	        } else {
	          props = props.match(rnothtmlwhite);
	        }

	        var prop,
	            index = 0,
	            length = props.length;

	        for (; index < length; index++) {
	          prop = props[index];
	          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
	          Animation.tweeners[prop].unshift(callback);
	        }
	      },
	      prefilters: [defaultPrefilter],
	      prefilter: function (callback, prepend) {
	        if (prepend) {
	          Animation.prefilters.unshift(callback);
	        } else {
	          Animation.prefilters.push(callback);
	        }
	      }
	    });

	    jQuery.speed = function (speed, easing, fn) {
	      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
	        complete: fn || !fn && easing || isFunction(speed) && speed,
	        duration: speed,
	        easing: fn && easing || easing && !isFunction(easing) && easing
	      }; // Go to the end state if fx are off

	      if (jQuery.fx.off) {
	        opt.duration = 0;
	      } else {
	        if (typeof opt.duration !== "number") {
	          if (opt.duration in jQuery.fx.speeds) {
	            opt.duration = jQuery.fx.speeds[opt.duration];
	          } else {
	            opt.duration = jQuery.fx.speeds._default;
	          }
	        }
	      } // Normalize opt.queue - true/undefined/null -> "fx"


	      if (opt.queue == null || opt.queue === true) {
	        opt.queue = "fx";
	      } // Queueing


	      opt.old = opt.complete;

	      opt.complete = function () {
	        if (isFunction(opt.old)) {
	          opt.old.call(this);
	        }

	        if (opt.queue) {
	          jQuery.dequeue(this, opt.queue);
	        }
	      };

	      return opt;
	    };

	    jQuery.fn.extend({
	      fadeTo: function (speed, to, easing, callback) {
	        // Show any hidden elements after setting opacity to 0
	        return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
	        .end().animate({
	          opacity: to
	        }, speed, easing, callback);
	      },
	      animate: function (prop, speed, easing, callback) {
	        var empty = jQuery.isEmptyObject(prop),
	            optall = jQuery.speed(speed, easing, callback),
	            doAnimation = function () {
	          // Operate on a copy of prop so per-property easing won't be lost
	          var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

	          if (empty || dataPriv.get(this, "finish")) {
	            anim.stop(true);
	          }
	        };

	        doAnimation.finish = doAnimation;
	        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
	      },
	      stop: function (type, clearQueue, gotoEnd) {
	        var stopQueue = function (hooks) {
	          var stop = hooks.stop;
	          delete hooks.stop;
	          stop(gotoEnd);
	        };

	        if (typeof type !== "string") {
	          gotoEnd = clearQueue;
	          clearQueue = type;
	          type = undefined;
	        }

	        if (clearQueue) {
	          this.queue(type || "fx", []);
	        }

	        return this.each(function () {
	          var dequeue = true,
	              index = type != null && type + "queueHooks",
	              timers = jQuery.timers,
	              data = dataPriv.get(this);

	          if (index) {
	            if (data[index] && data[index].stop) {
	              stopQueue(data[index]);
	            }
	          } else {
	            for (index in data) {
	              if (data[index] && data[index].stop && rrun.test(index)) {
	                stopQueue(data[index]);
	              }
	            }
	          }

	          for (index = timers.length; index--;) {
	            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
	              timers[index].anim.stop(gotoEnd);
	              dequeue = false;
	              timers.splice(index, 1);
	            }
	          } // Start the next in the queue if the last step wasn't forced.
	          // Timers currently will call their complete callbacks, which
	          // will dequeue but only if they were gotoEnd.


	          if (dequeue || !gotoEnd) {
	            jQuery.dequeue(this, type);
	          }
	        });
	      },
	      finish: function (type) {
	        if (type !== false) {
	          type = type || "fx";
	        }

	        return this.each(function () {
	          var index,
	              data = dataPriv.get(this),
	              queue = data[type + "queue"],
	              hooks = data[type + "queueHooks"],
	              timers = jQuery.timers,
	              length = queue ? queue.length : 0; // Enable finishing flag on private data

	          data.finish = true; // Empty the queue first

	          jQuery.queue(this, type, []);

	          if (hooks && hooks.stop) {
	            hooks.stop.call(this, true);
	          } // Look for any active animations, and finish them


	          for (index = timers.length; index--;) {
	            if (timers[index].elem === this && timers[index].queue === type) {
	              timers[index].anim.stop(true);
	              timers.splice(index, 1);
	            }
	          } // Look for any animations in the old queue and finish them


	          for (index = 0; index < length; index++) {
	            if (queue[index] && queue[index].finish) {
	              queue[index].finish.call(this);
	            }
	          } // Turn off finishing flag


	          delete data.finish;
	        });
	      }
	    });
	    jQuery.each(["toggle", "show", "hide"], function (_i, name) {
	      var cssFn = jQuery.fn[name];

	      jQuery.fn[name] = function (speed, easing, callback) {
	        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
	      };
	    }); // Generate shortcuts for custom animations

	    jQuery.each({
	      slideDown: genFx("show"),
	      slideUp: genFx("hide"),
	      slideToggle: genFx("toggle"),
	      fadeIn: {
	        opacity: "show"
	      },
	      fadeOut: {
	        opacity: "hide"
	      },
	      fadeToggle: {
	        opacity: "toggle"
	      }
	    }, function (name, props) {
	      jQuery.fn[name] = function (speed, easing, callback) {
	        return this.animate(props, speed, easing, callback);
	      };
	    });
	    jQuery.timers = [];

	    jQuery.fx.tick = function () {
	      var timer,
	          i = 0,
	          timers = jQuery.timers;
	      fxNow = Date.now();

	      for (; i < timers.length; i++) {
	        timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

	        if (!timer() && timers[i] === timer) {
	          timers.splice(i--, 1);
	        }
	      }

	      if (!timers.length) {
	        jQuery.fx.stop();
	      }

	      fxNow = undefined;
	    };

	    jQuery.fx.timer = function (timer) {
	      jQuery.timers.push(timer);
	      jQuery.fx.start();
	    };

	    jQuery.fx.interval = 13;

	    jQuery.fx.start = function () {
	      if (inProgress) {
	        return;
	      }

	      inProgress = true;
	      schedule();
	    };

	    jQuery.fx.stop = function () {
	      inProgress = null;
	    };

	    jQuery.fx.speeds = {
	      slow: 600,
	      fast: 200,
	      // Default speed
	      _default: 400
	    }; // Based off of the plugin by Clint Helfers, with permission.
	    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

	    jQuery.fn.delay = function (time, type) {
	      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
	      type = type || "fx";
	      return this.queue(type, function (next, hooks) {
	        var timeout = window.setTimeout(next, time);

	        hooks.stop = function () {
	          window.clearTimeout(timeout);
	        };
	      });
	    };

	    (function () {
	      var input = document.createElement("input"),
	          select = document.createElement("select"),
	          opt = select.appendChild(document.createElement("option"));
	      input.type = "checkbox"; // Support: Android <=4.3 only
	      // Default value for a checkbox should be "on"

	      support.checkOn = input.value !== ""; // Support: IE <=11 only
	      // Must access selectedIndex to make default options select

	      support.optSelected = opt.selected; // Support: IE <=11 only
	      // An input loses its value after becoming a radio

	      input = document.createElement("input");
	      input.value = "t";
	      input.type = "radio";
	      support.radioValue = input.value === "t";
	    })();

	    var boolHook,
	        attrHandle = jQuery.expr.attrHandle;
	    jQuery.fn.extend({
	      attr: function (name, value) {
	        return access(this, jQuery.attr, name, value, arguments.length > 1);
	      },
	      removeAttr: function (name) {
	        return this.each(function () {
	          jQuery.removeAttr(this, name);
	        });
	      }
	    });
	    jQuery.extend({
	      attr: function (elem, name, value) {
	        var ret,
	            hooks,
	            nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

	        if (nType === 3 || nType === 8 || nType === 2) {
	          return;
	        } // Fallback to prop when attributes are not supported


	        if (typeof elem.getAttribute === "undefined") {
	          return jQuery.prop(elem, name, value);
	        } // Attribute hooks are determined by the lowercase version
	        // Grab necessary hook if one is defined


	        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
	        }

	        if (value !== undefined) {
	          if (value === null) {
	            jQuery.removeAttr(elem, name);
	            return;
	          }

	          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	            return ret;
	          }

	          elem.setAttribute(name, value + "");
	          return value;
	        }

	        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	          return ret;
	        }

	        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

	        return ret == null ? undefined : ret;
	      },
	      attrHooks: {
	        type: {
	          set: function (elem, value) {
	            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
	              var val = elem.value;
	              elem.setAttribute("type", value);

	              if (val) {
	                elem.value = val;
	              }

	              return value;
	            }
	          }
	        }
	      },
	      removeAttr: function (elem, value) {
	        var name,
	            i = 0,
	            // Attribute names can contain non-HTML whitespace characters
	        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	        attrNames = value && value.match(rnothtmlwhite);

	        if (attrNames && elem.nodeType === 1) {
	          while (name = attrNames[i++]) {
	            elem.removeAttribute(name);
	          }
	        }
	      }
	    }); // Hooks for boolean attributes

	    boolHook = {
	      set: function (elem, value, name) {
	        if (value === false) {
	          // Remove boolean attributes when set to false
	          jQuery.removeAttr(elem, name);
	        } else {
	          elem.setAttribute(name, name);
	        }

	        return name;
	      }
	    };
	    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
	      var getter = attrHandle[name] || jQuery.find.attr;

	      attrHandle[name] = function (elem, name, isXML) {
	        var ret,
	            handle,
	            lowercaseName = name.toLowerCase();

	        if (!isXML) {
	          // Avoid an infinite loop by temporarily removing this function from the getter
	          handle = attrHandle[lowercaseName];
	          attrHandle[lowercaseName] = ret;
	          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
	          attrHandle[lowercaseName] = handle;
	        }

	        return ret;
	      };
	    });
	    var rfocusable = /^(?:input|select|textarea|button)$/i,
	        rclickable = /^(?:a|area)$/i;
	    jQuery.fn.extend({
	      prop: function (name, value) {
	        return access(this, jQuery.prop, name, value, arguments.length > 1);
	      },
	      removeProp: function (name) {
	        return this.each(function () {
	          delete this[jQuery.propFix[name] || name];
	        });
	      }
	    });
	    jQuery.extend({
	      prop: function (elem, name, value) {
	        var ret,
	            hooks,
	            nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

	        if (nType === 3 || nType === 8 || nType === 2) {
	          return;
	        }

	        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	          // Fix name and attach hooks
	          name = jQuery.propFix[name] || name;
	          hooks = jQuery.propHooks[name];
	        }

	        if (value !== undefined) {
	          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	            return ret;
	          }

	          return elem[name] = value;
	        }

	        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	          return ret;
	        }

	        return elem[name];
	      },
	      propHooks: {
	        tabIndex: {
	          get: function (elem) {
	            // Support: IE <=9 - 11 only
	            // elem.tabIndex doesn't always return the
	            // correct value when it hasn't been explicitly set
	            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
	            // Use proper attribute retrieval(#12072)
	            var tabindex = jQuery.find.attr(elem, "tabindex");

	            if (tabindex) {
	              return parseInt(tabindex, 10);
	            }

	            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
	              return 0;
	            }

	            return -1;
	          }
	        }
	      },
	      propFix: {
	        for: "htmlFor",
	        class: "className"
	      }
	    }); // Support: IE <=11 only
	    // Accessing the selectedIndex property
	    // forces the browser to respect setting selected
	    // on the option
	    // The getter ensures a default option is selected
	    // when in an optgroup
	    // eslint rule "no-unused-expressions" is disabled for this code
	    // since it considers such accessions noop

	    if (!support.optSelected) {
	      jQuery.propHooks.selected = {
	        get: function (elem) {
	          /* eslint no-unused-expressions: "off" */
	          var parent = elem.parentNode;

	          if (parent && parent.parentNode) {
	            parent.parentNode.selectedIndex;
	          }

	          return null;
	        },
	        set: function (elem) {
	          /* eslint no-unused-expressions: "off" */
	          var parent = elem.parentNode;

	          if (parent) {
	            parent.selectedIndex;

	            if (parent.parentNode) {
	              parent.parentNode.selectedIndex;
	            }
	          }
	        }
	      };
	    }

	    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	      jQuery.propFix[this.toLowerCase()] = this;
	    }); // Strip and collapse whitespace according to HTML spec
	    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

	    function stripAndCollapse(value) {
	      var tokens = value.match(rnothtmlwhite) || [];
	      return tokens.join(" ");
	    }

	    function getClass(elem) {
	      return elem.getAttribute && elem.getAttribute("class") || "";
	    }

	    function classesToArray(value) {
	      if (Array.isArray(value)) {
	        return value;
	      }

	      if (typeof value === "string") {
	        return value.match(rnothtmlwhite) || [];
	      }

	      return [];
	    }

	    jQuery.fn.extend({
	      addClass: function (value) {
	        var classes,
	            elem,
	            cur,
	            curValue,
	            clazz,
	            j,
	            finalValue,
	            i = 0;

	        if (isFunction(value)) {
	          return this.each(function (j) {
	            jQuery(this).addClass(value.call(this, j, getClass(this)));
	          });
	        }

	        classes = classesToArray(value);

	        if (classes.length) {
	          while (elem = this[i++]) {
	            curValue = getClass(elem);
	            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

	            if (cur) {
	              j = 0;

	              while (clazz = classes[j++]) {
	                if (cur.indexOf(" " + clazz + " ") < 0) {
	                  cur += clazz + " ";
	                }
	              } // Only assign if different to avoid unneeded rendering.


	              finalValue = stripAndCollapse(cur);

	              if (curValue !== finalValue) {
	                elem.setAttribute("class", finalValue);
	              }
	            }
	          }
	        }

	        return this;
	      },
	      removeClass: function (value) {
	        var classes,
	            elem,
	            cur,
	            curValue,
	            clazz,
	            j,
	            finalValue,
	            i = 0;

	        if (isFunction(value)) {
	          return this.each(function (j) {
	            jQuery(this).removeClass(value.call(this, j, getClass(this)));
	          });
	        }

	        if (!arguments.length) {
	          return this.attr("class", "");
	        }

	        classes = classesToArray(value);

	        if (classes.length) {
	          while (elem = this[i++]) {
	            curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

	            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

	            if (cur) {
	              j = 0;

	              while (clazz = classes[j++]) {
	                // Remove *all* instances
	                while (cur.indexOf(" " + clazz + " ") > -1) {
	                  cur = cur.replace(" " + clazz + " ", " ");
	                }
	              } // Only assign if different to avoid unneeded rendering.


	              finalValue = stripAndCollapse(cur);

	              if (curValue !== finalValue) {
	                elem.setAttribute("class", finalValue);
	              }
	            }
	          }
	        }

	        return this;
	      },
	      toggleClass: function (value, stateVal) {
	        var type = typeof value,
	            isValidValue = type === "string" || Array.isArray(value);

	        if (typeof stateVal === "boolean" && isValidValue) {
	          return stateVal ? this.addClass(value) : this.removeClass(value);
	        }

	        if (isFunction(value)) {
	          return this.each(function (i) {
	            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
	          });
	        }

	        return this.each(function () {
	          var className, i, self, classNames;

	          if (isValidValue) {
	            // Toggle individual class names
	            i = 0;
	            self = jQuery(this);
	            classNames = classesToArray(value);

	            while (className = classNames[i++]) {
	              // Check each className given, space separated list
	              if (self.hasClass(className)) {
	                self.removeClass(className);
	              } else {
	                self.addClass(className);
	              }
	            } // Toggle whole class name

	          } else if (value === undefined || type === "boolean") {
	            className = getClass(this);

	            if (className) {
	              // Store className if set
	              dataPriv.set(this, "__className__", className);
	            } // If the element has a class name or if we're passed `false`,
	            // then remove the whole classname (if there was one, the above saved it).
	            // Otherwise bring back whatever was previously saved (if anything),
	            // falling back to the empty string if nothing was stored.


	            if (this.setAttribute) {
	              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
	            }
	          }
	        });
	      },
	      hasClass: function (selector) {
	        var className,
	            elem,
	            i = 0;
	        className = " " + selector + " ";

	        while (elem = this[i++]) {
	          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
	            return true;
	          }
	        }

	        return false;
	      }
	    });
	    var rreturn = /\r/g;
	    jQuery.fn.extend({
	      val: function (value) {
	        var hooks,
	            ret,
	            valueIsFunction,
	            elem = this[0];

	        if (!arguments.length) {
	          if (elem) {
	            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

	            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
	              return ret;
	            }

	            ret = elem.value; // Handle most common string cases

	            if (typeof ret === "string") {
	              return ret.replace(rreturn, "");
	            } // Handle cases where value is null/undef or number


	            return ret == null ? "" : ret;
	          }

	          return;
	        }

	        valueIsFunction = isFunction(value);
	        return this.each(function (i) {
	          var val;

	          if (this.nodeType !== 1) {
	            return;
	          }

	          if (valueIsFunction) {
	            val = value.call(this, i, jQuery(this).val());
	          } else {
	            val = value;
	          } // Treat null/undefined as ""; convert numbers to string


	          if (val == null) {
	            val = "";
	          } else if (typeof val === "number") {
	            val += "";
	          } else if (Array.isArray(val)) {
	            val = jQuery.map(val, function (value) {
	              return value == null ? "" : value + "";
	            });
	          }

	          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

	          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
	            this.value = val;
	          }
	        });
	      }
	    });
	    jQuery.extend({
	      valHooks: {
	        option: {
	          get: function (elem) {
	            var val = jQuery.find.attr(elem, "value");
	            return val != null ? val : // Support: IE <=10 - 11 only
	            // option.text throws exceptions (#14686, #14858)
	            // Strip and collapse whitespace
	            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
	            stripAndCollapse(jQuery.text(elem));
	          }
	        },
	        select: {
	          get: function (elem) {
	            var value,
	                option,
	                i,
	                options = elem.options,
	                index = elem.selectedIndex,
	                one = elem.type === "select-one",
	                values = one ? null : [],
	                max = one ? index + 1 : options.length;

	            if (index < 0) {
	              i = max;
	            } else {
	              i = one ? index : 0;
	            } // Loop through all the selected options


	            for (; i < max; i++) {
	              option = options[i]; // Support: IE <=9 only
	              // IE8-9 doesn't update selected after form reset (#2551)

	              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
	              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
	                // Get the specific value for the option
	                value = jQuery(option).val(); // We don't need an array for one selects

	                if (one) {
	                  return value;
	                } // Multi-Selects return an array


	                values.push(value);
	              }
	            }

	            return values;
	          },
	          set: function (elem, value) {
	            var optionSet,
	                option,
	                options = elem.options,
	                values = jQuery.makeArray(value),
	                i = options.length;

	            while (i--) {
	              option = options[i];
	              /* eslint-disable no-cond-assign */

	              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
	                optionSet = true;
	              }
	              /* eslint-enable no-cond-assign */

	            } // Force browsers to behave consistently when non-matching value is set


	            if (!optionSet) {
	              elem.selectedIndex = -1;
	            }

	            return values;
	          }
	        }
	      }
	    }); // Radios and checkboxes getter/setter

	    jQuery.each(["radio", "checkbox"], function () {
	      jQuery.valHooks[this] = {
	        set: function (elem, value) {
	          if (Array.isArray(value)) {
	            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
	          }
	        }
	      };

	      if (!support.checkOn) {
	        jQuery.valHooks[this].get = function (elem) {
	          return elem.getAttribute("value") === null ? "on" : elem.value;
	        };
	      }
	    }); // Return jQuery for attributes-only inclusion

	    support.focusin = "onfocusin" in window;

	    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	        stopPropagationCallback = function (e) {
	      e.stopPropagation();
	    };

	    jQuery.extend(jQuery.event, {
	      trigger: function (event, data, elem, onlyHandlers) {
	        var i,
	            cur,
	            tmp,
	            bubbleType,
	            ontype,
	            handle,
	            special,
	            lastElement,
	            eventPath = [elem || document],
	            type = hasOwn.call(event, "type") ? event.type : event,
	            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
	        cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

	        if (elem.nodeType === 3 || elem.nodeType === 8) {
	          return;
	        } // focus/blur morphs to focusin/out; ensure we're not firing them right now


	        if (rfocusMorph.test(type + jQuery.event.triggered)) {
	          return;
	        }

	        if (type.indexOf(".") > -1) {
	          // Namespaced trigger; create a regexp to match event type in handle()
	          namespaces = type.split(".");
	          type = namespaces.shift();
	          namespaces.sort();
	        }

	        ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

	        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

	        event.isTrigger = onlyHandlers ? 2 : 3;
	        event.namespace = namespaces.join(".");
	        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

	        event.result = undefined;

	        if (!event.target) {
	          event.target = elem;
	        } // Clone any incoming data and prepend the event, creating the handler arg list


	        data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

	        special = jQuery.event.special[type] || {};

	        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
	          return;
	        } // Determine event propagation path in advance, per W3C events spec (#9951)
	        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


	        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
	          bubbleType = special.delegateType || type;

	          if (!rfocusMorph.test(bubbleType + type)) {
	            cur = cur.parentNode;
	          }

	          for (; cur; cur = cur.parentNode) {
	            eventPath.push(cur);
	            tmp = cur;
	          } // Only add window if we got to document (e.g., not plain obj or detached DOM)


	          if (tmp === (elem.ownerDocument || document)) {
	            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
	          }
	        } // Fire handlers on the event path


	        i = 0;

	        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
	          lastElement = cur;
	          event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

	          handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

	          if (handle) {
	            handle.apply(cur, data);
	          } // Native handler


	          handle = ontype && cur[ontype];

	          if (handle && handle.apply && acceptData(cur)) {
	            event.result = handle.apply(cur, data);

	            if (event.result === false) {
	              event.preventDefault();
	            }
	          }
	        }

	        event.type = type; // If nobody prevented the default action, do it now

	        if (!onlyHandlers && !event.isDefaultPrevented()) {
	          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
	            // Call a native DOM method on the target with the same name as the event.
	            // Don't do default actions on window, that's where global variables be (#6170)
	            if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
	              // Don't re-trigger an onFOO event when we call its FOO() method
	              tmp = elem[ontype];

	              if (tmp) {
	                elem[ontype] = null;
	              } // Prevent re-triggering of the same event, since we already bubbled it above


	              jQuery.event.triggered = type;

	              if (event.isPropagationStopped()) {
	                lastElement.addEventListener(type, stopPropagationCallback);
	              }

	              elem[type]();

	              if (event.isPropagationStopped()) {
	                lastElement.removeEventListener(type, stopPropagationCallback);
	              }

	              jQuery.event.triggered = undefined;

	              if (tmp) {
	                elem[ontype] = tmp;
	              }
	            }
	          }
	        }

	        return event.result;
	      },
	      // Piggyback on a donor event to simulate a different one
	      // Used only for `focus(in | out)` events
	      simulate: function (type, elem, event) {
	        var e = jQuery.extend(new jQuery.Event(), event, {
	          type: type,
	          isSimulated: true
	        });
	        jQuery.event.trigger(e, null, elem);
	      }
	    });
	    jQuery.fn.extend({
	      trigger: function (type, data) {
	        return this.each(function () {
	          jQuery.event.trigger(type, data, this);
	        });
	      },
	      triggerHandler: function (type, data) {
	        var elem = this[0];

	        if (elem) {
	          return jQuery.event.trigger(type, data, elem, true);
	        }
	      }
	    }); // Support: Firefox <=44
	    // Firefox doesn't have focus(in | out) events
	    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	    //
	    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	    // focus(in | out) events fire after focus & blur events,
	    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

	    if (!support.focusin) {
	      jQuery.each({
	        focus: "focusin",
	        blur: "focusout"
	      }, function (orig, fix) {
	        // Attach a single capturing handler on the document while someone wants focusin/focusout
	        var handler = function (event) {
	          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
	        };

	        jQuery.event.special[fix] = {
	          setup: function () {
	            // Handle: regular nodes (via `this.ownerDocument`), window
	            // (via `this.document`) & document (via `this`).
	            var doc = this.ownerDocument || this.document || this,
	                attaches = dataPriv.access(doc, fix);

	            if (!attaches) {
	              doc.addEventListener(orig, handler, true);
	            }

	            dataPriv.access(doc, fix, (attaches || 0) + 1);
	          },
	          teardown: function () {
	            var doc = this.ownerDocument || this.document || this,
	                attaches = dataPriv.access(doc, fix) - 1;

	            if (!attaches) {
	              doc.removeEventListener(orig, handler, true);
	              dataPriv.remove(doc, fix);
	            } else {
	              dataPriv.access(doc, fix, attaches);
	            }
	          }
	        };
	      });
	    }

	    var location = window.location;
	    var nonce = {
	      guid: Date.now()
	    };
	    var rquery = /\?/; // Cross-browser xml parsing

	    jQuery.parseXML = function (data) {
	      var xml;

	      if (!data || typeof data !== "string") {
	        return null;
	      } // Support: IE 9 - 11 only
	      // IE throws on parseFromString with invalid input.


	      try {
	        xml = new window.DOMParser().parseFromString(data, "text/xml");
	      } catch (e) {
	        xml = undefined;
	      }

	      if (!xml || xml.getElementsByTagName("parsererror").length) {
	        jQuery.error("Invalid XML: " + data);
	      }

	      return xml;
	    };

	    var rbracket = /\[\]$/,
	        rCRLF = /\r?\n/g,
	        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	        rsubmittable = /^(?:input|select|textarea|keygen)/i;

	    function buildParams(prefix, obj, traditional, add) {
	      var name;

	      if (Array.isArray(obj)) {
	        // Serialize array item.
	        jQuery.each(obj, function (i, v) {
	          if (traditional || rbracket.test(prefix)) {
	            // Treat each array item as a scalar.
	            add(prefix, v);
	          } else {
	            // Item is non-scalar (array or object), encode its numeric index.
	            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
	          }
	        });
	      } else if (!traditional && toType(obj) === "object") {
	        // Serialize object item.
	        for (name in obj) {
	          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
	        }
	      } else {
	        // Serialize scalar item.
	        add(prefix, obj);
	      }
	    } // Serialize an array of form elements or a set of
	    // key/values into a query string


	    jQuery.param = function (a, traditional) {
	      var prefix,
	          s = [],
	          add = function (key, valueOrFunction) {
	        // If value is a function, invoke it and use its return value
	        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
	        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
	      };

	      if (a == null) {
	        return "";
	      } // If an array was passed in, assume that it is an array of form elements.


	      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
	        // Serialize the form elements
	        jQuery.each(a, function () {
	          add(this.name, this.value);
	        });
	      } else {
	        // If traditional, encode the "old" way (the way 1.3.2 or older
	        // did it), otherwise encode params recursively.
	        for (prefix in a) {
	          buildParams(prefix, a[prefix], traditional, add);
	        }
	      } // Return the resulting serialization


	      return s.join("&");
	    };

	    jQuery.fn.extend({
	      serialize: function () {
	        return jQuery.param(this.serializeArray());
	      },
	      serializeArray: function () {
	        return this.map(function () {
	          // Can add propHook for "elements" to filter or add form elements
	          var elements = jQuery.prop(this, "elements");
	          return elements ? jQuery.makeArray(elements) : this;
	        }).filter(function () {
	          var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

	          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
	        }).map(function (_i, elem) {
	          var val = jQuery(this).val();

	          if (val == null) {
	            return null;
	          }

	          if (Array.isArray(val)) {
	            return jQuery.map(val, function (val) {
	              return {
	                name: elem.name,
	                value: val.replace(rCRLF, "\r\n")
	              };
	            });
	          }

	          return {
	            name: elem.name,
	            value: val.replace(rCRLF, "\r\n")
	          };
	        }).get();
	      }
	    });
	    var r20 = /%20/g,
	        rhash = /#.*$/,
	        rantiCache = /([?&])_=[^&]*/,
	        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
	        // #7653, #8125, #8152: local protocol detection
	    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	        rnoContent = /^(?:GET|HEAD)$/,
	        rprotocol = /^\/\//,

	    /* Prefilters
	     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	     * 2) These are called:
	     *    - BEFORE asking for a transport
	     *    - AFTER param serialization (s.data is a string if s.processData is true)
	     * 3) key is the dataType
	     * 4) the catchall symbol "*" can be used
	     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	     */
	    prefilters = {},

	    /* Transports bindings
	     * 1) key is the dataType
	     * 2) the catchall symbol "*" can be used
	     * 3) selection will start with transport dataType and THEN go to "*" if needed
	     */
	    transports = {},
	        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	    allTypes = "*/".concat("*"),
	        // Anchor tag for parsing the document origin
	    originAnchor = document.createElement("a");
	    originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

	    function addToPrefiltersOrTransports(structure) {
	      // dataTypeExpression is optional and defaults to "*"
	      return function (dataTypeExpression, func) {
	        if (typeof dataTypeExpression !== "string") {
	          func = dataTypeExpression;
	          dataTypeExpression = "*";
	        }

	        var dataType,
	            i = 0,
	            dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

	        if (isFunction(func)) {
	          // For each dataType in the dataTypeExpression
	          while (dataType = dataTypes[i++]) {
	            // Prepend if requested
	            if (dataType[0] === "+") {
	              dataType = dataType.slice(1) || "*";
	              (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
	            } else {
	              (structure[dataType] = structure[dataType] || []).push(func);
	            }
	          }
	        }
	      };
	    } // Base inspection function for prefilters and transports


	    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
	      var inspected = {},
	          seekingTransport = structure === transports;

	      function inspect(dataType) {
	        var selected;
	        inspected[dataType] = true;
	        jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
	          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

	          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
	            options.dataTypes.unshift(dataTypeOrTransport);
	            inspect(dataTypeOrTransport);
	            return false;
	          } else if (seekingTransport) {
	            return !(selected = dataTypeOrTransport);
	          }
	        });
	        return selected;
	      }

	      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	    } // A special extend for ajax options
	    // that takes "flat" options (not to be deep extended)
	    // Fixes #9887


	    function ajaxExtend(target, src) {
	      var key,
	          deep,
	          flatOptions = jQuery.ajaxSettings.flatOptions || {};

	      for (key in src) {
	        if (src[key] !== undefined) {
	          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
	        }
	      }

	      if (deep) {
	        jQuery.extend(true, target, deep);
	      }

	      return target;
	    }
	    /* Handles responses to an ajax request:
	     * - finds the right dataType (mediates between content-type and expected dataType)
	     * - returns the corresponding response
	     */


	    function ajaxHandleResponses(s, jqXHR, responses) {
	      var ct,
	          type,
	          finalDataType,
	          firstDataType,
	          contents = s.contents,
	          dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

	      while (dataTypes[0] === "*") {
	        dataTypes.shift();

	        if (ct === undefined) {
	          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
	        }
	      } // Check if we're dealing with a known content-type


	      if (ct) {
	        for (type in contents) {
	          if (contents[type] && contents[type].test(ct)) {
	            dataTypes.unshift(type);
	            break;
	          }
	        }
	      } // Check to see if we have a response for the expected dataType


	      if (dataTypes[0] in responses) {
	        finalDataType = dataTypes[0];
	      } else {
	        // Try convertible dataTypes
	        for (type in responses) {
	          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
	            finalDataType = type;
	            break;
	          }

	          if (!firstDataType) {
	            firstDataType = type;
	          }
	        } // Or just use first one


	        finalDataType = finalDataType || firstDataType;
	      } // If we found a dataType
	      // We add the dataType to the list if needed
	      // and return the corresponding response


	      if (finalDataType) {
	        if (finalDataType !== dataTypes[0]) {
	          dataTypes.unshift(finalDataType);
	        }

	        return responses[finalDataType];
	      }
	    }
	    /* Chain conversions given the request and the original response
	     * Also sets the responseXXX fields on the jqXHR instance
	     */


	    function ajaxConvert(s, response, jqXHR, isSuccess) {
	      var conv2,
	          current,
	          conv,
	          tmp,
	          prev,
	          converters = {},
	          // Work with a copy of dataTypes in case we need to modify it for conversion
	      dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

	      if (dataTypes[1]) {
	        for (conv in s.converters) {
	          converters[conv.toLowerCase()] = s.converters[conv];
	        }
	      }

	      current = dataTypes.shift(); // Convert to each sequential dataType

	      while (current) {
	        if (s.responseFields[current]) {
	          jqXHR[s.responseFields[current]] = response;
	        } // Apply the dataFilter if provided


	        if (!prev && isSuccess && s.dataFilter) {
	          response = s.dataFilter(response, s.dataType);
	        }

	        prev = current;
	        current = dataTypes.shift();

	        if (current) {
	          // There's only work to do if current dataType is non-auto
	          if (current === "*") {
	            current = prev; // Convert response if prev dataType is non-auto and differs from current
	          } else if (prev !== "*" && prev !== current) {
	            // Seek a direct converter
	            conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

	            if (!conv) {
	              for (conv2 in converters) {
	                // If conv2 outputs current
	                tmp = conv2.split(" ");

	                if (tmp[1] === current) {
	                  // If prev can be converted to accepted input
	                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

	                  if (conv) {
	                    // Condense equivalence converters
	                    if (conv === true) {
	                      conv = converters[conv2]; // Otherwise, insert the intermediate dataType
	                    } else if (converters[conv2] !== true) {
	                      current = tmp[0];
	                      dataTypes.unshift(tmp[1]);
	                    }

	                    break;
	                  }
	                }
	              }
	            } // Apply converter (if not an equivalence)


	            if (conv !== true) {
	              // Unless errors are allowed to bubble, catch and return them
	              if (conv && s.throws) {
	                response = conv(response);
	              } else {
	                try {
	                  response = conv(response);
	                } catch (e) {
	                  return {
	                    state: "parsererror",
	                    error: conv ? e : "No conversion from " + prev + " to " + current
	                  };
	                }
	              }
	            }
	          }
	        }
	      }

	      return {
	        state: "success",
	        data: response
	      };
	    }

	    jQuery.extend({
	      // Counter for holding the number of active queries
	      active: 0,
	      // Last-Modified header cache for next request
	      lastModified: {},
	      etag: {},
	      ajaxSettings: {
	        url: location.href,
	        type: "GET",
	        isLocal: rlocalProtocol.test(location.protocol),
	        global: true,
	        processData: true,
	        async: true,
	        contentType: "application/x-www-form-urlencoded; charset=UTF-8",

	        /*
	        timeout: 0,
	        data: null,
	        dataType: null,
	        username: null,
	        password: null,
	        cache: null,
	        throws: false,
	        traditional: false,
	        headers: {},
	        */
	        accepts: {
	          "*": allTypes,
	          text: "text/plain",
	          html: "text/html",
	          xml: "application/xml, text/xml",
	          json: "application/json, text/javascript"
	        },
	        contents: {
	          xml: /\bxml\b/,
	          html: /\bhtml/,
	          json: /\bjson\b/
	        },
	        responseFields: {
	          xml: "responseXML",
	          text: "responseText",
	          json: "responseJSON"
	        },
	        // Data converters
	        // Keys separate source (or catchall "*") and destination types with a single space
	        converters: {
	          // Convert anything to text
	          "* text": String,
	          // Text to html (true = no transformation)
	          "text html": true,
	          // Evaluate text as a json expression
	          "text json": JSON.parse,
	          // Parse text as xml
	          "text xml": jQuery.parseXML
	        },
	        // For options that shouldn't be deep extended:
	        // you can add your own custom options here if
	        // and when you create one that shouldn't be
	        // deep extended (see ajaxExtend)
	        flatOptions: {
	          url: true,
	          context: true
	        }
	      },
	      // Creates a full fledged settings object into target
	      // with both ajaxSettings and settings fields.
	      // If target is omitted, writes into ajaxSettings.
	      ajaxSetup: function (target, settings) {
	        return settings ? // Building a settings object
	        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
	        ajaxExtend(jQuery.ajaxSettings, target);
	      },
	      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
	      ajaxTransport: addToPrefiltersOrTransports(transports),
	      // Main method
	      ajax: function (url, options) {
	        // If url is an object, simulate pre-1.5 signature
	        if (typeof url === "object") {
	          options = url;
	          url = undefined;
	        } // Force options to be an object


	        options = options || {};
	        var transport,
	            // URL without anti-cache param
	        cacheURL,
	            // Response headers
	        responseHeadersString,
	            responseHeaders,
	            // timeout handle
	        timeoutTimer,
	            // Url cleanup var
	        urlAnchor,
	            // Request state (becomes false upon send and true upon completion)
	        completed,
	            // To know if global events are to be dispatched
	        fireGlobals,
	            // Loop variable
	        i,
	            // uncached part of the url
	        uncached,
	            // Create the final options object
	        s = jQuery.ajaxSetup({}, options),
	            // Callbacks context
	        callbackContext = s.context || s,
	            // Context for global events is callbackContext if it is a DOM node or jQuery collection
	        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
	            // Deferreds
	        deferred = jQuery.Deferred(),
	            completeDeferred = jQuery.Callbacks("once memory"),
	            // Status-dependent callbacks
	        statusCode = s.statusCode || {},
	            // Headers (they are sent all at once)
	        requestHeaders = {},
	            requestHeadersNames = {},
	            // Default abort message
	        strAbort = "canceled",
	            // Fake xhr
	        jqXHR = {
	          readyState: 0,
	          // Builds headers hashtable if needed
	          getResponseHeader: function (key) {
	            var match;

	            if (completed) {
	              if (!responseHeaders) {
	                responseHeaders = {};

	                while (match = rheaders.exec(responseHeadersString)) {
	                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
	                }
	              }

	              match = responseHeaders[key.toLowerCase() + " "];
	            }

	            return match == null ? null : match.join(", ");
	          },
	          // Raw string
	          getAllResponseHeaders: function () {
	            return completed ? responseHeadersString : null;
	          },
	          // Caches the header
	          setRequestHeader: function (name, value) {
	            if (completed == null) {
	              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
	              requestHeaders[name] = value;
	            }

	            return this;
	          },
	          // Overrides response content-type header
	          overrideMimeType: function (type) {
	            if (completed == null) {
	              s.mimeType = type;
	            }

	            return this;
	          },
	          // Status-dependent callbacks
	          statusCode: function (map) {
	            var code;

	            if (map) {
	              if (completed) {
	                // Execute the appropriate callbacks
	                jqXHR.always(map[jqXHR.status]);
	              } else {
	                // Lazy-add the new callbacks in a way that preserves old ones
	                for (code in map) {
	                  statusCode[code] = [statusCode[code], map[code]];
	                }
	              }
	            }

	            return this;
	          },
	          // Cancel the request
	          abort: function (statusText) {
	            var finalText = statusText || strAbort;

	            if (transport) {
	              transport.abort(finalText);
	            }

	            done(0, finalText);
	            return this;
	          }
	        }; // Attach deferreds

	        deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
	        // Handle falsy url in the settings object (#10093: consistency with old signature)
	        // We also use the url parameter if available

	        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

	        s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

	        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

	        if (s.crossDomain == null) {
	          urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
	          // IE throws exception on accessing the href property if url is malformed,
	          // e.g. http://example.com:80x/

	          try {
	            urlAnchor.href = s.url; // Support: IE <=8 - 11 only
	            // Anchor's host property isn't correctly set when s.url is relative

	            urlAnchor.href = urlAnchor.href;
	            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
	          } catch (e) {
	            // If there is an error parsing the URL, assume it is crossDomain,
	            // it can be rejected by the transport if it is invalid
	            s.crossDomain = true;
	          }
	        } // Convert data if not already a string


	        if (s.data && s.processData && typeof s.data !== "string") {
	          s.data = jQuery.param(s.data, s.traditional);
	        } // Apply prefilters


	        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

	        if (completed) {
	          return jqXHR;
	        } // We can fire global events as of now if asked to
	        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


	        fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

	        if (fireGlobals && jQuery.active++ === 0) {
	          jQuery.event.trigger("ajaxStart");
	        } // Uppercase the type


	        s.type = s.type.toUpperCase(); // Determine if request has content

	        s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
	        // and/or If-None-Match header later on
	        // Remove hash to simplify url manipulation

	        cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

	        if (!s.hasContent) {
	          // Remember the hash so we can put it back
	          uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

	          if (s.data && (s.processData || typeof s.data === "string")) {
	            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

	            delete s.data;
	          } // Add or update anti-cache param if needed


	          if (s.cache === false) {
	            cacheURL = cacheURL.replace(rantiCache, "$1");
	            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
	          } // Put hash and anti-cache on the URL that will be requested (gh-1732)


	          s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
	        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
	          s.data = s.data.replace(r20, "+");
	        } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


	        if (s.ifModified) {
	          if (jQuery.lastModified[cacheURL]) {
	            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
	          }

	          if (jQuery.etag[cacheURL]) {
	            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
	          }
	        } // Set the correct header, if data is being sent


	        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
	          jqXHR.setRequestHeader("Content-Type", s.contentType);
	        } // Set the Accepts header for the server, depending on the dataType


	        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

	        for (i in s.headers) {
	          jqXHR.setRequestHeader(i, s.headers[i]);
	        } // Allow custom headers/mimetypes and early abort


	        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
	          // Abort if not done already and return
	          return jqXHR.abort();
	        } // Aborting is no longer a cancellation


	        strAbort = "abort"; // Install callbacks on deferreds

	        completeDeferred.add(s.complete);
	        jqXHR.done(s.success);
	        jqXHR.fail(s.error); // Get transport

	        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

	        if (!transport) {
	          done(-1, "No Transport");
	        } else {
	          jqXHR.readyState = 1; // Send global event

	          if (fireGlobals) {
	            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
	          } // If request was aborted inside ajaxSend, stop there


	          if (completed) {
	            return jqXHR;
	          } // Timeout


	          if (s.async && s.timeout > 0) {
	            timeoutTimer = window.setTimeout(function () {
	              jqXHR.abort("timeout");
	            }, s.timeout);
	          }

	          try {
	            completed = false;
	            transport.send(requestHeaders, done);
	          } catch (e) {
	            // Rethrow post-completion exceptions
	            if (completed) {
	              throw e;
	            } // Propagate others as results


	            done(-1, e);
	          }
	        } // Callback for when everything is done


	        function done(status, nativeStatusText, responses, headers) {
	          var isSuccess,
	              success,
	              error,
	              response,
	              modified,
	              statusText = nativeStatusText; // Ignore repeat invocations

	          if (completed) {
	            return;
	          }

	          completed = true; // Clear timeout if it exists

	          if (timeoutTimer) {
	            window.clearTimeout(timeoutTimer);
	          } // Dereference transport for early garbage collection
	          // (no matter how long the jqXHR object will be used)


	          transport = undefined; // Cache response headers

	          responseHeadersString = headers || ""; // Set readyState

	          jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

	          isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

	          if (responses) {
	            response = ajaxHandleResponses(s, jqXHR, responses);
	          } // Use a noop converter for missing script


	          if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
	            s.converters["text script"] = function () {};
	          } // Convert no matter what (that way responseXXX fields are always set)


	          response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

	          if (isSuccess) {
	            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	            if (s.ifModified) {
	              modified = jqXHR.getResponseHeader("Last-Modified");

	              if (modified) {
	                jQuery.lastModified[cacheURL] = modified;
	              }

	              modified = jqXHR.getResponseHeader("etag");

	              if (modified) {
	                jQuery.etag[cacheURL] = modified;
	              }
	            } // if no content


	            if (status === 204 || s.type === "HEAD") {
	              statusText = "nocontent"; // if not modified
	            } else if (status === 304) {
	              statusText = "notmodified"; // If we have data, let's convert it
	            } else {
	              statusText = response.state;
	              success = response.data;
	              error = response.error;
	              isSuccess = !error;
	            }
	          } else {
	            // Extract error from statusText and normalize for non-aborts
	            error = statusText;

	            if (status || !statusText) {
	              statusText = "error";

	              if (status < 0) {
	                status = 0;
	              }
	            }
	          } // Set data for the fake xhr object


	          jqXHR.status = status;
	          jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

	          if (isSuccess) {
	            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
	          } else {
	            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
	          } // Status-dependent callbacks


	          jqXHR.statusCode(statusCode);
	          statusCode = undefined;

	          if (fireGlobals) {
	            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
	          } // Complete


	          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

	          if (fireGlobals) {
	            globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

	            if (! --jQuery.active) {
	              jQuery.event.trigger("ajaxStop");
	            }
	          }
	        }

	        return jqXHR;
	      },
	      getJSON: function (url, data, callback) {
	        return jQuery.get(url, data, callback, "json");
	      },
	      getScript: function (url, callback) {
	        return jQuery.get(url, undefined, callback, "script");
	      }
	    });
	    jQuery.each(["get", "post"], function (_i, method) {
	      jQuery[method] = function (url, data, callback, type) {
	        // Shift arguments if data argument was omitted
	        if (isFunction(data)) {
	          type = type || callback;
	          callback = data;
	          data = undefined;
	        } // The url can be an options object (which then must have .url)


	        return jQuery.ajax(jQuery.extend({
	          url: url,
	          type: method,
	          dataType: type,
	          data: data,
	          success: callback
	        }, jQuery.isPlainObject(url) && url));
	      };
	    });
	    jQuery.ajaxPrefilter(function (s) {
	      var i;

	      for (i in s.headers) {
	        if (i.toLowerCase() === "content-type") {
	          s.contentType = s.headers[i] || "";
	        }
	      }
	    });

	    jQuery._evalUrl = function (url, options, doc) {
	      return jQuery.ajax({
	        url: url,
	        // Make this explicit, since user can override this through ajaxSetup (#11264)
	        type: "GET",
	        dataType: "script",
	        cache: true,
	        async: false,
	        global: false,
	        // Only evaluate the response if it is successful (gh-4126)
	        // dataFilter is not invoked for failure responses, so using it instead
	        // of the default converter is kludgy but it works.
	        converters: {
	          "text script": function () {}
	        },
	        dataFilter: function (response) {
	          jQuery.globalEval(response, options, doc);
	        }
	      });
	    };

	    jQuery.fn.extend({
	      wrapAll: function (html) {
	        var wrap;

	        if (this[0]) {
	          if (isFunction(html)) {
	            html = html.call(this[0]);
	          } // The elements to wrap the target around


	          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

	          if (this[0].parentNode) {
	            wrap.insertBefore(this[0]);
	          }

	          wrap.map(function () {
	            var elem = this;

	            while (elem.firstElementChild) {
	              elem = elem.firstElementChild;
	            }

	            return elem;
	          }).append(this);
	        }

	        return this;
	      },
	      wrapInner: function (html) {
	        if (isFunction(html)) {
	          return this.each(function (i) {
	            jQuery(this).wrapInner(html.call(this, i));
	          });
	        }

	        return this.each(function () {
	          var self = jQuery(this),
	              contents = self.contents();

	          if (contents.length) {
	            contents.wrapAll(html);
	          } else {
	            self.append(html);
	          }
	        });
	      },
	      wrap: function (html) {
	        var htmlIsFunction = isFunction(html);
	        return this.each(function (i) {
	          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
	        });
	      },
	      unwrap: function (selector) {
	        this.parent(selector).not("body").each(function () {
	          jQuery(this).replaceWith(this.childNodes);
	        });
	        return this;
	      }
	    });

	    jQuery.expr.pseudos.hidden = function (elem) {
	      return !jQuery.expr.pseudos.visible(elem);
	    };

	    jQuery.expr.pseudos.visible = function (elem) {
	      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	    };

	    jQuery.ajaxSettings.xhr = function () {
	      try {
	        return new window.XMLHttpRequest();
	      } catch (e) {}
	    };

	    var xhrSuccessStatus = {
	      // File protocol always yields status code 0, assume 200
	      0: 200,
	      // Support: IE <=9 only
	      // #1450: sometimes IE returns 1223 when it should be 204
	      1223: 204
	    },
	        xhrSupported = jQuery.ajaxSettings.xhr();
	    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	    support.ajax = xhrSupported = !!xhrSupported;
	    jQuery.ajaxTransport(function (options) {
	      var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

	      if (support.cors || xhrSupported && !options.crossDomain) {
	        return {
	          send: function (headers, complete) {
	            var i,
	                xhr = options.xhr();
	            xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

	            if (options.xhrFields) {
	              for (i in options.xhrFields) {
	                xhr[i] = options.xhrFields[i];
	              }
	            } // Override mime type if needed


	            if (options.mimeType && xhr.overrideMimeType) {
	              xhr.overrideMimeType(options.mimeType);
	            } // X-Requested-With header
	            // For cross-domain requests, seeing as conditions for a preflight are
	            // akin to a jigsaw puzzle, we simply never set it to be sure.
	            // (it can always be set on a per-request basis or even using ajaxSetup)
	            // For same-domain requests, won't change header if already provided.


	            if (!options.crossDomain && !headers["X-Requested-With"]) {
	              headers["X-Requested-With"] = "XMLHttpRequest";
	            } // Set headers


	            for (i in headers) {
	              xhr.setRequestHeader(i, headers[i]);
	            } // Callback


	            callback = function (type) {
	              return function () {
	                if (callback) {
	                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

	                  if (type === "abort") {
	                    xhr.abort();
	                  } else if (type === "error") {
	                    // Support: IE <=9 only
	                    // On a manual native abort, IE9 throws
	                    // errors on any property access that is not readyState
	                    if (typeof xhr.status !== "number") {
	                      complete(0, "error");
	                    } else {
	                      complete( // File: protocol always yields status 0; see #8605, #14207
	                      xhr.status, xhr.statusText);
	                    }
	                  } else {
	                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
	                    // IE9 has no XHR2 but throws on binary (trac-11426)
	                    // For XHR2 non-text, let the caller handle it (gh-2498)
	                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
	                      binary: xhr.response
	                    } : {
	                      text: xhr.responseText
	                    }, xhr.getAllResponseHeaders());
	                  }
	                }
	              };
	            }; // Listen to events


	            xhr.onload = callback();
	            errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
	            // Use onreadystatechange to replace onabort
	            // to handle uncaught aborts

	            if (xhr.onabort !== undefined) {
	              xhr.onabort = errorCallback;
	            } else {
	              xhr.onreadystatechange = function () {
	                // Check readyState before timeout as it changes
	                if (xhr.readyState === 4) {
	                  // Allow onerror to be called first,
	                  // but that will not handle a native abort
	                  // Also, save errorCallback to a variable
	                  // as xhr.onerror cannot be accessed
	                  window.setTimeout(function () {
	                    if (callback) {
	                      errorCallback();
	                    }
	                  });
	                }
	              };
	            } // Create the abort callback


	            callback = callback("abort");

	            try {
	              // Do send the request (this may raise an exception)
	              xhr.send(options.hasContent && options.data || null);
	            } catch (e) {
	              // #14683: Only rethrow if this hasn't been notified as an error yet
	              if (callback) {
	                throw e;
	              }
	            }
	          },
	          abort: function () {
	            if (callback) {
	              callback();
	            }
	          }
	        };
	      }
	    }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

	    jQuery.ajaxPrefilter(function (s) {
	      if (s.crossDomain) {
	        s.contents.script = false;
	      }
	    }); // Install script dataType

	    jQuery.ajaxSetup({
	      accepts: {
	        script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
	      },
	      contents: {
	        script: /\b(?:java|ecma)script\b/
	      },
	      converters: {
	        "text script": function (text) {
	          jQuery.globalEval(text);
	          return text;
	        }
	      }
	    }); // Handle cache's special case and crossDomain

	    jQuery.ajaxPrefilter("script", function (s) {
	      if (s.cache === undefined) {
	        s.cache = false;
	      }

	      if (s.crossDomain) {
	        s.type = "GET";
	      }
	    }); // Bind script tag hack transport

	    jQuery.ajaxTransport("script", function (s) {
	      // This transport only deals with cross domain or forced-by-attrs requests
	      if (s.crossDomain || s.scriptAttrs) {
	        var script, callback;
	        return {
	          send: function (_, complete) {
	            script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
	              charset: s.scriptCharset,
	              src: s.url
	            }).on("load error", callback = function (evt) {
	              script.remove();
	              callback = null;

	              if (evt) {
	                complete(evt.type === "error" ? 404 : 200, evt.type);
	              }
	            }); // Use native DOM manipulation to avoid our domManip AJAX trickery

	            document.head.appendChild(script[0]);
	          },
	          abort: function () {
	            if (callback) {
	              callback();
	            }
	          }
	        };
	      }
	    });
	    var oldCallbacks = [],
	        rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

	    jQuery.ajaxSetup({
	      jsonp: "callback",
	      jsonpCallback: function () {
	        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
	        this[callback] = true;
	        return callback;
	      }
	    }); // Detect, normalize options and install callbacks for jsonp requests

	    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
	      var callbackName,
	          overwritten,
	          responseContainer,
	          jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

	      if (jsonProp || s.dataTypes[0] === "jsonp") {
	        // Get callback name, remembering preexisting value associated with it
	        callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

	        if (jsonProp) {
	          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
	        } else if (s.jsonp !== false) {
	          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
	        } // Use data converter to retrieve json after script execution


	        s.converters["script json"] = function () {
	          if (!responseContainer) {
	            jQuery.error(callbackName + " was not called");
	          }

	          return responseContainer[0];
	        }; // Force json dataType


	        s.dataTypes[0] = "json"; // Install callback

	        overwritten = window[callbackName];

	        window[callbackName] = function () {
	          responseContainer = arguments;
	        }; // Clean-up function (fires after converters)


	        jqXHR.always(function () {
	          // If previous value didn't exist - remove it
	          if (overwritten === undefined) {
	            jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
	          } else {
	            window[callbackName] = overwritten;
	          } // Save back as free


	          if (s[callbackName]) {
	            // Make sure that re-using the options doesn't screw things around
	            s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

	            oldCallbacks.push(callbackName);
	          } // Call if it was a function and we have a response


	          if (responseContainer && isFunction(overwritten)) {
	            overwritten(responseContainer[0]);
	          }

	          responseContainer = overwritten = undefined;
	        }); // Delegate to script

	        return "script";
	      }
	    }); // Support: Safari 8 only
	    // In Safari 8 documents created via document.implementation.createHTMLDocument
	    // collapse sibling forms: the second one becomes a child of the first one.
	    // Because of that, this security measure has to be disabled in Safari 8.
	    // https://bugs.webkit.org/show_bug.cgi?id=137337

	    support.createHTMLDocument = function () {
	      var body = document.implementation.createHTMLDocument("").body;
	      body.innerHTML = "<form></form><form></form>";
	      return body.childNodes.length === 2;
	    }(); // Argument "data" should be string of html
	    // context (optional): If specified, the fragment will be created in this context,
	    // defaults to document
	    // keepScripts (optional): If true, will include scripts passed in the html string


	    jQuery.parseHTML = function (data, context, keepScripts) {
	      if (typeof data !== "string") {
	        return [];
	      }

	      if (typeof context === "boolean") {
	        keepScripts = context;
	        context = false;
	      }

	      var base, parsed, scripts;

	      if (!context) {
	        // Stop scripts or inline event handlers from being executed immediately
	        // by using document.implementation
	        if (support.createHTMLDocument) {
	          context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
	          // so any parsed elements with URLs
	          // are based on the document's URL (gh-2965)

	          base = context.createElement("base");
	          base.href = document.location.href;
	          context.head.appendChild(base);
	        } else {
	          context = document;
	        }
	      }

	      parsed = rsingleTag.exec(data);
	      scripts = !keepScripts && []; // Single tag

	      if (parsed) {
	        return [context.createElement(parsed[1])];
	      }

	      parsed = buildFragment([data], context, scripts);

	      if (scripts && scripts.length) {
	        jQuery(scripts).remove();
	      }

	      return jQuery.merge([], parsed.childNodes);
	    };
	    /**
	     * Load a url into a page
	     */


	    jQuery.fn.load = function (url, params, callback) {
	      var selector,
	          type,
	          response,
	          self = this,
	          off = url.indexOf(" ");

	      if (off > -1) {
	        selector = stripAndCollapse(url.slice(off));
	        url = url.slice(0, off);
	      } // If it's a function


	      if (isFunction(params)) {
	        // We assume that it's the callback
	        callback = params;
	        params = undefined; // Otherwise, build a param string
	      } else if (params && typeof params === "object") {
	        type = "POST";
	      } // If we have elements to modify, make the request


	      if (self.length > 0) {
	        jQuery.ajax({
	          url: url,
	          // If "type" variable is undefined, then "GET" method will be used.
	          // Make value of this field explicit since
	          // user can override it through ajaxSetup method
	          type: type || "GET",
	          dataType: "html",
	          data: params
	        }).done(function (responseText) {
	          // Save response for use in complete callback
	          response = arguments;
	          self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
	          // Exclude scripts to avoid IE 'Permission Denied' errors
	          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
	          responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
	          // but they are ignored because response was set above.
	          // If it fails, this function gets "jqXHR", "status", "error"
	        }).always(callback && function (jqXHR, status) {
	          self.each(function () {
	            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
	          });
	        });
	      }

	      return this;
	    };

	    jQuery.expr.pseudos.animated = function (elem) {
	      return jQuery.grep(jQuery.timers, function (fn) {
	        return elem === fn.elem;
	      }).length;
	    };

	    jQuery.offset = {
	      setOffset: function (elem, options, i) {
	        var curPosition,
	            curLeft,
	            curCSSTop,
	            curTop,
	            curOffset,
	            curCSSLeft,
	            calculatePosition,
	            position = jQuery.css(elem, "position"),
	            curElem = jQuery(elem),
	            props = {}; // Set position first, in-case top/left are set even on static elem

	        if (position === "static") {
	          elem.style.position = "relative";
	        }

	        curOffset = curElem.offset();
	        curCSSTop = jQuery.css(elem, "top");
	        curCSSLeft = jQuery.css(elem, "left");
	        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
	        // top or left is auto and position is either absolute or fixed

	        if (calculatePosition) {
	          curPosition = curElem.position();
	          curTop = curPosition.top;
	          curLeft = curPosition.left;
	        } else {
	          curTop = parseFloat(curCSSTop) || 0;
	          curLeft = parseFloat(curCSSLeft) || 0;
	        }

	        if (isFunction(options)) {
	          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
	          options = options.call(elem, i, jQuery.extend({}, curOffset));
	        }

	        if (options.top != null) {
	          props.top = options.top - curOffset.top + curTop;
	        }

	        if (options.left != null) {
	          props.left = options.left - curOffset.left + curLeft;
	        }

	        if ("using" in options) {
	          options.using.call(elem, props);
	        } else {
	          if (typeof props.top === "number") {
	            props.top += "px";
	          }

	          if (typeof props.left === "number") {
	            props.left += "px";
	          }

	          curElem.css(props);
	        }
	      }
	    };
	    jQuery.fn.extend({
	      // offset() relates an element's border box to the document origin
	      offset: function (options) {
	        // Preserve chaining for setter
	        if (arguments.length) {
	          return options === undefined ? this : this.each(function (i) {
	            jQuery.offset.setOffset(this, options, i);
	          });
	        }

	        var rect,
	            win,
	            elem = this[0];

	        if (!elem) {
	          return;
	        } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
	        // Support: IE <=11 only
	        // Running getBoundingClientRect on a
	        // disconnected node in IE throws an error


	        if (!elem.getClientRects().length) {
	          return {
	            top: 0,
	            left: 0
	          };
	        } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


	        rect = elem.getBoundingClientRect();
	        win = elem.ownerDocument.defaultView;
	        return {
	          top: rect.top + win.pageYOffset,
	          left: rect.left + win.pageXOffset
	        };
	      },
	      // position() relates an element's margin box to its offset parent's padding box
	      // This corresponds to the behavior of CSS absolute positioning
	      position: function () {
	        if (!this[0]) {
	          return;
	        }

	        var offsetParent,
	            offset,
	            doc,
	            elem = this[0],
	            parentOffset = {
	          top: 0,
	          left: 0
	        }; // position:fixed elements are offset from the viewport, which itself always has zero offset

	        if (jQuery.css(elem, "position") === "fixed") {
	          // Assume position:fixed implies availability of getBoundingClientRect
	          offset = elem.getBoundingClientRect();
	        } else {
	          offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
	          // when a statically positioned element is identified

	          doc = elem.ownerDocument;
	          offsetParent = elem.offsetParent || doc.documentElement;

	          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
	            offsetParent = offsetParent.parentNode;
	          }

	          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
	            // Incorporate borders into its offset, since they are outside its content origin
	            parentOffset = jQuery(offsetParent).offset();
	            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
	            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
	          }
	        } // Subtract parent offsets and element margins


	        return {
	          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
	          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
	        };
	      },
	      // This method will return documentElement in the following cases:
	      // 1) For the element inside the iframe without offsetParent, this method will return
	      //    documentElement of the parent window
	      // 2) For the hidden or detached element
	      // 3) For body or html element, i.e. in case of the html node - it will return itself
	      //
	      // but those exceptions were never presented as a real life use-cases
	      // and might be considered as more preferable results.
	      //
	      // This logic, however, is not guaranteed and can change at any point in the future
	      offsetParent: function () {
	        return this.map(function () {
	          var offsetParent = this.offsetParent;

	          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
	            offsetParent = offsetParent.offsetParent;
	          }

	          return offsetParent || documentElement;
	        });
	      }
	    }); // Create scrollLeft and scrollTop methods

	    jQuery.each({
	      scrollLeft: "pageXOffset",
	      scrollTop: "pageYOffset"
	    }, function (method, prop) {
	      var top = "pageYOffset" === prop;

	      jQuery.fn[method] = function (val) {
	        return access(this, function (elem, method, val) {
	          // Coalesce documents and windows
	          var win;

	          if (isWindow(elem)) {
	            win = elem;
	          } else if (elem.nodeType === 9) {
	            win = elem.defaultView;
	          }

	          if (val === undefined) {
	            return win ? win[prop] : elem[method];
	          }

	          if (win) {
	            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
	          } else {
	            elem[method] = val;
	          }
	        }, method, val, arguments.length);
	      };
	    }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
	    // Add the top/left cssHooks using jQuery.fn.position
	    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	    // getComputedStyle returns percent when specified for top/left/bottom/right;
	    // rather than make the css module depend on the offset module, just check for it here

	    jQuery.each(["top", "left"], function (_i, prop) {
	      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
	        if (computed) {
	          computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

	          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
	        }
	      });
	    }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

	    jQuery.each({
	      Height: "height",
	      Width: "width"
	    }, function (name, type) {
	      jQuery.each({
	        padding: "inner" + name,
	        content: type,
	        "": "outer" + name
	      }, function (defaultExtra, funcName) {
	        // Margin is only for outerHeight, outerWidth
	        jQuery.fn[funcName] = function (margin, value) {
	          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
	              extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
	          return access(this, function (elem, type, value) {
	            var doc;

	            if (isWindow(elem)) {
	              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
	              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
	            } // Get document width or height


	            if (elem.nodeType === 9) {
	              doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
	              // whichever is greatest

	              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
	            }

	            return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
	            jQuery.css(elem, type, extra) : // Set width or height on the element
	            jQuery.style(elem, type, value, extra);
	          }, type, chainable ? margin : undefined, chainable);
	        };
	      });
	    });
	    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
	      jQuery.fn[type] = function (fn) {
	        return this.on(type, fn);
	      };
	    });
	    jQuery.fn.extend({
	      bind: function (types, data, fn) {
	        return this.on(types, null, data, fn);
	      },
	      unbind: function (types, fn) {
	        return this.off(types, null, fn);
	      },
	      delegate: function (selector, types, data, fn) {
	        return this.on(types, selector, data, fn);
	      },
	      undelegate: function (selector, types, fn) {
	        // ( namespace ) or ( selector, types [, fn] )
	        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
	      },
	      hover: function (fnOver, fnOut) {
	        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
	      }
	    });
	    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
	      // Handle event binding
	      jQuery.fn[name] = function (data, fn) {
	        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
	      };
	    }); // Support: Android <=4.0 only
	    // Make sure we trim BOM and NBSP

	    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
	    // arguments.
	    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	    // However, it is not slated for removal any time soon

	    jQuery.proxy = function (fn, context) {
	      var tmp, args, proxy;

	      if (typeof context === "string") {
	        tmp = fn[context];
	        context = fn;
	        fn = tmp;
	      } // Quick check to determine if target is callable, in the spec
	      // this throws a TypeError, but we will just return undefined.


	      if (!isFunction(fn)) {
	        return undefined;
	      } // Simulated bind


	      args = slice.call(arguments, 2);

	      proxy = function () {
	        return fn.apply(context || this, args.concat(slice.call(arguments)));
	      }; // Set the guid of unique handler to the same of original handler, so it can be removed


	      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	      return proxy;
	    };

	    jQuery.holdReady = function (hold) {
	      if (hold) {
	        jQuery.readyWait++;
	      } else {
	        jQuery.ready(true);
	      }
	    };

	    jQuery.isArray = Array.isArray;
	    jQuery.parseJSON = JSON.parse;
	    jQuery.nodeName = nodeName;
	    jQuery.isFunction = isFunction;
	    jQuery.isWindow = isWindow;
	    jQuery.camelCase = camelCase;
	    jQuery.type = toType;
	    jQuery.now = Date.now;

	    jQuery.isNumeric = function (obj) {
	      // As of jQuery 3.0, isNumeric is limited to
	      // strings and numbers (primitives or objects)
	      // that can be coerced to finite numbers (gh-2662)
	      var type = jQuery.type(obj);
	      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
	      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	      // subtraction forces infinities to NaN
	      !isNaN(obj - parseFloat(obj));
	    };

	    jQuery.trim = function (text) {
	      return text == null ? "" : (text + "").replace(rtrim, "");
	    }; // Register as a named AMD module, since jQuery can be concatenated with other

	    var // Map over jQuery in case of overwrite
	    _jQuery = window.jQuery,
	        // Map over the $ in case of overwrite
	    _$ = window.$;

	    jQuery.noConflict = function (deep) {
	      if (window.$ === jQuery) {
	        window.$ = _$;
	      }

	      if (deep && window.jQuery === jQuery) {
	        window.jQuery = _jQuery;
	      }

	      return jQuery;
	    }; // Expose jQuery and $ identifiers, even in AMD
	    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	    // and CommonJS for browser emulators (#13566)


	    if (typeof noGlobal === "undefined") {
	      window.jQuery = window.$ = jQuery;
	    }

	    return jQuery;
	  });
	});

	return jquery3_5_1;

}());

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianF1ZXJ5LTMuNS4xLmpzIiwic291cmNlcyI6WyJzcmMvanMvanF1ZXJ5LTMuNS4xLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjUuMVxyXG4gKiBodHRwczovL2pxdWVyeS5jb20vXHJcbiAqXHJcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xyXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cclxuICpcclxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcclxuICAgIC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXHJcbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxyXG4gICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXHJcbiAgICAvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxyXG4gICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xyXG4gICAgLy8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50XHJcbiAgICAgID8gZmFjdG9yeShnbG9iYWwsIHRydWUpXHJcbiAgICAgIDogZnVuY3Rpb24gKHcpIHtcclxuICAgICAgICAgIGlmICghdy5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZhY3Rvcnkodyk7XHJcbiAgICAgICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgZmFjdG9yeShnbG9iYWwpO1xyXG4gIH1cclxuXHJcbiAgLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcclxufSkodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICh3aW5kb3csIG5vR2xvYmFsKSB7XHJcbiAgLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXHJcbiAgLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXHJcbiAgLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cclxuICAvLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIGFyciA9IFtdO1xyXG5cclxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XHJcblxyXG4gIHZhciBzbGljZSA9IGFyci5zbGljZTtcclxuXHJcbiAgdmFyIGZsYXQgPSBhcnIuZmxhdFxyXG4gICAgPyBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyLmZsYXQuY2FsbChhcnJheSk7XHJcbiAgICAgIH1cclxuICAgIDogZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5jb25jYXQuYXBwbHkoW10sIGFycmF5KTtcclxuICAgICAgfTtcclxuXHJcbiAgdmFyIHB1c2ggPSBhcnIucHVzaDtcclxuXHJcbiAgdmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcclxuXHJcbiAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcclxuXHJcbiAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcclxuXHJcbiAgdmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG4gIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xyXG5cclxuICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoT2JqZWN0KTtcclxuXHJcbiAgdmFyIHN1cHBvcnQgPSB7fTtcclxuXHJcbiAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xyXG4gICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxyXG4gICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXHJcbiAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xyXG4gIH07XHJcblxyXG4gIHZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcclxuICB9O1xyXG5cclxuICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcblxyXG4gIHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xyXG4gICAgdHlwZTogdHJ1ZSxcclxuICAgIHNyYzogdHJ1ZSxcclxuICAgIG5vbmNlOiB0cnVlLFxyXG4gICAgbm9Nb2R1bGU6IHRydWUsXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gRE9NRXZhbChjb2RlLCBub2RlLCBkb2MpIHtcclxuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgdmFsLFxyXG4gICAgICBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuXHJcbiAgICBzY3JpcHQudGV4dCA9IGNvZGU7XHJcbiAgICBpZiAobm9kZSkge1xyXG4gICAgICBmb3IgKGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcykge1xyXG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xyXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXHJcbiAgICAgICAgLy8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xyXG4gICAgICAgIC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcclxuICAgICAgICAvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xyXG4gICAgICAgIC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2ZcclxuICAgICAgICAvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcclxuICAgICAgICAvLyB2aWEgYW4gb2JqZWN0LlxyXG4gICAgICAgIHZhbCA9IG5vZGVbaV0gfHwgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKGkpKTtcclxuICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGksIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvVHlwZShvYmopIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gb2JqICsgXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICA/IGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiXHJcbiAgICAgIDogdHlwZW9mIG9iajtcclxuICB9XHJcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xyXG4gIC8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXHJcbiAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcclxuXHJcbiAgdmFyIHZlcnNpb24gPSBcIjMuNS4xXCIsXHJcbiAgICAvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxyXG4gICAgalF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xyXG4gICAgICAvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxyXG4gICAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcclxuICAgIH07XHJcblxyXG4gIGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXHJcbiAgICBqcXVlcnk6IHZlcnNpb24sXHJcblxyXG4gICAgY29uc3RydWN0b3I6IGpRdWVyeSxcclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcclxuICAgIGxlbmd0aDogMCxcclxuXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXHJcbiAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxyXG4gICAgZ2V0OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcclxuICAgICAgaWYgKG51bSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcclxuICAgICAgcmV0dXJuIG51bSA8IDAgPyB0aGlzW251bSArIHRoaXMubGVuZ3RoXSA6IHRoaXNbbnVtXTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xyXG4gICAgLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXHJcbiAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uIChlbGVtcykge1xyXG4gICAgICAvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxyXG4gICAgICB2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMpO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcclxuICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cclxuICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4galF1ZXJ5LmVhY2godGhpcywgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXHJcbiAgICAgICAgalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWxlbSwgaSwgZWxlbSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2xpY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lcSgwKTtcclxuICAgIH0sXHJcblxyXG4gICAgbGFzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGV2ZW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxyXG4gICAgICAgIGpRdWVyeS5ncmVwKHRoaXMsIGZ1bmN0aW9uIChfZWxlbSwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIChpICsgMSkgJSAyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9kZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXHJcbiAgICAgICAgalF1ZXJ5LmdyZXAodGhpcywgZnVuY3Rpb24gKF9lbGVtLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gaSAlIDI7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgZXE6IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICBqID0gK2kgKyAoaSA8IDAgPyBsZW4gOiAwKTtcclxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGogPj0gMCAmJiBqIDwgbGVuID8gW3RoaXNbal1dIDogW10pO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cclxuICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxyXG4gICAgcHVzaDogcHVzaCxcclxuICAgIHNvcnQ6IGFyci5zb3J0LFxyXG4gICAgc3BsaWNlOiBhcnIuc3BsaWNlLFxyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG9wdGlvbnMsXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHNyYyxcclxuICAgICAgY29weSxcclxuICAgICAgY29weUlzQXJyYXksXHJcbiAgICAgIGNsb25lLFxyXG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICBkZWVwID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGRlZXAgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xyXG4gICAgICB0YXJnZXQgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgIGlmIChpID09PSBsZW5ndGgpIHtcclxuICAgICAgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgaS0tO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcclxuICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xyXG5cclxuICAgICAgICAgIC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cclxuICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuICAgICAgICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgZGVlcCAmJlxyXG4gICAgICAgICAgICBjb3B5ICYmXHJcbiAgICAgICAgICAgIChqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KHNyYykpIHtcclxuICAgICAgICAgICAgICBjbG9uZSA9IFtdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSkge1xyXG4gICAgICAgICAgICAgIGNsb25lID0ge307XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY2xvbmUgPSBzcmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBqUXVlcnkuZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcclxuICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAodmVyc2lvbiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcclxuXHJcbiAgICAvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxyXG4gICAgaXNSZWFkeTogdHJ1ZSxcclxuXHJcbiAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgIH0sXHJcblxyXG4gICAgbm9vcDogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcHJvdG8sIEN0b3I7XHJcblxyXG4gICAgICAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcclxuICAgICAgLy8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXHJcbiAgICAgIGlmICghb2JqIHx8IHRvU3RyaW5nLmNhbGwob2JqKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJvdG8gPSBnZXRQcm90byhvYmopO1xyXG5cclxuICAgICAgLy8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxyXG4gICAgICBpZiAoIXByb3RvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXHJcbiAgICAgIEN0b3IgPSBoYXNPd24uY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgZm5Ub1N0cmluZy5jYWxsKEN0b3IpID09PSBPYmplY3RGdW5jdGlvblN0cmluZ1xyXG4gICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBuYW1lO1xyXG5cclxuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxyXG4gICAgLy8gaWYgbm90IHNwZWNpZmllZC5cclxuICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uIChjb2RlLCBvcHRpb25zLCBkb2MpIHtcclxuICAgICAgRE9NRXZhbChjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jKTtcclxuICAgIH0sXHJcblxyXG4gICAgZWFjaDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcclxuICAgICAgdmFyIGxlbmd0aCxcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgbWFrZUFycmF5OiBmdW5jdGlvbiAoYXJyLCByZXN1bHRzKSB7XHJcbiAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xyXG5cclxuICAgICAgaWYgKGFyciAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKE9iamVjdChhcnIpKSkge1xyXG4gICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/IFthcnJdIDogYXJyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHVzaC5jYWxsKHJldCwgYXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGluQXJyYXk6IGZ1bmN0aW9uIChlbGVtLCBhcnIsIGkpIHtcclxuICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoYXJyLCBlbGVtLCBpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XHJcbiAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICBtZXJnZTogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxyXG4gICAgICAgIGogPSAwLFxyXG4gICAgICAgIGkgPSBmaXJzdC5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZmlyc3QubGVuZ3RoID0gaTtcclxuXHJcbiAgICAgIHJldHVybiBmaXJzdDtcclxuICAgIH0sXHJcblxyXG4gICAgZ3JlcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0KSB7XHJcbiAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXHJcbiAgICAgICAgbWF0Y2hlcyA9IFtdLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcclxuICAgICAgICBjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XHJcblxyXG4gICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXHJcbiAgICAgIC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXHJcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soZWxlbXNbaV0sIGkpO1xyXG4gICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XHJcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZWxlbXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgbWFwOiBmdW5jdGlvbiAoZWxlbXMsIGNhbGxiYWNrLCBhcmcpIHtcclxuICAgICAgdmFyIGxlbmd0aCxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBpID0gMCxcclxuICAgICAgICByZXQgPSBbXTtcclxuXHJcbiAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXHJcbiAgICAgIGlmIChpc0FycmF5TGlrZShlbGVtcykpIHtcclxuICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSBpbiBlbGVtcykge1xyXG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXHJcbiAgICAgIHJldHVybiBmbGF0KHJldCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xyXG4gICAgZ3VpZDogMSxcclxuXHJcbiAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcclxuICAgIC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXHJcbiAgICBzdXBwb3J0OiBzdXBwb3J0LFxyXG4gIH0pO1xyXG5cclxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xyXG4gIH1cclxuXHJcbiAgLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXHJcbiAgalF1ZXJ5LmVhY2goXHJcbiAgICBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoXHJcbiAgICAgIFwiIFwiXHJcbiAgICApLFxyXG4gICAgZnVuY3Rpb24gKF9pLCBuYW1lKSB7XHJcbiAgICAgIGNsYXNzMnR5cGVbXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcclxuICAgIC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcclxuICAgIC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcclxuICAgIC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xyXG4gICAgLy8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxyXG4gICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXHJcbiAgICAgIHR5cGUgPSB0b1R5cGUob2JqKTtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopIHx8IGlzV2luZG93KG9iaikpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIHR5cGUgPT09IFwiYXJyYXlcIiB8fFxyXG4gICAgICBsZW5ndGggPT09IDAgfHxcclxuICAgICAgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiBsZW5ndGggLSAxIGluIG9iailcclxuICAgICk7XHJcbiAgfVxyXG4gIHZhciBTaXp6bGUgPVxyXG4gICAgLyohXHJcbiAgICAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcclxuICAgICAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xyXG4gICAgICpcclxuICAgICAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcclxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gICAgICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xyXG4gICAgICpcclxuICAgICAqIERhdGU6IDIwMjAtMDMtMTRcclxuICAgICAqL1xyXG4gICAgKGZ1bmN0aW9uICh3aW5kb3cpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgc3VwcG9ydCxcclxuICAgICAgICBFeHByLFxyXG4gICAgICAgIGdldFRleHQsXHJcbiAgICAgICAgaXNYTUwsXHJcbiAgICAgICAgdG9rZW5pemUsXHJcbiAgICAgICAgY29tcGlsZSxcclxuICAgICAgICBzZWxlY3QsXHJcbiAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCxcclxuICAgICAgICBzb3J0SW5wdXQsXHJcbiAgICAgICAgaGFzRHVwbGljYXRlLFxyXG4gICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcclxuICAgICAgICBzZXREb2N1bWVudCxcclxuICAgICAgICBkb2N1bWVudCxcclxuICAgICAgICBkb2NFbGVtLFxyXG4gICAgICAgIGRvY3VtZW50SXNIVE1MLFxyXG4gICAgICAgIHJidWdneVFTQSxcclxuICAgICAgICByYnVnZ3lNYXRjaGVzLFxyXG4gICAgICAgIG1hdGNoZXMsXHJcbiAgICAgICAgY29udGFpbnMsXHJcbiAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxyXG4gICAgICAgIGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXHJcbiAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxyXG4gICAgICAgIGRpcnJ1bnMgPSAwLFxyXG4gICAgICAgIGRvbmUgPSAwLFxyXG4gICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBJbnN0YW5jZSBtZXRob2RzXHJcbiAgICAgICAgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHksXHJcbiAgICAgICAgYXJyID0gW10sXHJcbiAgICAgICAgcG9wID0gYXJyLnBvcCxcclxuICAgICAgICBwdXNoTmF0aXZlID0gYXJyLnB1c2gsXHJcbiAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxyXG4gICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxyXG4gICAgICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcclxuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKGxpc3QsIGVsZW0pIHtcclxuICAgICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvb2xlYW5zID1cclxuICAgICAgICAgIFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcclxuICAgICAgICAgIFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxyXG4gICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcclxuICAgICAgICB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxyXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cclxuICAgICAgICBpZGVudGlmaWVyID1cclxuICAgICAgICAgIFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArXHJcbiAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgIFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXHJcbiAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXHJcbiAgICAgICAgYXR0cmlidXRlcyA9XHJcbiAgICAgICAgICBcIlxcXFxbXCIgK1xyXG4gICAgICAgICAgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICBcIiooXCIgK1xyXG4gICAgICAgICAgaWRlbnRpZmllciArXHJcbiAgICAgICAgICBcIikoPzpcIiArXHJcbiAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgIC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXHJcbiAgICAgICAgICBcIiooWypeJHwhfl0/PSlcIiArXHJcbiAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxyXG4gICAgICAgICAgLy8gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxyXG4gICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArXHJcbiAgICAgICAgICBpZGVudGlmaWVyICtcclxuICAgICAgICAgIFwiKSl8KVwiICtcclxuICAgICAgICAgIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgXCIqXFxcXF1cIixcclxuICAgICAgICBwc2V1ZG9zID1cclxuICAgICAgICAgIFwiOihcIiArXHJcbiAgICAgICAgICBpZGVudGlmaWVyICtcclxuICAgICAgICAgIFwiKSg/OlxcXFwoKFwiICtcclxuICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XHJcbiAgICAgICAgICAvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcclxuICAgICAgICAgIFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xyXG4gICAgICAgICAgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXHJcbiAgICAgICAgICBcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzICtcclxuICAgICAgICAgIFwiKSopfFwiICtcclxuICAgICAgICAgIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcclxuICAgICAgICAgIFwiLipcIiArXHJcbiAgICAgICAgICBcIilcXFxcKXwpXCIsXHJcbiAgICAgICAgLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxyXG4gICAgICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCh3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiKSxcclxuICAgICAgICBydHJpbSA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxyXG4gICAgICAgICAgXCJnXCJcclxuICAgICAgICApLFxyXG4gICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcclxuICAgICAgICByY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiXHJcbiAgICAgICAgKSxcclxuICAgICAgICByZGVzY2VuZCA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwifD5cIiksXHJcbiAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAocHNldWRvcyksXHJcbiAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiKSxcclxuICAgICAgICBtYXRjaEV4cHIgPSB7XHJcbiAgICAgICAgICBJRDogbmV3IFJlZ0V4cChcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiKSxcclxuICAgICAgICAgIENMQVNTOiBuZXcgUmVnRXhwKFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiKSxcclxuICAgICAgICAgIFRBRzogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcclxuICAgICAgICAgIEFUVFI6IG5ldyBSZWdFeHAoXCJeXCIgKyBhdHRyaWJ1dGVzKSxcclxuICAgICAgICAgIFBTRVVETzogbmV3IFJlZ0V4cChcIl5cIiArIHBzZXVkb3MpLFxyXG4gICAgICAgICAgQ0hJTEQ6IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXHJcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICAgICAgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArXHJcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICAgICAgXCIqKD86KFsrLV18KVwiICtcclxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICBcIiooXFxcXGQrKXwpKVwiICtcclxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICBcIipcXFxcKXwpXCIsXHJcbiAgICAgICAgICAgIFwiaVwiXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXHJcblxyXG4gICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXHJcbiAgICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXHJcbiAgICAgICAgICBuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgIFwiXlwiICtcclxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xyXG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArXHJcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICAgICAgXCIqXFxcXCl8KSg/PVteLV18JClcIixcclxuICAgICAgICAgICAgXCJpXCJcclxuICAgICAgICAgICksXHJcbiAgICAgICAgfSxcclxuICAgICAgICByaHRtbCA9IC9IVE1MJC9pLFxyXG4gICAgICAgIHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxyXG4gICAgICAgIHJoZWFkZXIgPSAvXmhcXGQkL2ksXHJcbiAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXHJcbiAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXHJcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxyXG4gICAgICAgIHJzaWJsaW5nID0gL1srfl0vLFxyXG4gICAgICAgIC8vIENTUyBlc2NhcGVzXHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xyXG4gICAgICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIixcclxuICAgICAgICAgIFwiZ1wiXHJcbiAgICAgICAgKSxcclxuICAgICAgICBmdW5lc2NhcGUgPSBmdW5jdGlvbiAoZXNjYXBlLCBub25IZXgpIHtcclxuICAgICAgICAgIHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKDEpIC0gMHgxMDAwMDtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbm9uSGV4XHJcbiAgICAgICAgICAgID8gLy8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgbm9uSGV4XHJcbiAgICAgICAgICAgIDogLy8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExK1xyXG4gICAgICAgICAgICAvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcclxuICAgICAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcclxuICAgICAgICAgICAgaGlnaCA8IDBcclxuICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKVxyXG4gICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgICAgICAgICAoaGlnaCA+PiAxMCkgfCAweGQ4MDAsXHJcbiAgICAgICAgICAgICAgICAoaGlnaCAmIDB4M2ZmKSB8IDB4ZGMwMFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxyXG4gICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xyXG4gICAgICAgIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcclxuICAgICAgICBmY3NzZXNjYXBlID0gZnVuY3Rpb24gKGNoLCBhc0NvZGVQb2ludCkge1xyXG4gICAgICAgICAgaWYgKGFzQ29kZVBvaW50KSB7XHJcbiAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxyXG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFwwXCIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgY2guc2xpY2UoMCwgLTEpICtcclxuICAgICAgICAgICAgICBcIlxcXFxcIiArXHJcbiAgICAgICAgICAgICAgY2guY2hhckNvZGVBdChjaC5sZW5ndGggLSAxKS50b1N0cmluZygxNikgK1xyXG4gICAgICAgICAgICAgIFwiIFwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxyXG4gICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2g7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBVc2VkIGZvciBpZnJhbWVzXHJcbiAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcclxuICAgICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcclxuICAgICAgICAvLyBlcnJvciBpbiBJRVxyXG4gICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZXREb2N1bWVudCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcclxuICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJlxyXG4gICAgICAgICAgICAgIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBwdXNoLmFwcGx5KFxyXG4gICAgICAgICAgKGFyciA9IHNsaWNlLmNhbGwocHJlZmVycmVkRG9jLmNoaWxkTm9kZXMpKSxcclxuICAgICAgICAgIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcclxuICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xyXG4gICAgICAgIGFycltwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcHVzaCA9IHtcclxuICAgICAgICAgIGFwcGx5OiBhcnIubGVuZ3RoXHJcbiAgICAgICAgICAgID8gLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcclxuICAgICAgICAgICAgICAgIHB1c2hOYXRpdmUuYXBwbHkodGFyZ2V0LCBzbGljZS5jYWxsKGVscykpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiAvLyBTdXBwb3J0OiBJRTw5XHJcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGogPSB0YXJnZXQubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcclxuICAgICAgICAgICAgICAgIHdoaWxlICgodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkpIHt9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcclxuICAgICAgICB2YXIgbSxcclxuICAgICAgICAgIGksXHJcbiAgICAgICAgICBlbGVtLFxyXG4gICAgICAgICAgbmlkLFxyXG4gICAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgICBncm91cHMsXHJcbiAgICAgICAgICBuZXdTZWxlY3RvcixcclxuICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcclxuICAgICAgICAgIC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcclxuICAgICAgICAgIG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xyXG5cclxuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHxcclxuICAgICAgICAgICFzZWxlY3RvciB8fFxyXG4gICAgICAgICAgKG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xyXG4gICAgICAgIGlmICghc2VlZCkge1xyXG4gICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcclxuXHJcbiAgICAgICAgICBpZiAoZG9jdW1lbnRJc0hUTUwpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2RcclxuICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxyXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICBpZiAoKG0gPSBtYXRjaFsxXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gRWxlbWVudCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxyXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXHJcbiAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKG0pKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5pZCA9PT0gbVxyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUeXBlIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGFzcyBzZWxlY3RvclxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAobSA9IG1hdGNoWzNdKSAmJlxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWVcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgc3VwcG9ydC5xc2EgJiZcclxuICAgICAgICAgICAgICAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVtzZWxlY3RvciArIFwiIFwiXSAmJlxyXG4gICAgICAgICAgICAgICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChzZWxlY3RvcikpICYmXHJcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOCBvbmx5XHJcbiAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcclxuICAgICAgICAgICAgICAobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXHJcbiAgICAgICAgICAgICAgLy8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cclxuICAgICAgICAgICAgICAvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cclxuICAgICAgICAgICAgICAvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgLy8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXHJcbiAgICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIG5vZGVUeXBlID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAocmRlc2NlbmQudGVzdChzZWxlY3RvcikgfHwgcmNvbWJpbmF0b3JzLnRlc3Qoc2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID1cclxuICAgICAgICAgICAgICAgICAgKHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSkgfHxcclxuICAgICAgICAgICAgICAgICAgY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICAgIGlmIChuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgIGlmICgobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIChuaWQgPSBleHBhbmRvKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IHRva2VuaXplKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICBncm91cHNbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIChuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIpICsgXCIgXCIgKyB0b1NlbGVjdG9yKGdyb3Vwc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbChuZXdTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoc2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGwgb3RoZXJzXHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxyXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXHJcbiAgICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxyXG4gICAgICAgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcclxuICAgICAgICAgIGlmIChrZXlzLnB1c2goa2V5ICsgXCIgXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcclxuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gKGNhY2hlW2tleSArIFwiIFwiXSA9IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcclxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xyXG4gICAgICAgIGZuW2V4cGFuZG9dID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxyXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBhc3NlcnQoZm4pIHtcclxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gISFmbihlbCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcclxuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXHJcbiAgICAgICAgICBlbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXHJcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gYWRkSGFuZGxlKGF0dHJzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcclxuICAgICAgICAgIGkgPSBhcnIubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICBFeHByLmF0dHJIYW5kbGVbYXJyW2ldXSA9IGhhbmRsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xyXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcclxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBiXHJcbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKGEsIGIpIHtcclxuICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxyXG4gICAgICAgICAgZGlmZiA9XHJcbiAgICAgICAgICAgIGN1ciAmJlxyXG4gICAgICAgICAgICBhLm5vZGVUeXBlID09PSAxICYmXHJcbiAgICAgICAgICAgIGIubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XHJcblxyXG4gICAgICAgIC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xyXG4gICAgICAgIGlmIChkaWZmKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXHJcbiAgICAgICAgaWYgKGN1cikge1xyXG4gICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhID8gMSA6IC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8odHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8odHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXHJcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XHJcbiAgICAgICAgLy8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcclxuICAgICAgICAgIGlmIChcImZvcm1cIiBpbiBlbGVtKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcclxuICAgICAgICAgICAgLy8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcclxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxyXG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxyXG4gICAgICAgICAgICAvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXHJcbiAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxyXG4gICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXHJcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcclxuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xyXG4gICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXHJcbiAgICAgICAgICAgICAgICAoZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0KGVsZW0pID09PSBkaXNhYmxlZClcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgIC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxyXG4gICAgICAgICAgICAvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcclxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZm4pIHtcclxuICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChhcmd1bWVudCkge1xyXG4gICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XHJcbiAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcyA9IGZuKFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQpLFxyXG4gICAgICAgICAgICAgIGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICBpZiAoc2VlZFsoaiA9IG1hdGNoSW5kZXhlc1tpXSldKSB7XHJcbiAgICAgICAgICAgICAgICBzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcclxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcclxuICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0ZXN0Q29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGNvbnRleHQgJiZcclxuICAgICAgICAgIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcclxuICAgICAgc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogRGV0ZWN0cyBYTUwgbm9kZXNcclxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcclxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxyXG4gICAgICAgKi9cclxuICAgICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcclxuICAgICAgICAgIGRvY0VsZW0gPSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XHJcbiAgICAgICAgLy8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXHJcbiAgICAgICAgcmV0dXJuICFyaHRtbC50ZXN0KFxyXG4gICAgICAgICAgbmFtZXNwYWNlIHx8IChkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUpIHx8IFwiSFRNTFwiXHJcbiAgICAgICAgKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcclxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcclxuICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxyXG4gICAgICAgKi9cclxuICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBoYXNDb21wYXJlLFxyXG4gICAgICAgICAgc3ViV2luZG93LFxyXG4gICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xyXG4gICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xyXG4gICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgICAgaWYgKGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXHJcbiAgICAgICAgZG9jdW1lbnQgPSBkb2M7XHJcbiAgICAgICAgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICBkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2N1bWVudCk7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcclxuICAgICAgICAvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXHJcbiAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXHJcbiAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcclxuICAgICAgICAgIChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiZcclxuICAgICAgICAgIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvd1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcclxuICAgICAgICAgIGlmIChzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJXaW5kb3cuYXR0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgc3ViV2luZG93LmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxyXG4gICAgICAgIC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcclxuICAgICAgICAvLyBJRS9FZGdlICYgb2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cclxuICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcclxuICAgICAgICAvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cclxuICAgICAgICBzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSBmaWVsZHNldCBkaXZcIikubGVuZ3RoXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKiBBdHRyaWJ1dGVzXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XHJcbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXHJcbiAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJpXCI7XHJcbiAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyogZ2V0RWxlbWVudChzKUJ5KlxyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xyXG4gICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcclxuICAgICAgICAgIHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OVxyXG4gICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdChcclxuICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBJRTwxMFxyXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxyXG4gICAgICAgIC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxyXG4gICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxyXG4gICAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlkID0gZXhwYW5kbztcclxuICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fFxyXG4gICAgICAgICAgICAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcclxuICAgICAgICBpZiAoc3VwcG9ydC5nZXRCeUlkKSB7XHJcbiAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgICBkb2N1bWVudElzSFRNTFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICB2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBlbGVtID8gW2VsZW1dIDogW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICB2YXIgbm9kZSA9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcclxuICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcclxuICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIHZhciBub2RlLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIGVsZW1zLFxyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXHJcbiAgICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoaWQpO1xyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGFnXHJcbiAgICAgICAgRXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZVxyXG4gICAgICAgICAgPyBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5xc2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xyXG4gICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgdG1wID0gW10sXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcclxuICAgICAgICAgICAgICBpZiAodGFnID09PSBcIipcIikge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gcmVzdWx0c1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENsYXNzXHJcbiAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPVxyXG4gICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXHJcbiAgICAgICAgICBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICAgICAgZG9jdW1lbnRJc0hUTUxcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XHJcblxyXG4gICAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXHJcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxyXG4gICAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxyXG4gICAgICAgIC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcclxuICAgICAgICAvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcclxuICAgICAgICByYnVnZ3lRU0EgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSkpIHtcclxuICAgICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxyXG4gICAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxyXG4gICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxyXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcclxuICAgICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XHJcbiAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgXCI8YSBpZD0nXCIgK1xyXG4gICAgICAgICAgICAgIGV4cGFuZG8gK1xyXG4gICAgICAgICAgICAgIFwiJz48L2E+XCIgK1xyXG4gICAgICAgICAgICAgIFwiPHNlbGVjdCBpZD0nXCIgK1xyXG4gICAgICAgICAgICAgIGV4cGFuZG8gK1xyXG4gICAgICAgICAgICAgIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcclxuICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cclxuICAgICAgICAgICAgLy8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxyXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcclxuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFxyXG4gICAgICAgICAgICAgICAgXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xyXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXHJcbiAgICAgICAgICAgIC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXHJcbiAgICAgICAgICAgIC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXHJcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgaXNzdWUuXHJcbiAgICAgICAgICAgIC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cclxuICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9JyddXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFxyXG4gICAgICAgICAgICAgICAgXCJcXFxcW1wiICtcclxuICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICAgICAgICAgIFwiKm5hbWVcIiArXHJcbiAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgICBcIio9XCIgK1xyXG4gICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICAgICAgXCIqKD86Jyd8XFxcIlxcXCIpXCJcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xyXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxyXG4gICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xyXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXHJcbiAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcclxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD0zLjYgLSA1IG9ubHlcclxuICAgICAgICAgICAgLy8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvckFsbChcIlxcXFxcXGZcIik7XHJcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiW1xcXFxyXFxcXG5cXFxcZl1cIik7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICAgXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcclxuICAgICAgICAgICAgICBcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xyXG4gICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcclxuICAgICAgICAgICAgLy8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXHJcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcclxuICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcclxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTktMTErXHJcbiAgICAgICAgICAgIC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xyXG4gICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxyXG4gICAgICAgICAgICAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xyXG4gICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcclxuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoXHJcbiAgICAgICAgICAgIChtYXRjaGVzID1cclxuICAgICAgICAgICAgICBkb2NFbGVtLm1hdGNoZXMgfHxcclxuICAgICAgICAgICAgICBkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxyXG4gICAgICAgICAgICAgIGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcilcclxuICAgICAgICAgICkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxyXG4gICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxyXG4gICAgICAgICAgICBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKGVsLCBcIipcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcclxuICAgICAgICAgICAgbWF0Y2hlcy5jYWxsKGVsLCBcIltzIT0nJ106eFwiKTtcclxuICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5wdXNoKFwiIT1cIiwgcHNldWRvcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lRU0Euam9pbihcInxcIikpO1xyXG4gICAgICAgIHJidWdneU1hdGNoZXMgPVxyXG4gICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpKTtcclxuXHJcbiAgICAgICAgLyogQ29udGFpbnNcclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgaGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXHJcbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXHJcbiAgICAgICAgLy8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcclxuICAgICAgICBjb250YWlucyA9XHJcbiAgICAgICAgICBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbnRhaW5zKVxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxyXG4gICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgIGEgPT09IGJ1cCB8fFxyXG4gICAgICAgICAgICAgICAgICAhIShcclxuICAgICAgICAgICAgICAgICAgICBidXAgJiZcclxuICAgICAgICAgICAgICAgICAgICBidXAubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAoYWRvd24uY29udGFpbnNcclxuICAgICAgICAgICAgICAgICAgICAgID8gYWRvd24uY29udGFpbnMoYnVwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2KVxyXG4gICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKChiID0gYi5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKiBTb3J0aW5nXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXHJcbiAgICAgICAgc29ydE9yZGVyID0gaGFzQ29tcGFyZVxyXG4gICAgICAgICAgPyBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgIC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cclxuICAgICAgICAgICAgICB2YXIgY29tcGFyZSA9XHJcbiAgICAgICAgICAgICAgICAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgIGlmIChjb21wYXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcclxuICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcclxuICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXHJcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICAgICAgICAgIGNvbXBhcmUgPVxyXG4gICAgICAgICAgICAgICAgKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PSAoYi5vd25lckRvY3VtZW50IHx8IGIpXHJcbiAgICAgICAgICAgICAgICAgID8gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKVxyXG4gICAgICAgICAgICAgICAgICA6IC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGNvbXBhcmUgJiAxIHx8XHJcbiAgICAgICAgICAgICAgICAoIXN1cHBvcnQuc29ydERldGFjaGVkICYmXHJcbiAgICAgICAgICAgICAgICAgIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xyXG4gICAgICAgICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIGEgPT0gZG9jdW1lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgKGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSlcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXHJcbiAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcclxuICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgYiA9PSBkb2N1bWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAoYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydElucHV0XHJcbiAgICAgICAgICAgICAgICAgID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpXHJcbiAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcclxuICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIGN1cixcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgYXAgPSBbYV0sXHJcbiAgICAgICAgICAgICAgICBicCA9IFtiXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcclxuICAgICAgICAgICAgICBpZiAoIWF1cCB8fCAhYnVwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcclxuICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICA/IC0xXHJcbiAgICAgICAgICAgICAgICAgIDogYiA9PSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgICAgICAgOiAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xyXG4gICAgICAgICAgICAgICAgICBhdXBcclxuICAgICAgICAgICAgICAgICAgPyAtMVxyXG4gICAgICAgICAgICAgICAgICA6IGJ1cFxyXG4gICAgICAgICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgICAgICAgOiBzb3J0SW5wdXRcclxuICAgICAgICAgICAgICAgICAgPyBpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYilcclxuICAgICAgICAgICAgICAgICAgOiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdXAgPT09IGJ1cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgICAgICAgY3VyID0gYTtcclxuICAgICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci5wYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgYXAudW5zaGlmdChjdXIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjdXIgPSBiO1xyXG4gICAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBicC51bnNoaWZ0KGN1cik7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxyXG4gICAgICAgICAgICAgIHdoaWxlIChhcFtpXSA9PT0gYnBbaV0pIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiBpXHJcbiAgICAgICAgICAgICAgICA/IC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxyXG4gICAgICAgICAgICAgICAgICBzaWJsaW5nQ2hlY2soYXBbaV0sIGJwW2ldKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xyXG4gICAgICAgICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cclxuICAgICAgICAgICAgICAgIGFwW2ldID09IHByZWZlcnJlZERvY1xyXG4gICAgICAgICAgICAgICAgPyAtMVxyXG4gICAgICAgICAgICAgICAgOiBicFtpXSA9PSBwcmVmZXJyZWREb2NcclxuICAgICAgICAgICAgICAgID8gMVxyXG4gICAgICAgICAgICAgICAgOiAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xyXG4gICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChleHByLCBlbGVtZW50cykge1xyXG4gICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtLCBleHByKSB7XHJcbiAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmXHJcbiAgICAgICAgICBkb2N1bWVudElzSFRNTCAmJlxyXG4gICAgICAgICAgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbZXhwciArIFwiIFwiXSAmJlxyXG4gICAgICAgICAgKCFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoZXhwcikpICYmXHJcbiAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoZXhwcikpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKGVsZW0sIGV4cHIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgcmV0IHx8XHJcbiAgICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxyXG4gICAgICAgICAgICAgIC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxyXG4gICAgICAgICAgICAgIChlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoZXhwciwgdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0pLmxlbmd0aCA+IDA7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xyXG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xyXG4gICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xyXG4gICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgICAgaWYgKChjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCkgIT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGFpbnMoY29udGV4dCwgZWxlbSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XHJcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXHJcbiAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXHJcbiAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbbmFtZS50b0xvd2VyQ2FzZSgpXSxcclxuICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxyXG4gICAgICAgICAgdmFsID1cclxuICAgICAgICAgICAgZm4gJiYgaGFzT3duLmNhbGwoRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgICAgPyBmbihlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwpXHJcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyB2YWxcclxuICAgICAgICAgIDogc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTFxyXG4gICAgICAgICAgPyBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKVxyXG4gICAgICAgICAgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkXHJcbiAgICAgICAgICA/IHZhbC52YWx1ZVxyXG4gICAgICAgICAgOiBudWxsO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uIChzZWwpIHtcclxuICAgICAgICByZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICAgICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcclxuICAgICAgICovXHJcbiAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICB2YXIgZWxlbSxcclxuICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcclxuICAgICAgICAgIGogPSAwLFxyXG4gICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcclxuICAgICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xyXG4gICAgICAgIHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSgwKTtcclxuICAgICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xyXG4gICAgICAgICAgd2hpbGUgKChlbGVtID0gcmVzdWx0c1tpKytdKSkge1xyXG4gICAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xyXG4gICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoZHVwbGljYXRlc1tqXSwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxyXG4gICAgICAgIHNvcnRJbnB1dCA9IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICB2YXIgbm9kZSxcclxuICAgICAgICAgIHJldCA9IFwiXCIsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcbiAgICAgICAgaWYgKCFub2RlVHlwZSkge1xyXG4gICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcclxuICAgICAgICAgIHdoaWxlICgobm9kZSA9IGVsZW1baSsrXSkpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcclxuICAgICAgICAgICAgcmV0ICs9IGdldFRleHQobm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEpIHtcclxuICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcclxuICAgICAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cclxuICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KGVsZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xyXG4gICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcclxuICAgICAgICAvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcclxuICAgICAgICBjYWNoZUxlbmd0aDogNTAsXHJcblxyXG4gICAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxyXG5cclxuICAgICAgICBtYXRjaDogbWF0Y2hFeHByLFxyXG5cclxuICAgICAgICBhdHRySGFuZGxlOiB7fSxcclxuXHJcbiAgICAgICAgZmluZDoge30sXHJcblxyXG4gICAgICAgIHJlbGF0aXZlOiB7XHJcbiAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxyXG4gICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxyXG4gICAgICAgICAgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxyXG4gICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH0sXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHJlRmlsdGVyOiB7XHJcbiAgICAgICAgICBBVFRSOiBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXHJcbiAgICAgICAgICAgIG1hdGNoWzNdID0gKG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIpLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgcnVuZXNjYXBlLFxyXG4gICAgICAgICAgICAgIGZ1bmVzY2FwZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09PSBcIn49XCIpIHtcclxuICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDQpO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBDSElMRDogZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxyXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxyXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcclxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxyXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxyXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcclxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XHJcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XHJcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XHJcblx0XHRcdCovXHJcbiAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zbGljZSgwLCAzKSA9PT0gXCJudGhcIikge1xyXG4gICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XHJcbiAgICAgICAgICAgICAgaWYgKCFtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxyXG4gICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcclxuICAgICAgICAgICAgICBtYXRjaFs0XSA9ICsobWF0Y2hbNF1cclxuICAgICAgICAgICAgICAgID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSlcclxuICAgICAgICAgICAgICAgIDogMiAqIChtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpKTtcclxuICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsobWF0Y2hbN10gKyBtYXRjaFs4XSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIik7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XHJcbiAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBQU0VVRE86IGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgZXhjZXNzLFxyXG4gICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QobWF0Y2hbMF0pKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXHJcbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICB1bnF1b3RlZCAmJlxyXG4gICAgICAgICAgICAgIHJwc2V1ZG8udGVzdCh1bnF1b3RlZCkgJiZcclxuICAgICAgICAgICAgICAvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxyXG4gICAgICAgICAgICAgIChleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmXHJcbiAgICAgICAgICAgICAgLy8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXHJcbiAgICAgICAgICAgICAgKGV4Y2VzcyA9XHJcbiAgICAgICAgICAgICAgICB1bnF1b3RlZC5pbmRleE9mKFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MpIC1cclxuICAgICAgICAgICAgICAgIHVucXVvdGVkLmxlbmd0aClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcclxuICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XHJcbiAgICAgICAgICAgICAgbWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSgwLCBleGNlc3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgIFRBRzogZnVuY3Rpb24gKG5vZGVOYW1lU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3RvclxyXG4gICAgICAgICAgICAgIC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKVxyXG4gICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCJcclxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZVxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgQ0xBU1M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlW2NsYXNzTmFtZSArIFwiIFwiXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgcGF0dGVybiB8fFxyXG4gICAgICAgICAgICAgICgocGF0dGVybiA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICAgICBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIlxyXG4gICAgICAgICAgICAgICkpICYmXHJcbiAgICAgICAgICAgICAgICBjbGFzc0NhY2hlKGNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChcclxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJcIlxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIEFUVFI6IGZ1bmN0aW9uIChuYW1lLCBvcGVyYXRvciwgY2hlY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKGVsZW0sIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCJcclxuICAgICAgICAgICAgICAgID8gcmVzdWx0ID09PSBjaGVja1xyXG4gICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCIhPVwiXHJcbiAgICAgICAgICAgICAgICA/IHJlc3VsdCAhPT0gY2hlY2tcclxuICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwiXj1cIlxyXG4gICAgICAgICAgICAgICAgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDBcclxuICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwiKj1cIlxyXG4gICAgICAgICAgICAgICAgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMVxyXG4gICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCIkPVwiXHJcbiAgICAgICAgICAgICAgICA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSgtY2hlY2subGVuZ3RoKSA9PT0gY2hlY2tcclxuICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwifj1cIlxyXG4gICAgICAgICAgICAgICAgPyAoXCIgXCIgKyByZXN1bHQucmVwbGFjZShyd2hpdGVzcGFjZSwgXCIgXCIpICsgXCIgXCIpLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tcclxuICAgICAgICAgICAgICAgICAgKSA+IC0xXHJcbiAgICAgICAgICAgICAgICA6IG9wZXJhdG9yID09PSBcInw9XCJcclxuICAgICAgICAgICAgICAgID8gcmVzdWx0ID09PSBjaGVjayB8fFxyXG4gICAgICAgICAgICAgICAgICByZXN1bHQuc2xpY2UoMCwgY2hlY2subGVuZ3RoICsgMSkgPT09IGNoZWNrICsgXCItXCJcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIENISUxEOiBmdW5jdGlvbiAodHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCkge1xyXG4gICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSgwLCAzKSAhPT0gXCJudGhcIixcclxuICAgICAgICAgICAgICBmb3J3YXJkID0gdHlwZS5zbGljZSgtNCkgIT09IFwibGFzdFwiLFxyXG4gICAgICAgICAgICAgIG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDBcclxuICAgICAgICAgICAgICA/IC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChlbGVtLCBfY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBjYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGRpciA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGVbZGlyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZlR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLm5vZGVUeXBlID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBkaXIgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gW2ZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XHJcbiAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXHJcbiAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVt0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9wKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBub2RlSW5kZXgsIGRpZmZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbdHlwZV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9wKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvZlR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytkaWZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBkaWZmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICBkaWZmID09PSBmaXJzdCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgKGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBQU0VVRE86IGZ1bmN0aW9uIChwc2V1ZG8sIGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxyXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXHJcbiAgICAgICAgICAgIC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXHJcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcclxuICAgICAgICAgICAgdmFyIGFyZ3MsXHJcbiAgICAgICAgICAgICAgZm4gPVxyXG4gICAgICAgICAgICAgICAgRXhwci5wc2V1ZG9zW3BzZXVkb10gfHxcclxuICAgICAgICAgICAgICAgIEV4cHIuc2V0RmlsdGVyc1twc2V1ZG8udG9Mb3dlckNhc2UoKV0gfHxcclxuICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxyXG4gICAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxyXG4gICAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXHJcbiAgICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmbihhcmd1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xyXG4gICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcclxuICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KHBzZXVkby50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICAgICAgICAgICAgPyBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKHNlZWQsIGFyZ3VtZW50KSxcclxuICAgICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mKHNlZWQsIG1hdGNoZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2VlZFtpZHhdID0gIShtYXRjaGVzW2lkeF0gPSBtYXRjaGVkW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBzZXVkb3M6IHtcclxuICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xyXG4gICAgICAgICAgbm90OiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXHJcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXHJcbiAgICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBbXSxcclxuICAgICAgICAgICAgICByZXN1bHRzID0gW10sXHJcbiAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcltleHBhbmRvXVxyXG4gICAgICAgICAgICAgID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHNlZWQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdW5tYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChlbGVtLCBfY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcclxuICAgICAgICAgICAgICAgICAgbWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXHJcbiAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgIGhhczogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgY29udGFpbnM6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoZWxlbSkpLmluZGV4T2YodGV4dCkgPiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxyXG4gICAgICAgICAgLy8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcclxuICAgICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXHJcbiAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxyXG4gICAgICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXHJcbiAgICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXHJcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXHJcbiAgICAgICAgICBsYW5nOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGxhbmcpIHtcclxuICAgICAgICAgICAgLy8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxyXG4gICAgICAgICAgICBpZiAoIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSkge1xyXG4gICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFuZyA9IGxhbmcucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xyXG4gICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUxcclxuICAgICAgICAgICAgICAgICAgICA/IGVsZW0ubGFuZ1xyXG4gICAgICAgICAgICAgICAgICAgIDogZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKGxhbmcgKyBcIi1cIikgPT09IDBcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xyXG4gICAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgcm9vdDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmXHJcbiAgICAgICAgICAgICAgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICBlbmFibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhmYWxzZSksXHJcbiAgICAgICAgICBkaXNhYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8odHJ1ZSksXHJcblxyXG4gICAgICAgICAgY2hlY2tlZDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgLy8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXHJcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHxcclxuICAgICAgICAgICAgICAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBzZWxlY3RlZDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgLy8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxyXG4gICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XHJcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAvLyBDb250ZW50c1xyXG4gICAgICAgICAgZW1wdHk6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXHJcbiAgICAgICAgICAgIC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcclxuICAgICAgICAgICAgLy8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcclxuICAgICAgICAgICAgLy8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxyXG4gICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oZWxlbSk7XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcclxuICAgICAgICAgIGhlYWRlcjogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdChlbGVtLm5vZGVOYW1lKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByaW5wdXRzLnRlc3QoZWxlbS5ub2RlTmFtZSk7XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIGJ1dHRvbjogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgKG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIpIHx8IG5hbWUgPT09IFwiYnV0dG9uXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgdGV4dDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgdmFyIGF0dHI7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcclxuICAgICAgICAgICAgICBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXHJcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxyXG4gICAgICAgICAgICAgIC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgKChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXHJcbiAgICAgICAgICBmaXJzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMF07XHJcbiAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICBsYXN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChfbWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtsZW5ndGggLSAxXTtcclxuICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgIGVxOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChcclxuICAgICAgICAgICAgX21hdGNoSW5kZXhlcyxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBhcmd1bWVudFxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudF07XHJcbiAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICBldmVuOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgb2RkOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDE7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgbHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9XHJcbiAgICAgICAgICAgICAgYXJndW1lbnQgPCAwXHJcbiAgICAgICAgICAgICAgICA/IGFyZ3VtZW50ICsgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50ID4gbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudDtcclxuICAgICAgICAgICAgZm9yICg7IC0taSA+PSAwOyApIHtcclxuICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgZ3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XHJcbiAgICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7ICkge1xyXG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XHJcblxyXG4gICAgICAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xyXG4gICAgICBmb3IgKGkgaW4ge1xyXG4gICAgICAgIHJhZGlvOiB0cnVlLFxyXG4gICAgICAgIGNoZWNrYm94OiB0cnVlLFxyXG4gICAgICAgIGZpbGU6IHRydWUsXHJcbiAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgaW1hZ2U6IHRydWUsXHJcbiAgICAgIH0pIHtcclxuICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVJbnB1dFBzZXVkbyhpKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0pIHtcclxuICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oaSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xyXG4gICAgICBmdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cclxuICAgICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XHJcbiAgICAgIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XHJcblxyXG4gICAgICB0b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFyc2VPbmx5KSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZWQsXHJcbiAgICAgICAgICBtYXRjaCxcclxuICAgICAgICAgIHRva2VucyxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBzb0ZhcixcclxuICAgICAgICAgIGdyb3VwcyxcclxuICAgICAgICAgIHByZUZpbHRlcnMsXHJcbiAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xyXG5cclxuICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSgwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XHJcbiAgICAgICAgZ3JvdXBzID0gW107XHJcbiAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xyXG5cclxuICAgICAgICB3aGlsZSAoc29GYXIpIHtcclxuICAgICAgICAgIC8vIENvbW1hIGFuZCBmaXJzdCBydW5cclxuICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyhzb0ZhcikpKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgIC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXHJcbiAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaFswXS5sZW5ndGgpIHx8IHNvRmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCh0b2tlbnMgPSBbXSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBDb21iaW5hdG9yc1xyXG4gICAgICAgICAgaWYgKChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKHNvRmFyKSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXHJcbiAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMF0ucmVwbGFjZShydHJpbSwgXCIgXCIpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRmlsdGVyc1xyXG4gICAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAobWF0Y2ggPSBtYXRjaEV4cHJbdHlwZV0uZXhlYyhzb0ZhcikpICYmXHJcbiAgICAgICAgICAgICAgKCFwcmVGaWx0ZXJzW3R5cGVdIHx8IChtYXRjaCA9IHByZUZpbHRlcnNbdHlwZV0obWF0Y2gpKSlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2gsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIW1hdGNoZWQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcclxuICAgICAgICAvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcclxuICAgICAgICByZXR1cm4gcGFyc2VPbmx5XHJcbiAgICAgICAgICA/IHNvRmFyLmxlbmd0aFxyXG4gICAgICAgICAgOiBzb0ZhclxyXG4gICAgICAgICAgPyBTaXp6bGUuZXJyb3Ioc2VsZWN0b3IpXHJcbiAgICAgICAgICA6IC8vIENhY2hlIHRoZSB0b2tlbnNcclxuICAgICAgICAgICAgdG9rZW5DYWNoZShzZWxlY3RvciwgZ3JvdXBzKS5zbGljZSgwKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IodG9rZW5zKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcclxuICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gYWRkQ29tYmluYXRvcihtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxyXG4gICAgICAgICAgc2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcclxuICAgICAgICAgIGtleSA9IHNraXAgfHwgZGlyLFxyXG4gICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcclxuICAgICAgICAgIGRvbmVOYW1lID0gZG9uZSsrO1xyXG5cclxuICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdFxyXG4gICAgICAgICAgPyAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICA6IC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG9sZENhY2hlLFxyXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxyXG4gICAgICAgICAgICAgICAgbmV3Q2FjaGUgPSBbZGlycnVucywgZG9uZU5hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcclxuICAgICAgICAgICAgICBpZiAoeG1sKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbVtkaXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IGVsZW1bZXhwYW5kb10gfHwgKGVsZW1bZXhwYW5kb10gPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSA9IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlW2tleV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICBvbGRDYWNoZVswXSA9PT0gZGlycnVucyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXdDYWNoZVsyXSA9IG9sZENhY2hlWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVba2V5XSA9IG5ld0NhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgPyBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVyc1tpXShlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIDogbWF0Y2hlcnNbMF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIFNpenpsZShzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29uZGVuc2UodW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcclxuICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoKGVsZW0gPSB1bm1hdGNoZWRbaV0pKSB7XHJcbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgbWFwLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzZXRNYXRjaGVyKFxyXG4gICAgICAgIHByZUZpbHRlcixcclxuICAgICAgICBzZWxlY3RvcixcclxuICAgICAgICBtYXRjaGVyLFxyXG4gICAgICAgIHBvc3RGaWx0ZXIsXHJcbiAgICAgICAgcG9zdEZpbmRlcixcclxuICAgICAgICBwb3N0U2VsZWN0b3JcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcclxuICAgICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xyXG4gICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICB2YXIgdGVtcCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgcHJlTWFwID0gW10sXHJcbiAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcclxuICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcclxuICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcclxuICAgICAgICAgICAgZWxlbXMgPVxyXG4gICAgICAgICAgICAgIHNlZWQgfHxcclxuICAgICAgICAgICAgICBtdWx0aXBsZUNvbnRleHRzKFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgfHwgXCIqXCIsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCxcclxuICAgICAgICAgICAgICAgIFtdXHJcbiAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXHJcbiAgICAgICAgICAgIG1hdGNoZXJJbiA9XHJcbiAgICAgICAgICAgICAgcHJlRmlsdGVyICYmIChzZWVkIHx8ICFzZWxlY3RvcilcclxuICAgICAgICAgICAgICAgID8gY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpXHJcbiAgICAgICAgICAgICAgICA6IGVsZW1zLFxyXG4gICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlclxyXG4gICAgICAgICAgICAgID8gLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcclxuICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKVxyXG4gICAgICAgICAgICAgICAgPyAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgICAgIDogLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHNcclxuICAgICAgICAgICAgICA6IG1hdGNoZXJJbjtcclxuXHJcbiAgICAgICAgICAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xyXG4gICAgICAgICAgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxyXG4gICAgICAgICAgaWYgKHBvc3RGaWx0ZXIpIHtcclxuICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQsIHBvc3RNYXApO1xyXG4gICAgICAgICAgICBwb3N0RmlsdGVyKHRlbXAsIFtdLCBjb250ZXh0LCB4bWwpO1xyXG5cclxuICAgICAgICAgICAgLy8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxyXG4gICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB0ZW1wW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHNlZWQpIHtcclxuICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKChtYXRjaGVySW5baV0gPSBlbGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxyXG4gICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcclxuICAgICAgICAgICAgICAgICAgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZihzZWVkLCBlbGVtKSA6IHByZU1hcFtpXSkgPiAtMVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0Y2hlck91dCA9IGNvbmRlbnNlKFxyXG4gICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHNcclxuICAgICAgICAgICAgICAgID8gbWF0Y2hlck91dC5zcGxpY2UocHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgOiBtYXRjaGVyT3V0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XHJcbiAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XHJcbiAgICAgICAgdmFyIGNoZWNrQ29udGV4dCxcclxuICAgICAgICAgIG1hdGNoZXIsXHJcbiAgICAgICAgICBqLFxyXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcclxuICAgICAgICAgIGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbdG9rZW5zWzBdLnR5cGVdLFxyXG4gICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcclxuICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcclxuICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXHJcbiAgICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUsXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBpbmRleE9mKGNoZWNrQ29udGV4dCwgZWxlbSkgPiAtMTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSxcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG1hdGNoZXJzID0gW1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJldCA9XHJcbiAgICAgICAgICAgICAgICAoIWxlYWRpbmdSZWxhdGl2ZSAmJiAoeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQpKSB8fFxyXG4gICAgICAgICAgICAgICAgKChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZVxyXG4gICAgICAgICAgICAgICAgICA/IG1hdGNoQ29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpXHJcbiAgICAgICAgICAgICAgICAgIDogbWF0Y2hBbnlDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcclxuICAgICAgICAgICAgICBjaGVja0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1tpXS50eXBlXSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclt0b2tlbnNbaV0udHlwZV0uYXBwbHkoXHJcbiAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICB0b2tlbnNbaV0ubWF0Y2hlc1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXJbZXhwYW5kb10pIHtcclxuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcclxuICAgICAgICAgICAgICBqID0gKytpO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3Rva2Vuc1tqXS50eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHNldE1hdGNoZXIoXHJcbiAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksXHJcbiAgICAgICAgICAgICAgICBpID4gMSAmJlxyXG4gICAgICAgICAgICAgICAgICB0b1NlbGVjdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaSAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1tpIC0gMl0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcclxuICAgICAgICAgICAgICAgICAgKS5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcixcclxuICAgICAgICAgICAgICAgIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucy5zbGljZShpLCBqKSksXHJcbiAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpKSxcclxuICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgdG9TZWxlY3Rvcih0b2tlbnMpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpIHtcclxuICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgYnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXHJcbiAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiAoc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgICBtYXRjaGVyLFxyXG4gICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgaSA9IFwiMFwiLFxyXG4gICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXHJcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxyXG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcclxuICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgKGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oXCIqXCIsIG91dGVybW9zdCkpLFxyXG4gICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXHJcbiAgICAgICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxyXG4gICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcclxuICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcclxuICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXHJcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcclxuICAgICAgICAgICAgLy8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXHJcbiAgICAgICAgICAgIGZvciAoOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcclxuICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAgaWYgKGJ5U2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcclxuICAgICAgICAgICAgLy8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cclxuICAgICAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxyXG4gICAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcclxuICAgICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cclxuICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxyXG4gICAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cclxuICAgICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cclxuICAgICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyKHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwocmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBjb25kZW5zZShzZXRNYXRjaGVkKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcclxuICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNldE1hdGNoZWQpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3QgJiZcclxuICAgICAgICAgICAgICAgICFzZWVkICYmXHJcbiAgICAgICAgICAgICAgICBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXHJcbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcclxuICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBieVNldCA/IG1hcmtGdW5jdGlvbihzdXBlck1hdGNoZXIpIDogc3VwZXJNYXRjaGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiAoXHJcbiAgICAgICAgc2VsZWN0b3IsXHJcbiAgICAgICAgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi9cclxuICAgICAgKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBzZXRNYXRjaGVycyA9IFtdLFxyXG4gICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXHJcbiAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xyXG5cclxuICAgICAgICBpZiAoIWNhY2hlZCkge1xyXG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIG1hdGNoID0gdG9rZW5pemUoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcclxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMobWF0Y2hbaV0pO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkW2V4cGFuZG9dKSB7XHJcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cclxuICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXHJcbiAgICAgICAgICAgIHNlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycylcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXHJcbiAgICAgICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXHJcbiAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcclxuICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcclxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XHJcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxyXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxyXG4gICAgICAgKi9cclxuICAgICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgdG9rZW5zLFxyXG4gICAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgZmluZCxcclxuICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXHJcbiAgICAgICAgICBtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSk7XHJcblxyXG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xyXG5cclxuICAgICAgICAvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxyXG4gICAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcclxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxyXG4gICAgICAgICAgdG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwKTtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA+IDIgJiZcclxuICAgICAgICAgICAgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcclxuICAgICAgICAgICAgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJlxyXG4gICAgICAgICAgICBkb2N1bWVudElzSFRNTCAmJlxyXG4gICAgICAgICAgICBFeHByLnJlbGF0aXZlW3Rva2Vuc1sxXS50eXBlXVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSAoRXhwci5maW5kW1wiSURcIl0oXHJcbiAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSxcclxuICAgICAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgICAgICkgfHwgW10pWzBdO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuXHJcbiAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcclxuICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdChzZWxlY3RvcikgPyAwIDogdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXHJcbiAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlWyh0eXBlID0gdG9rZW4udHlwZSldKSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChmaW5kID0gRXhwci5maW5kW3R5cGVdKSkge1xyXG4gICAgICAgICAgICAgIC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChzZWVkID0gZmluZChcclxuICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSxcclxuICAgICAgICAgICAgICAgICAgKHJzaWJsaW5nLnRlc3QodG9rZW5zWzBdLnR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICApKVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XHJcbiAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2VlZCk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXHJcbiAgICAgICAgLy8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxyXG4gICAgICAgIChjb21waWxlZCB8fCBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCkpKFxyXG4gICAgICAgICAgc2VlZCxcclxuICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAhZG9jdW1lbnRJc0hUTUwsXHJcbiAgICAgICAgICByZXN1bHRzLFxyXG4gICAgICAgICAgIWNvbnRleHQgfHxcclxuICAgICAgICAgICAgKHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkpIHx8XHJcbiAgICAgICAgICAgIGNvbnRleHRcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gT25lLXRpbWUgYXNzaWdubWVudHNcclxuXHJcbiAgICAgIC8vIFNvcnQgc3RhYmlsaXR5XHJcbiAgICAgIHN1cHBvcnQuc29ydFN0YWJsZSA9XHJcbiAgICAgICAgZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KHNvcnRPcmRlcikuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcclxuXHJcbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcclxuICAgICAgLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxyXG4gICAgICBzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxyXG4gICAgICBzZXREb2N1bWVudCgpO1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcclxuICAgICAgLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXHJcbiAgICAgIHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpICYgMVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogSUU8OFxyXG4gICAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxyXG4gICAgICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xyXG4gICAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XHJcbiAgICAgICAgfSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgYWRkSGFuZGxlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcclxuICAgICAgICAgIGlmICghaXNYTUwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFxyXG4gICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN1cHBvcnQ6IElFPDlcclxuICAgICAgLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXN1cHBvcnQuYXR0cmlidXRlcyB8fFxyXG4gICAgICAgICFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XHJcbiAgICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpO1xyXG4gICAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IFwiXCI7XHJcbiAgICAgICAgfSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgYWRkSGFuZGxlKFwidmFsdWVcIiwgZnVuY3Rpb24gKGVsZW0sIF9uYW1lLCBpc1hNTCkge1xyXG4gICAgICAgICAgaWYgKCFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN1cHBvcnQ6IElFPDlcclxuICAgICAgLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICkge1xyXG4gICAgICAgIGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XHJcbiAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgaWYgKCFpc1hNTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICAgID8gbmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgPyB2YWwudmFsdWVcclxuICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBTaXp6bGU7XHJcbiAgICB9KSh3aW5kb3cpO1xyXG5cclxuICBqUXVlcnkuZmluZCA9IFNpenpsZTtcclxuICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XHJcblxyXG4gIC8vIERlcHJlY2F0ZWRcclxuICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xyXG4gIGpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xyXG4gIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XHJcbiAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xyXG4gIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcclxuICBqUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xyXG5cclxuICB2YXIgZGlyID0gZnVuY3Rpb24gKGVsZW0sIGRpciwgdW50aWwpIHtcclxuICAgIHZhciBtYXRjaGVkID0gW10sXHJcbiAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkpIHtcclxuICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICBpZiAodHJ1bmNhdGUgJiYgalF1ZXJ5KGVsZW0pLmlzKHVudGlsKSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoZWQucHVzaChlbGVtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZWQ7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHNpYmxpbmdzID0gZnVuY3Rpb24gKG4sIGVsZW0pIHtcclxuICAgIHZhciBtYXRjaGVkID0gW107XHJcblxyXG4gICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0pIHtcclxuICAgICAgICBtYXRjaGVkLnB1c2gobik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWF0Y2hlZDtcclxuICB9O1xyXG5cclxuICB2YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcclxuXHJcbiAgZnVuY3Rpb24gbm9kZU5hbWUoZWxlbSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgfVxyXG4gIHZhciByc2luZ2xlVGFnID0gL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2k7XHJcblxyXG4gIC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XHJcbiAgZnVuY3Rpb24gd2lubm93KGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xyXG4gICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XHJcbiAgICAgICAgcmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoZWxlbSwgaSwgZWxlbSkgIT09IG5vdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2luZ2xlIGVsZW1lbnRcclxuICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiAoZWxlbSA9PT0gcXVhbGlmaWVyKSAhPT0gbm90O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcclxuICAgIGlmICh0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHF1YWxpZmllciwgZWxlbSkgPiAtMSAhPT0gbm90O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXHJcbiAgICByZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QpO1xyXG4gIH1cclxuXHJcbiAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBlbGVtcywgbm90KSB7XHJcbiAgICB2YXIgZWxlbSA9IGVsZW1zWzBdO1xyXG5cclxuICAgIGlmIChub3QpIHtcclxuICAgICAgZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtLCBleHByKSA/IFtlbGVtXSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKFxyXG4gICAgICBleHByLFxyXG4gICAgICBqUXVlcnkuZ3JlcChlbGVtcywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICBmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgcmV0LFxyXG4gICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhcclxuICAgICAgICAgIGpRdWVyeShzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyhzZWxmW2ldLCB0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KHJldCkgOiByZXQ7XHJcbiAgICB9LFxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpKTtcclxuICAgIH0sXHJcbiAgICBub3Q6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSk7XHJcbiAgICB9LFxyXG4gICAgaXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gISF3aW5ub3coXHJcbiAgICAgICAgdGhpcyxcclxuXHJcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxyXG4gICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cclxuICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9yKVxyXG4gICAgICAgICAgPyBqUXVlcnkoc2VsZWN0b3IpXHJcbiAgICAgICAgICA6IHNlbGVjdG9yIHx8IFtdLFxyXG4gICAgICAgIGZhbHNlXHJcbiAgICAgICkubGVuZ3RoO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcclxuXHJcbiAgLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXHJcbiAgdmFyIHJvb3RqUXVlcnksXHJcbiAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xyXG4gICAgLy8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxyXG4gICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXHJcbiAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXHJcbiAgICBycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXHJcbiAgICBpbml0ID0gKGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0LCByb290KSB7XHJcbiAgICAgIHZhciBtYXRjaCwgZWxlbTtcclxuXHJcbiAgICAgIC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxyXG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxyXG4gICAgICAvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXHJcbiAgICAgIHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXHJcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiZcclxuICAgICAgICAgIHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdID09PSBcIj5cIiAmJlxyXG4gICAgICAgICAgc2VsZWN0b3IubGVuZ3RoID49IDNcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXHJcbiAgICAgICAgICBtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcclxuICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSkge1xyXG4gICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXHJcbiAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgIC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxyXG4gICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UoXHJcbiAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICBqUXVlcnkucGFyc2VIVE1MKFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGVcclxuICAgICAgICAgICAgICAgICAgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcclxuICAgICAgICAgICAgaWYgKHJzaW5nbGVUYWcudGVzdChtYXRjaFsxXSkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICBmb3IgKG1hdGNoIGluIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbbWF0Y2hdKSkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzW21hdGNoXShjb250ZXh0W21hdGNoXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobWF0Y2gsIGNvbnRleHRbbWF0Y2hdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gSEFORExFOiAkKCNpZClcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XHJcbiAgICAgICAgICAgICAgdGhpc1swXSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXHJcbiAgICAgICAgfSBlbHNlIGlmICghY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIChjb250ZXh0IHx8IHJvb3QpLmZpbmQoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxyXG4gICAgICAgICAgLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXHJcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcclxuICAgICAgICB0aGlzWzBdID0gc2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcclxuICAgICAgICByZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICA/IHJvb3QucmVhZHkoc2VsZWN0b3IpXHJcbiAgICAgICAgICA6IC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcclxuICAgICAgICAgICAgc2VsZWN0b3IoalF1ZXJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IsIHRoaXMpO1xyXG4gICAgfSk7XHJcblxyXG4gIC8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cclxuICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxyXG4gIHJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xyXG5cclxuICB2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXHJcbiAgICAvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxyXG4gICAgZ3VhcmFudGVlZFVuaXF1ZSA9IHtcclxuICAgICAgY2hpbGRyZW46IHRydWUsXHJcbiAgICAgIGNvbnRlbnRzOiB0cnVlLFxyXG4gICAgICBuZXh0OiB0cnVlLFxyXG4gICAgICBwcmV2OiB0cnVlLFxyXG4gICAgfTtcclxuXHJcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgdmFyIHRhcmdldHMgPSBqUXVlcnkodGFyZ2V0LCB0aGlzKSxcclxuICAgICAgICBsID0gdGFyZ2V0cy5sZW5ndGg7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9zZXN0OiBmdW5jdGlvbiAoc2VsZWN0b3JzLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBjdXIsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgIG1hdGNoZWQgPSBbXSxcclxuICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTtcclxuXHJcbiAgICAgIC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcclxuICAgICAgaWYgKCFybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSkge1xyXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICBmb3IgKGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlIDwgMTEgJiZcclxuICAgICAgICAgICAgICAodGFyZ2V0c1xyXG4gICAgICAgICAgICAgICAgPyB0YXJnZXRzLmluZGV4KGN1cikgPiAtMVxyXG4gICAgICAgICAgICAgICAgOiAvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcclxuICAgICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXHJcbiAgICAgICAgbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQobWF0Y2hlZCkgOiBtYXRjaGVkXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxyXG4gICAgaW5kZXg6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XHJcbiAgICAgIGlmICghZWxlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZVxyXG4gICAgICAgICAgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aFxyXG4gICAgICAgICAgOiAtMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5kZXggaW4gc2VsZWN0b3JcclxuICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChqUXVlcnkoZWxlbSksIHRoaXNbMF0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcclxuICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChcclxuICAgICAgICB0aGlzLFxyXG5cclxuICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcclxuICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhcclxuICAgICAgICBqUXVlcnkudW5pcXVlU29ydChqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSkpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZEJhY2s6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5hZGQoXHJcbiAgICAgICAgc2VsZWN0b3IgPT0gbnVsbCA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBzaWJsaW5nKGN1ciwgZGlyKSB7XHJcbiAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHt9XHJcbiAgICByZXR1cm4gY3VyO1xyXG4gIH1cclxuXHJcbiAgalF1ZXJ5LmVhY2goXHJcbiAgICB7XHJcbiAgICAgIHBhcmVudDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhcmVudHM6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInBhcmVudE5vZGVcIik7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gKGVsZW0sIF9pLCB1bnRpbCkge1xyXG4gICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsKTtcclxuICAgICAgfSxcclxuICAgICAgbmV4dDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcIm5leHRTaWJsaW5nXCIpO1xyXG4gICAgICB9LFxyXG4gICAgICBwcmV2OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xyXG4gICAgICB9LFxyXG4gICAgICBuZXh0QWxsOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcclxuICAgICAgfSxcclxuICAgICAgcHJldkFsbDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xyXG4gICAgICB9LFxyXG4gICAgICBuZXh0VW50aWw6IGZ1bmN0aW9uIChlbGVtLCBfaSwgdW50aWwpIHtcclxuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xyXG4gICAgICB9LFxyXG4gICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uIChlbGVtLCBfaSwgdW50aWwpIHtcclxuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsKTtcclxuICAgICAgfSxcclxuICAgICAgc2libGluZ3M6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xyXG4gICAgICB9LFxyXG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gc2libGluZ3MoZWxlbS5maXJzdENoaWxkKTtcclxuICAgICAgfSxcclxuICAgICAgY29udGVudHM6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErXHJcbiAgICAgICAgICAvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxyXG4gICAgICAgICAgLy8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXHJcbiAgICAgICAgICBnZXRQcm90byhlbGVtLmNvbnRlbnREb2N1bWVudClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxyXG4gICAgICAgIC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXHJcbiAgICAgICAgaWYgKG5vZGVOYW1lKGVsZW0sIFwidGVtcGxhdGVcIikpIHtcclxuICAgICAgICAgIGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoW10sIGVsZW0uY2hpbGROb2Rlcyk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uICh1bnRpbCwgc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAodGhpcywgZm4sIHVudGlsKTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTUpICE9PSBcIlVudGlsXCIpIHtcclxuICAgICAgICAgIHNlbGVjdG9yID0gdW50aWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBtYXRjaGVkID0galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgbWF0Y2hlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgaWYgKCFndWFyYW50ZWVkVW5pcXVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXHJcbiAgICAgICAgICBpZiAocnBhcmVudHNwcmV2LnRlc3QobmFtZSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgKTtcclxuICB2YXIgcm5vdGh0bWx3aGl0ZSA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcclxuXHJcbiAgLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcclxuICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgIGpRdWVyeS5lYWNoKG9wdGlvbnMubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW10sIGZ1bmN0aW9uIChfLCBmbGFnKSB7XHJcbiAgICAgIG9iamVjdFtmbGFnXSA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gICAqXHJcbiAgICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcclxuICAgKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXHJcbiAgICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxyXG4gICAqXHJcbiAgICogUG9zc2libGUgb3B0aW9uczpcclxuICAgKlxyXG4gICAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcclxuICAgKlxyXG4gICAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxyXG4gICAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcclxuICAgKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcclxuICAgKlxyXG4gICAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXHJcbiAgICpcclxuICAgKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcclxuICAgKlxyXG4gICAqL1xyXG4gIGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxyXG4gICAgLy8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxyXG4gICAgb3B0aW9ucyA9XHJcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgPyBjcmVhdGVPcHRpb25zKG9wdGlvbnMpXHJcbiAgICAgICAgOiBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xyXG4gICAgICBmaXJpbmcsXHJcbiAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXHJcbiAgICAgIG1lbW9yeSxcclxuICAgICAgLy8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcclxuICAgICAgZmlyZWQsXHJcbiAgICAgIC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcclxuICAgICAgbG9ja2VkLFxyXG4gICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxyXG4gICAgICBsaXN0ID0gW10sXHJcbiAgICAgIC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXHJcbiAgICAgIHF1ZXVlID0gW10sXHJcbiAgICAgIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxyXG4gICAgICBmaXJpbmdJbmRleCA9IC0xLFxyXG4gICAgICAvLyBGaXJlIGNhbGxiYWNrc1xyXG4gICAgICBmaXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xyXG4gICAgICAgIGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxyXG4gICAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcclxuICAgICAgICBmaXJlZCA9IGZpcmluZyA9IHRydWU7XHJcbiAgICAgICAgZm9yICg7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSkge1xyXG4gICAgICAgICAgbWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgIHdoaWxlICgrK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIGxpc3RbZmlyaW5nSW5kZXhdLmFwcGx5KG1lbW9yeVswXSwgbWVtb3J5WzFdKSA9PT0gZmFsc2UgJiZcclxuICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcclxuICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLm1lbW9yeSkge1xyXG4gICAgICAgICAgbWVtb3J5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmaXJpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcclxuICAgICAgICBpZiAobG9ja2VkKSB7XHJcbiAgICAgICAgICAvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXHJcbiAgICAgICAgICBpZiAobWVtb3J5KSB7XHJcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxpc3QgPSBcIlwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgLy8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcclxuICAgICAgc2VsZiA9IHtcclxuICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAobGlzdCkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xyXG4gICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcclxuICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG1lbW9yeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIChmdW5jdGlvbiBhZGQoYXJncykge1xyXG4gICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChfLCBhcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhcmcpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZShhcmcpICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcclxuICAgICAgICAgICAgICAgICAgYWRkKGFyZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcclxuICAgICAgICAgICAgICBmaXJlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGpRdWVyeS5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKF8sIGFyZykge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgIHdoaWxlICgoaW5kZXggPSBqUXVlcnkuaW5BcnJheShhcmcsIGxpc3QsIGluZGV4KSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXHJcbiAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IGZpcmluZ0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxyXG4gICAgICAgIC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxyXG4gICAgICAgIGhhczogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICByZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheShmbiwgbGlzdCkgPiAtMSA6IGxpc3QubGVuZ3RoID4gMDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChsaXN0KSB7XHJcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcclxuICAgICAgICAvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcclxuICAgICAgICAvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcclxuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gIWxpc3Q7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGlzYWJsZSAuZmlyZVxyXG4gICAgICAgIC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXHJcbiAgICAgICAgLy8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xyXG4gICAgICAgIGxvY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XHJcbiAgICAgICAgICBpZiAoIW1lbW9yeSAmJiAhZmlyaW5nKSB7XHJcbiAgICAgICAgICAgIGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXHJcbiAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7XHJcbiAgICAgICAgICBpZiAoIWxvY2tlZCkge1xyXG4gICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcclxuICAgICAgICAgICAgYXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goYXJncyk7XHJcbiAgICAgICAgICAgIGlmICghZmlyaW5nKSB7XHJcbiAgICAgICAgICAgICAgZmlyZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNlbGYuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxyXG4gICAgICAgIGZpcmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gISFmaXJlZDtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgIHJldHVybiBzZWxmO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIElkZW50aXR5KHYpIHtcclxuICAgIHJldHVybiB2O1xyXG4gIH1cclxuICBmdW5jdGlvbiBUaHJvd2VyKGV4KSB7XHJcbiAgICB0aHJvdyBleDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkb3B0VmFsdWUodmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSkge1xyXG4gICAgdmFyIG1ldGhvZDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXHJcbiAgICAgIGlmICh2YWx1ZSAmJiBpc0Z1bmN0aW9uKChtZXRob2QgPSB2YWx1ZS5wcm9taXNlKSkpIHtcclxuICAgICAgICBtZXRob2QuY2FsbCh2YWx1ZSkuZG9uZShyZXNvbHZlKS5mYWlsKHJlamVjdCk7XHJcblxyXG4gICAgICAgIC8vIE90aGVyIHRoZW5hYmxlc1xyXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24oKG1ldGhvZCA9IHZhbHVlLnRoZW4pKSkge1xyXG4gICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xyXG5cclxuICAgICAgICAvLyBPdGhlciBub24tdGhlbmFibGVzXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxyXG4gICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcclxuICAgICAgICAvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxyXG4gICAgICAgIHJlc29sdmUuYXBwbHkodW5kZWZpbmVkLCBbdmFsdWVdLnNsaWNlKG5vVmFsdWUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXHJcbiAgICAgIC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cclxuICAgICAgLy8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cclxuICAgIH0gY2F0Y2ggKHZhbHVlKSB7XHJcbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcclxuICAgICAgLy8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxyXG4gICAgICByZWplY3QuYXBwbHkodW5kZWZpbmVkLCBbdmFsdWVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgRGVmZXJyZWQ6IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgIHZhciB0dXBsZXMgPSBbXHJcbiAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxyXG4gICAgICAgICAgLy8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxyXG4gICAgICAgICAgW1xyXG4gICAgICAgICAgICBcIm5vdGlmeVwiLFxyXG4gICAgICAgICAgICBcInByb2dyZXNzXCIsXHJcbiAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIiksXHJcbiAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIiksXHJcbiAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgW1xyXG4gICAgICAgICAgICBcInJlc29sdmVcIixcclxuICAgICAgICAgICAgXCJkb25lXCIsXHJcbiAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBcInJlc29sdmVkXCIsXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgW1xyXG4gICAgICAgICAgICBcInJlamVjdFwiLFxyXG4gICAgICAgICAgICBcImZhaWxcIixcclxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxyXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXHJcbiAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxyXG4gICAgICAgIHByb21pc2UgPSB7XHJcbiAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNhdGNoOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihudWxsLCBmbik7XHJcbiAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uICgvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLykge1xyXG4gICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeVxyXG4gICAgICAgICAgICAgIC5EZWZlcnJlZChmdW5jdGlvbiAobmV3RGVmZXIpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKF9pLCB0dXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcclxuICAgICAgICAgICAgICAgICAgdmFyIGZuID0gaXNGdW5jdGlvbihmbnNbdHVwbGVbNF1dKSAmJiBmbnNbdHVwbGVbNF1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxyXG4gICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxyXG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVsxXV0oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkICYmIGlzRnVuY3Rpb24ocmV0dXJuZWQucHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9taXNlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKG5ld0RlZmVyLm5vdGlmeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbmUobmV3RGVmZXIucmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwobmV3RGVmZXIucmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbdHVwbGVbMF0gKyBcIldpdGhcIl0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID8gW3JldHVybmVkXSA6IGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBmbnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLnByb21pc2UoKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgdmFyIG1heERlcHRoID0gMDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZShkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgICBtaWdodFRocm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8IG1heERlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkodGhhdCwgYXJncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2VcclxuICAgICAgICAgICAgICAgICAgICB0aGVuID1cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQudGhlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElkZW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSBJZGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gW3JldHVybmVkXTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcclxuICAgICAgICAgICAgICAgICAgICAgIChzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoKSh0aGF0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3BlY2lhbFxyXG4gICAgICAgICAgICAgICAgICAgID8gbWlnaHRUaHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCArIDEgPj0gbWF4RGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IFRocm93ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKHRoYXQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcclxuICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cclxuICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xyXG4gICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChwcm9jZXNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5XHJcbiAgICAgICAgICAgICAgLkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxyXG4gICAgICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmFkZChcclxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24ob25Qcm9ncmVzcykgPyBvblByb2dyZXNzIDogSWRlbnRpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIubm90aWZ5V2l0aFxyXG4gICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXHJcbiAgICAgICAgICAgICAgICB0dXBsZXNbMV1bM10uYWRkKFxyXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IElkZW50aXR5XHJcbiAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxyXG4gICAgICAgICAgICAgICAgdHVwbGVzWzJdWzNdLmFkZChcclxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24ob25SZWplY3RlZCkgPyBvblJlamVjdGVkIDogVGhyb3dlclxyXG4gICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLnByb21pc2UoKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxyXG4gICAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxyXG4gICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKG9iaiwgcHJvbWlzZSkgOiBwcm9taXNlO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlZmVycmVkID0ge307XHJcblxyXG4gICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXHJcbiAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKGksIHR1cGxlKSB7XHJcbiAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsyXSxcclxuICAgICAgICAgIHN0YXRlU3RyaW5nID0gdHVwbGVbNV07XHJcblxyXG4gICAgICAgIC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxyXG4gICAgICAgIC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXHJcbiAgICAgICAgLy8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcclxuICAgICAgICBwcm9taXNlW3R1cGxlWzFdXSA9IGxpc3QuYWRkO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgc3RhdGVcclxuICAgICAgICBpZiAoc3RhdGVTdHJpbmcpIHtcclxuICAgICAgICAgIGxpc3QuYWRkKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcclxuICAgICAgICAgICAgICAvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxyXG4gICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdHJpbmc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxyXG4gICAgICAgICAgICAvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcclxuICAgICAgICAgICAgdHVwbGVzWzMgLSBpXVsyXS5kaXNhYmxlLFxyXG5cclxuICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxyXG4gICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxyXG4gICAgICAgICAgICB0dXBsZXNbMyAtIGldWzNdLmRpc2FibGUsXHJcblxyXG4gICAgICAgICAgICAvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xyXG4gICAgICAgICAgICB0dXBsZXNbMF1bMl0ubG9jayxcclxuXHJcbiAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcclxuICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmxvY2tcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXHJcbiAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcclxuICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXHJcbiAgICAgICAgbGlzdC5hZGQodHVwbGVbM10uZmlyZSk7XHJcblxyXG4gICAgICAgIC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxyXG4gICAgICAgIC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XHJcbiAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XHJcbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF1dID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0oXHJcbiAgICAgICAgICAgIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcyxcclxuICAgICAgICAgICAgYXJndW1lbnRzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcclxuICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcclxuICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxyXG4gICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXCJXaXRoXCJdID0gbGlzdC5maXJlV2l0aDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcclxuICAgICAgcHJvbWlzZS5wcm9taXNlKGRlZmVycmVkKTtcclxuXHJcbiAgICAgIC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcclxuICAgICAgaWYgKGZ1bmMpIHtcclxuICAgICAgICBmdW5jLmNhbGwoZGVmZXJyZWQsIGRlZmVycmVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxsIGRvbmUhXHJcbiAgICAgIHJldHVybiBkZWZlcnJlZDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVmZXJyZWQgaGVscGVyXHJcbiAgICB3aGVuOiBmdW5jdGlvbiAoc2luZ2xlVmFsdWUpIHtcclxuICAgICAgdmFyIC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xyXG4gICAgICAgIHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgLy8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXHJcbiAgICAgICAgaSA9IHJlbWFpbmluZyxcclxuICAgICAgICAvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXHJcbiAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoaSksXHJcbiAgICAgICAgcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkXHJcbiAgICAgICAgbWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXHJcbiAgICAgICAgLy8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxyXG4gICAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlQ29udGV4dHNbaV0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXNvbHZlVmFsdWVzW2ldID1cclxuICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoYXJndW1lbnRzKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKSB7XHJcbiAgICAgICAgICAgICAgbWFzdGVyLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxyXG4gICAgICBpZiAocmVtYWluaW5nIDw9IDEpIHtcclxuICAgICAgICBhZG9wdFZhbHVlKFxyXG4gICAgICAgICAgc2luZ2xlVmFsdWUsXHJcbiAgICAgICAgICBtYXN0ZXIuZG9uZSh1cGRhdGVGdW5jKGkpKS5yZXNvbHZlLFxyXG4gICAgICAgICAgbWFzdGVyLnJlamVjdCxcclxuICAgICAgICAgICFyZW1haW5pbmdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XHJcbiAgICAgICAgICBpc0Z1bmN0aW9uKHJlc29sdmVWYWx1ZXNbaV0gJiYgcmVzb2x2ZVZhbHVlc1tpXS50aGVuKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIG1hc3Rlci50aGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgYWRvcHRWYWx1ZShyZXNvbHZlVmFsdWVzW2ldLCB1cGRhdGVGdW5jKGkpLCBtYXN0ZXIucmVqZWN0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICAvLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcclxuICAvLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cclxuICB2YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcclxuXHJcbiAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiAoZXJyb3IsIHN0YWNrKSB7XHJcbiAgICAvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XHJcbiAgICAvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxyXG4gICAgaWYgKFxyXG4gICAgICB3aW5kb3cuY29uc29sZSAmJlxyXG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuICYmXHJcbiAgICAgIGVycm9yICYmXHJcbiAgICAgIHJlcnJvck5hbWVzLnRlc3QoZXJyb3IubmFtZSlcclxuICAgICkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKFxyXG4gICAgICAgIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIGVycm9yLnN0YWNrLFxyXG4gICAgICAgIHN0YWNrXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XHJcbiAgdmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xyXG5cclxuICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHJlYWR5TGlzdFxyXG4gICAgICAudGhlbihmbilcclxuXHJcbiAgICAgIC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXHJcbiAgICAgIC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xyXG4gICAgICAvLyByZWdpc3RyYXRpb24uXHJcbiAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oZXJyb3IpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXHJcbiAgICBpc1JlYWR5OiBmYWxzZSxcclxuXHJcbiAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXHJcbiAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxyXG4gICAgcmVhZHlXYWl0OiAxLFxyXG5cclxuICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcclxuICAgIHJlYWR5OiBmdW5jdGlvbiAod2FpdCkge1xyXG4gICAgICAvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XHJcbiAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxyXG4gICAgICBqUXVlcnkuaXNSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxyXG4gICAgICBpZiAod2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXHJcbiAgICAgIHJlYWR5TGlzdC5yZXNvbHZlV2l0aChkb2N1bWVudCwgW2pRdWVyeV0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcclxuXHJcbiAgLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcclxuICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQpO1xyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCk7XHJcbiAgICBqUXVlcnkucmVhZHkoKTtcclxuICB9XHJcblxyXG4gIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXHJcbiAgLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXHJcbiAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxyXG4gIC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxyXG4gIGlmIChcclxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxyXG4gICAgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpXHJcbiAgKSB7XHJcbiAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCk7XHJcblxyXG4gICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQpO1xyXG4gIH1cclxuXHJcbiAgLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXHJcbiAgLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXHJcbiAgdmFyIGFjY2VzcyA9IGZ1bmN0aW9uIChlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdykge1xyXG4gICAgdmFyIGkgPSAwLFxyXG4gICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXHJcbiAgICAgIGJ1bGsgPSBrZXkgPT0gbnVsbDtcclxuXHJcbiAgICAvLyBTZXRzIG1hbnkgdmFsdWVzXHJcbiAgICBpZiAodG9UeXBlKGtleSkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcclxuICAgICAgZm9yIChpIGluIGtleSkge1xyXG4gICAgICAgIGFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldHMgb25lIHZhbHVlXHJcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByYXcgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYnVsaykge1xyXG4gICAgICAgIC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxyXG4gICAgICAgIGlmIChyYXcpIHtcclxuICAgICAgICAgIGZuLmNhbGwoZWxlbXMsIHZhbHVlKTtcclxuICAgICAgICAgIGZuID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJ1bGsgPSBmbjtcclxuICAgICAgICAgIGZuID0gZnVuY3Rpb24gKGVsZW0sIF9rZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWxrLmNhbGwoalF1ZXJ5KGVsZW0pLCB2YWx1ZSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgZm4oXHJcbiAgICAgICAgICAgIGVsZW1zW2ldLFxyXG4gICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGFpbmFibGUpIHtcclxuICAgICAgcmV0dXJuIGVsZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHNcclxuICAgIGlmIChidWxrKSB7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGVuID8gZm4oZWxlbXNbMF0sIGtleSkgOiBlbXB0eUdldDtcclxuICB9O1xyXG5cclxuICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcclxuICB2YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcclxuICAgIHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcclxuXHJcbiAgLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXHJcbiAgZnVuY3Rpb24gZmNhbWVsQ2FzZShfYWxsLCBsZXR0ZXIpIHtcclxuICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcclxuICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XHJcbiAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxyXG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShybXNQcmVmaXgsIFwibXMtXCIpLnJlcGxhY2UocmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSk7XHJcbiAgfVxyXG4gIHZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAvLyBBY2NlcHRzIG9ubHk6XHJcbiAgICAvLyAgLSBOb2RlXHJcbiAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxyXG4gICAgLy8gIC0gT2JqZWN0XHJcbiAgICAvLyAgICAtIEFueVxyXG4gICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICErb3duZXIubm9kZVR5cGU7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gRGF0YSgpIHtcclxuICAgIHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcclxuICB9XHJcblxyXG4gIERhdGEudWlkID0gMTtcclxuXHJcbiAgRGF0YS5wcm90b3R5cGUgPSB7XHJcbiAgICBjYWNoZTogZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxyXG4gICAgICB2YXIgdmFsdWUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xyXG5cclxuICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IHt9O1xyXG5cclxuICAgICAgICAvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2VycyxcclxuICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxyXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxyXG4gICAgICAgIGlmIChhY2NlcHREYXRhKG93bmVyKSkge1xyXG4gICAgICAgICAgLy8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxyXG4gICAgICAgICAgLy8gdXNlIHBsYWluIGFzc2lnbm1lbnRcclxuICAgICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICBvd25lclt0aGlzLmV4cGFuZG9dID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcclxuICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcclxuICAgICAgICAgICAgLy8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcclxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChvd25lciwgZGF0YSwgdmFsdWUpIHtcclxuICAgICAgdmFyIHByb3AsXHJcbiAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlKG93bmVyKTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcclxuICAgICAgLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjYWNoZVtjYW1lbENhc2UoZGF0YSldID0gdmFsdWU7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcclxuICAgICAgICBmb3IgKHByb3AgaW4gZGF0YSkge1xyXG4gICAgICAgICAgY2FjaGVbY2FtZWxDYXNlKHByb3ApXSA9IGRhdGFbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYWNoZTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIChvd25lciwga2V5KSB7XHJcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gdGhpcy5jYWNoZShvd25lcilcclxuICAgICAgICA6IC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcclxuICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gJiYgb3duZXJbdGhpcy5leHBhbmRvXVtjYW1lbENhc2Uoa2V5KV07XHJcbiAgICB9LFxyXG4gICAgYWNjZXNzOiBmdW5jdGlvbiAob3duZXIsIGtleSwgdmFsdWUpIHtcclxuICAgICAgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxyXG4gICAgICAvL1xyXG4gICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcclxuICAgICAgLy8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxyXG4gICAgICAvL1xyXG4gICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XHJcbiAgICAgIC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcclxuICAgICAgLy9cclxuICAgICAgaWYgKFxyXG4gICAgICAgIGtleSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcclxuICAgICAgLy8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcclxuICAgICAgLy8gICAyLiBBIGtleSBhbmQgdmFsdWVcclxuICAgICAgLy9cclxuICAgICAgdGhpcy5zZXQob3duZXIsIGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgLy8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXHJcbiAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxyXG4gICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG93bmVyLCBrZXkpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgY2FjaGUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xyXG5cclxuICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xyXG4gICAgICAgICAgLy8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cclxuICAgICAgICAgIC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxyXG4gICAgICAgICAga2V5ID0ga2V5Lm1hcChjYW1lbENhc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBrZXkgPSBjYW1lbENhc2Uoa2V5KTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXHJcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxyXG4gICAgICAgICAga2V5ID0ga2V5IGluIGNhY2hlID8gW2tleV0gOiBrZXkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpID0ga2V5Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgZGVsZXRlIGNhY2hlW2tleVtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcclxuICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KGNhY2hlKSkge1xyXG4gICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcclxuICAgICAgICAvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xyXG4gICAgICAgIC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcclxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxyXG4gICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgb3duZXJbdGhpcy5leHBhbmRvXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVsZXRlIG93bmVyW3RoaXMuZXhwYW5kb107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaGFzRGF0YTogZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgIHZhciBjYWNoZSA9IG93bmVyW3RoaXMuZXhwYW5kb107XHJcbiAgICAgIHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSk7XHJcbiAgICB9LFxyXG4gIH07XHJcbiAgdmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcclxuXHJcbiAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcclxuXHJcbiAgLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcclxuICAvL1xyXG4gIC8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXHJcbiAgLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxyXG4gIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cclxuICAvL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cclxuICAvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxyXG4gIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcclxuICAvL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XHJcblxyXG4gIHZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXHJcbiAgICBybXVsdGlEYXNoID0gL1tBLVpdL2c7XHJcblxyXG4gIGZ1bmN0aW9uIGdldERhdGEoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhID09PSBcImZhbHNlXCIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhID09PSBcIm51bGxcIikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xyXG4gICAgaWYgKGRhdGEgPT09ICtkYXRhICsgXCJcIikge1xyXG4gICAgICByZXR1cm4gK2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJicmFjZS50ZXN0KGRhdGEpKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGF0YUF0dHIoZWxlbSwga2V5LCBkYXRhKSB7XHJcbiAgICB2YXIgbmFtZTtcclxuXHJcbiAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XHJcbiAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcclxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2Uocm11bHRpRGFzaCwgXCItJCZcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRhdGEgPSBnZXREYXRhKGRhdGEpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxyXG4gICAgICAgIGRhdGFVc2VyLnNldChlbGVtLCBrZXksIGRhdGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICBoYXNEYXRhOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICByZXR1cm4gZGF0YVVzZXIuaGFzRGF0YShlbGVtKSB8fCBkYXRhUHJpdi5oYXNEYXRhKGVsZW0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBkYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgZGF0YSkge1xyXG4gICAgICByZXR1cm4gZGF0YVVzZXIuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xyXG4gICAgICBkYXRhVXNlci5yZW1vdmUoZWxlbSwgbmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcbiAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cclxuICAgIF9kYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgZGF0YSkge1xyXG4gICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcclxuICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIG5hbWUpO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICBkYXRhOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgZWxlbSA9IHRoaXNbMF0sXHJcbiAgICAgICAgYXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcclxuXHJcbiAgICAgIC8vIEdldHMgYWxsIHZhbHVlc1xyXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgIGRhdGEgPSBkYXRhVXNlci5nZXQoZWxlbSk7XHJcblxyXG4gICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiKSkge1xyXG4gICAgICAgICAgICBpID0gYXR0cnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxyXG4gICAgICAgICAgICAgIC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxyXG4gICAgICAgICAgICAgIGlmIChhdHRyc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lLnNsaWNlKDUpKTtcclxuICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoZWxlbSwgbmFtZSwgZGF0YVtuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFQcml2LnNldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xyXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZGF0YVVzZXIuc2V0KHRoaXMsIGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhY2Nlc3MoXHJcbiAgICAgICAgdGhpcyxcclxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgIHZhciBkYXRhO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XHJcbiAgICAgICAgICAvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxyXG4gICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcclxuICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcclxuICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXHJcbiAgICAgICAgICBpZiAoZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldChlbGVtLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXHJcbiAgICAgICAgICAgIC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGFBdHRyKGVsZW0sIGtleSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXHJcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XHJcbiAgICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSxcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkYXRhVXNlci5yZW1vdmUodGhpcywga2V5KTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgIHF1ZXVlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgZGF0YSkge1xyXG4gICAgICB2YXIgcXVldWU7XHJcblxyXG4gICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgIHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xyXG4gICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KGVsZW0sIHR5cGUpO1xyXG5cclxuICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgIGlmICghcXVldWUgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICBxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyhlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXF1ZXVlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSkge1xyXG4gICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG4gICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoZWxlbSwgdHlwZSksXHJcbiAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXHJcbiAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIHR5cGUpLFxyXG4gICAgICAgIG5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBqUXVlcnkuZGVxdWV1ZShlbGVtLCB0eXBlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxyXG4gICAgICBpZiAoZm4gPT09IFwiaW5wcm9ncmVzc1wiKSB7XHJcbiAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIHN0YXJ0TGVuZ3RoLS07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmbikge1xyXG4gICAgICAgIC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcclxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZnhcIikge1xyXG4gICAgICAgICAgcXVldWUudW5zaGlmdChcImlucHJvZ3Jlc3NcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXHJcbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XHJcbiAgICAgICAgZm4uY2FsbChlbGVtLCBuZXh0LCBob29rcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc3RhcnRMZW5ndGggJiYgaG9va3MpIHtcclxuICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcclxuICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiAoZWxlbSwgdHlwZSkge1xyXG4gICAgICB2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIGRhdGFQcml2LmdldChlbGVtLCBrZXkpIHx8XHJcbiAgICAgICAgZGF0YVByaXYuYWNjZXNzKGVsZW0sIGtleSwge1xyXG4gICAgICAgICAgZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgW3R5cGUgKyBcInF1ZXVlXCIsIGtleV0pO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgcXVldWU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XHJcbiAgICAgIHZhciBzZXR0ZXIgPSAyO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgZGF0YSA9IHR5cGU7XHJcbiAgICAgICAgdHlwZSA9IFwiZnhcIjtcclxuICAgICAgICBzZXR0ZXItLTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIpIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKHRoaXNbMF0sIHR5cGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB0aGlzXHJcbiAgICAgICAgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxyXG4gICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3ModGhpcywgdHlwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xyXG4gICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBkZXF1ZXVlOiBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSB8fCBcImZ4XCIsIFtdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxyXG4gICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXHJcbiAgICBwcm9taXNlOiBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XHJcbiAgICAgIHZhciB0bXAsXHJcbiAgICAgICAgY291bnQgPSAxLFxyXG4gICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXHJcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxyXG4gICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKCEtLWNvdW50KSB7XHJcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmVXaXRoKGVsZW1lbnRzLCBbZWxlbWVudHNdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgb2JqID0gdHlwZTtcclxuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcclxuXHJcbiAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoZWxlbWVudHNbaV0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIik7XHJcbiAgICAgICAgaWYgKHRtcCAmJiB0bXAuZW1wdHkpIHtcclxuICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICB0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXNvbHZlKCk7XHJcbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKG9iaik7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIHZhciBwbnVtID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlO1xyXG5cclxuICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpO1xyXG5cclxuICB2YXIgY3NzRXhwYW5kID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdO1xyXG5cclxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICB2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKTtcclxuICAgIH0sXHJcbiAgICBjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcclxuXHJcbiAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcclxuICAvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcclxuICAvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcclxuICAvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXHJcbiAgLy8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXHJcbiAgaWYgKGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSkge1xyXG4gICAgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkgfHxcclxuICAgICAgICBlbGVtLmdldFJvb3ROb2RlKGNvbXBvc2VkKSA9PT0gZWxlbS5vd25lckRvY3VtZW50XHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24gKGVsZW0sIGVsKSB7XHJcbiAgICAvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcclxuICAgIC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxyXG4gICAgZWxlbSA9IGVsIHx8IGVsZW07XHJcblxyXG4gICAgLy8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcclxuICAgICAgKGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcclxuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxyXG4gICAgICAgIC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xyXG4gICAgICAgIC8vIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAgICBpc0F0dGFjaGVkKGVsZW0pICYmXHJcbiAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiKVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhZGp1c3RDU1MoZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4pIHtcclxuICAgIHZhciBhZGp1c3RlZCxcclxuICAgICAgc2NhbGUsXHJcbiAgICAgIG1heEl0ZXJhdGlvbnMgPSAyMCxcclxuICAgICAgY3VycmVudFZhbHVlID0gdHdlZW5cclxuICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmN1cigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNzcyhlbGVtLCBwcm9wLCBcIlwiKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgIGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcclxuICAgICAgdW5pdCA9XHJcbiAgICAgICAgKHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1szXSkgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKSxcclxuICAgICAgLy8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcclxuICAgICAgaW5pdGlhbEluVW5pdCA9XHJcbiAgICAgICAgZWxlbS5ub2RlVHlwZSAmJlxyXG4gICAgICAgIChqUXVlcnkuY3NzTnVtYmVyW3Byb3BdIHx8ICh1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwpKSAmJlxyXG4gICAgICAgIHJjc3NOdW0uZXhlYyhqUXVlcnkuY3NzKGVsZW0sIHByb3ApKTtcclxuXHJcbiAgICBpZiAoaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WzNdICE9PSB1bml0KSB7XHJcbiAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxyXG4gICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXHJcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsIC8gMjtcclxuXHJcbiAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcclxuICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFszXTtcclxuXHJcbiAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xyXG5cclxuICAgICAgd2hpbGUgKG1heEl0ZXJhdGlvbnMtLSkge1xyXG4gICAgICAgIC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXHJcbiAgICAgICAgLy8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxyXG4gICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgKDEgLSBzY2FsZSkgKiAoMSAtIChzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUpKSA8PVxyXG4gICAgICAgICAgMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcclxuICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0KTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cclxuICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZhbHVlUGFydHMpIHtcclxuICAgICAgaW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XHJcblxyXG4gICAgICAvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcclxuICAgICAgYWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWzFdXHJcbiAgICAgICAgPyBpbml0aWFsSW5Vbml0ICsgKHZhbHVlUGFydHNbMV0gKyAxKSAqIHZhbHVlUGFydHNbMl1cclxuICAgICAgICA6ICt2YWx1ZVBhcnRzWzJdO1xyXG4gICAgICBpZiAodHdlZW4pIHtcclxuICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcclxuICAgICAgICB0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XHJcbiAgICAgICAgdHdlZW4uZW5kID0gYWRqdXN0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhZGp1c3RlZDtcclxuICB9XHJcblxyXG4gIHZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheShlbGVtKSB7XHJcbiAgICB2YXIgdGVtcCxcclxuICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxyXG4gICAgICBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXHJcbiAgICAgIGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFtub2RlTmFtZV07XHJcblxyXG4gICAgaWYgKGRpc3BsYXkpIHtcclxuICAgICAgcmV0dXJuIGRpc3BsYXk7XHJcbiAgICB9XHJcblxyXG4gICAgdGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKSk7XHJcbiAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyh0ZW1wLCBcImRpc3BsYXlcIik7XHJcblxyXG4gICAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xyXG5cclxuICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xyXG4gICAgICBkaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdERpc3BsYXlNYXBbbm9kZU5hbWVdID0gZGlzcGxheTtcclxuXHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XHJcbiAgICB2YXIgZGlzcGxheSxcclxuICAgICAgZWxlbSxcclxuICAgICAgdmFsdWVzID0gW10sXHJcbiAgICAgIGluZGV4ID0gMCxcclxuICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxyXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGVsZW0gPSBlbGVtZW50c1tpbmRleF07XHJcbiAgICAgIGlmICghZWxlbS5zdHlsZSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcclxuICAgICAgICAvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcclxuICAgICAgICAvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXHJcbiAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZGlzcGxheVwiKSB8fCBudWxsO1xyXG4gICAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKGVsZW0pKSB7XHJcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZ2V0RGVmYXVsdERpc3BsYXkoZWxlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChkaXNwbGF5ICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IFwibm9uZVwiO1xyXG5cclxuICAgICAgICAgIC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcclxuICAgICAgICAgIGRhdGFQcml2LnNldChlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xyXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGlmICh2YWx1ZXNbaW5kZXhdICE9IG51bGwpIHtcclxuICAgICAgICBlbGVtZW50c1tpbmRleF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1tpbmRleF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIHRvZ2dsZTogZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGlzSGlkZGVuV2l0aGluVHJlZSh0aGlzKSkge1xyXG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuICB2YXIgcmNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcclxuXHJcbiAgdmFyIHJ0YWdOYW1lID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pO1xyXG5cclxuICB2YXIgcnNjcmlwdFR5cGUgPSAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pO1xyXG5cclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxyXG4gICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcclxuICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcblxyXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxyXG4gICAgLy8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcclxuICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcclxuICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxyXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpO1xyXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIik7XHJcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKTtcclxuXHJcbiAgICBkaXYuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxyXG4gICAgLy8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXHJcbiAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcclxuICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXHJcbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XHJcbiAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XHJcblxyXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAgIC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXHJcbiAgICAvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXHJcbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xyXG4gICAgc3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcclxuICB2YXIgd3JhcE1hcCA9IHtcclxuICAgIC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXHJcbiAgICAvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXHJcbiAgICAvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXHJcbiAgICB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxyXG4gICAgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sXHJcbiAgICB0cjogWzIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxyXG4gICAgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxcclxuXHJcbiAgICBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdLFxyXG4gIH07XHJcblxyXG4gIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9XHJcbiAgICB3cmFwTWFwLnRoZWFkO1xyXG4gIHdyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xyXG5cclxuICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxyXG4gIGlmICghc3VwcG9ydC5vcHRpb24pIHtcclxuICAgIHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFtcclxuICAgICAgMSxcclxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXHJcbiAgICAgIFwiPC9zZWxlY3Q+XCIsXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWxsKGNvbnRleHQsIHRhZykge1xyXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxyXG4gICAgLy8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxyXG4gICAgdmFyIHJldDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgcmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcgfHwgXCIqXCIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcgfHwgXCIqXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkIHx8ICh0YWcgJiYgbm9kZU5hbWUoY29udGV4dCwgdGFnKSkpIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbY29udGV4dF0sIHJldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxyXG4gIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XHJcbiAgICB2YXIgaSA9IDAsXHJcbiAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XHJcblxyXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgZGF0YVByaXYuc2V0KFxyXG4gICAgICAgIGVsZW1zW2ldLFxyXG4gICAgICAgIFwiZ2xvYmFsRXZhbFwiLFxyXG4gICAgICAgICFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xyXG5cclxuICBmdW5jdGlvbiBidWlsZEZyYWdtZW50KGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQpIHtcclxuICAgIHZhciBlbGVtLFxyXG4gICAgICB0bXAsXHJcbiAgICAgIHRhZyxcclxuICAgICAgd3JhcCxcclxuICAgICAgYXR0YWNoZWQsXHJcbiAgICAgIGosXHJcbiAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcbiAgICAgIG5vZGVzID0gW10sXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBsID0gZWxlbXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGVsZW0gPSBlbGVtc1tpXTtcclxuXHJcbiAgICAgIGlmIChlbGVtIHx8IGVsZW0gPT09IDApIHtcclxuICAgICAgICAvLyBBZGQgbm9kZXMgZGlyZWN0bHlcclxuICAgICAgICBpZiAodG9UeXBlKGVsZW0pID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcclxuICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcclxuICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgZWxlbS5ub2RlVHlwZSA/IFtlbGVtXSA6IGVsZW0pO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcclxuICAgICAgICAgIG5vZGVzLnB1c2goY29udGV4dC5jcmVhdGVUZXh0Tm9kZShlbGVtKSk7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG5cclxuICAgICAgICAgIC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgIHRhZyA9IChydGFnTmFtZS5leGVjKGVsZW0pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgIHdyYXAgPSB3cmFwTWFwW3RhZ10gfHwgd3JhcE1hcC5fZGVmYXVsdDtcclxuICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSB3cmFwWzFdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoZWxlbSkgKyB3cmFwWzJdO1xyXG5cclxuICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxyXG4gICAgICAgICAgaiA9IHdyYXBbMF07XHJcbiAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XHJcbiAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIHRtcC5jaGlsZE5vZGVzKTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxyXG4gICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXHJcbiAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcclxuICAgIGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcclxuXHJcbiAgICBpID0gMDtcclxuICAgIHdoaWxlICgoZWxlbSA9IG5vZGVzW2krK10pKSB7XHJcbiAgICAgIC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXHJcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoZWxlbSwgc2VsZWN0aW9uKSA+IC0xKSB7XHJcbiAgICAgICAgaWYgKGlnbm9yZWQpIHtcclxuICAgICAgICAgIGlnbm9yZWQucHVzaChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF0dGFjaGVkID0gaXNBdHRhY2hlZChlbGVtKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxyXG4gICAgICB0bXAgPSBnZXRBbGwoZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbSksIFwic2NyaXB0XCIpO1xyXG5cclxuICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxyXG4gICAgICBpZiAoYXR0YWNoZWQpIHtcclxuICAgICAgICBzZXRHbG9iYWxFdmFsKHRtcCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcclxuICAgICAgaWYgKHNjcmlwdHMpIHtcclxuICAgICAgICBqID0gMDtcclxuICAgICAgICB3aGlsZSAoKGVsZW0gPSB0bXBbaisrXSkpIHtcclxuICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KGVsZW0udHlwZSB8fCBcIlwiKSkge1xyXG4gICAgICAgICAgICBzY3JpcHRzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZyYWdtZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIHJrZXlFdmVudCA9IC9ea2V5LyxcclxuICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxyXG4gICAgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xyXG5cclxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xyXG4gIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cclxuICAvLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcclxuICAvLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cclxuICAvLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXHJcbiAgLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxyXG4gIGZ1bmN0aW9uIGV4cGVjdFN5bmMoZWxlbSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIChlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpKSA9PT0gKHR5cGUgPT09IFwiZm9jdXNcIik7XHJcbiAgfVxyXG5cclxuICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxyXG4gIC8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcclxuICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcclxuICBmdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb24oZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKSB7XHJcbiAgICB2YXIgb3JpZ0ZuLCB0eXBlO1xyXG5cclxuICAgIC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxyXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xyXG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xyXG4gICAgICAgIG9uKGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1t0eXBlXSwgb25lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZWxlbTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwpIHtcclxuICAgICAgLy8gKCB0eXBlcywgZm4gKVxyXG4gICAgICBmbiA9IHNlbGVjdG9yO1xyXG4gICAgICBkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKGZuID09IG51bGwpIHtcclxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXHJcbiAgICAgICAgZm4gPSBkYXRhO1xyXG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxyXG4gICAgICAgIGZuID0gZGF0YTtcclxuICAgICAgICBkYXRhID0gc2VsZWN0b3I7XHJcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChmbiA9PT0gZmFsc2UpIHtcclxuICAgICAgZm4gPSByZXR1cm5GYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoIWZuKSB7XHJcbiAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvbmUgPT09IDEpIHtcclxuICAgICAgb3JpZ0ZuID0gZm47XHJcbiAgICAgIGZuID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXHJcbiAgICAgICAgalF1ZXJ5KCkub2ZmKGV2ZW50KTtcclxuICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxyXG4gICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgalF1ZXJ5LmV2ZW50LmFkZCh0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXHJcbiAgICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cclxuICAgKi9cclxuICBqUXVlcnkuZXZlbnQgPSB7XHJcbiAgICBnbG9iYWw6IHt9LFxyXG5cclxuICAgIGFkZDogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3Rvcikge1xyXG4gICAgICB2YXIgaGFuZGxlT2JqSW4sXHJcbiAgICAgICAgZXZlbnRIYW5kbGUsXHJcbiAgICAgICAgdG1wLFxyXG4gICAgICAgIGV2ZW50cyxcclxuICAgICAgICB0LFxyXG4gICAgICAgIGhhbmRsZU9iaixcclxuICAgICAgICBzcGVjaWFsLFxyXG4gICAgICAgIGhhbmRsZXJzLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbmFtZXNwYWNlcyxcclxuICAgICAgICBvcmlnVHlwZSxcclxuICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2LmdldChlbGVtKTtcclxuXHJcbiAgICAgIC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcclxuICAgICAgaWYgKCFhY2NlcHREYXRhKGVsZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcclxuICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlcikge1xyXG4gICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcclxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcclxuICAgICAgICBzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXHJcbiAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxyXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZG9jdW1lbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxyXG4gICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgIGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcclxuICAgICAgaWYgKCEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xyXG4gICAgICAgIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpKSB7XHJcbiAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcclxuICAgICAgICAgIC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcclxuICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZVxyXG4gICAgICAgICAgICA/IGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseShlbGVtLCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcclxuICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xyXG4gICAgICB0ID0gdHlwZXMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAodC0tKSB7XHJcbiAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XHJcbiAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xyXG4gICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCk7XHJcblxyXG4gICAgICAgIC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcclxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcblxyXG4gICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxyXG4gICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcclxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcblxyXG4gICAgICAgIC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgaGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZChcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxyXG4gICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcclxuICAgICAgICAgICAgbmVlZHNDb250ZXh0OlxyXG4gICAgICAgICAgICAgIHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9yKSxcclxuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGhhbmRsZU9iakluXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcclxuICAgICAgICBpZiAoIShoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSkpIHtcclxuICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIXNwZWNpYWwuc2V0dXAgfHxcclxuICAgICAgICAgICAgc3BlY2lhbC5zZXR1cC5jYWxsKGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSA9PT0gZmFsc2VcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XHJcbiAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XHJcblxyXG4gICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxyXG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxyXG4gICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcykge1xyXG4gICAgICB2YXIgaixcclxuICAgICAgICBvcmlnQ291bnQsXHJcbiAgICAgICAgdG1wLFxyXG4gICAgICAgIGV2ZW50cyxcclxuICAgICAgICB0LFxyXG4gICAgICAgIGhhbmRsZU9iaixcclxuICAgICAgICBzcGVjaWFsLFxyXG4gICAgICAgIGhhbmRsZXJzLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgbmFtZXNwYWNlcyxcclxuICAgICAgICBvcmlnVHlwZSxcclxuICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoZWxlbSkgJiYgZGF0YVByaXYuZ2V0KGVsZW0pO1xyXG5cclxuICAgICAgaWYgKCFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcclxuICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xyXG4gICAgICB0ID0gdHlwZXMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAodC0tKSB7XHJcbiAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XHJcbiAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xyXG4gICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCk7XHJcblxyXG4gICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUgKyB0eXBlc1t0XSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcbiAgICAgICAgdHlwZSA9IChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkgfHwgdHlwZTtcclxuICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcclxuICAgICAgICB0bXAgPVxyXG4gICAgICAgICAgdG1wWzJdICYmXHJcbiAgICAgICAgICBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXHJcbiAgICAgICAgb3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tqXTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIChtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlKSAmJlxyXG4gICAgICAgICAgICAoIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCkgJiZcclxuICAgICAgICAgICAgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXHJcbiAgICAgICAgICAgICghc2VsZWN0b3IgfHxcclxuICAgICAgICAgICAgICBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgKHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yKSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaiwgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlT2JqLnNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xyXG4gICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxyXG4gICAgICAgIC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxyXG4gICAgICAgIGlmIChvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhc3BlY2lhbC50ZWFyZG93biB8fFxyXG4gICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2VcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcclxuICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KGV2ZW50cykpIHtcclxuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgaixcclxuICAgICAgICByZXQsXHJcbiAgICAgICAgbWF0Y2hlZCxcclxuICAgICAgICBoYW5kbGVPYmosXHJcbiAgICAgICAgaGFuZGxlclF1ZXVlLFxyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXHJcbiAgICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KG5hdGl2ZUV2ZW50KSxcclxuICAgICAgICBoYW5kbGVycyA9XHJcbiAgICAgICAgICAoZGF0YVByaXYuZ2V0KHRoaXMsIFwiZXZlbnRzXCIpIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpW2V2ZW50LnR5cGVdIHx8XHJcbiAgICAgICAgICBbXSxcclxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbZXZlbnQudHlwZV0gfHwge307XHJcblxyXG4gICAgICAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxyXG4gICAgICBhcmdzWzBdID0gZXZlbnQ7XHJcblxyXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xyXG5cclxuICAgICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgc3BlY2lhbC5wcmVEaXNwYXRjaCAmJlxyXG4gICAgICAgIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCkgPT09IGZhbHNlXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXHJcbiAgICAgIGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGV2ZW50LCBoYW5kbGVycyk7XHJcblxyXG4gICAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xyXG4gICAgICBpID0gMDtcclxuICAgICAgd2hpbGUgKChtYXRjaGVkID0gaGFuZGxlclF1ZXVlW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcclxuXHJcbiAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbaisrXSkgJiZcclxuICAgICAgICAgICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXHJcbiAgICAgICAgICAvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhZXZlbnQucm5hbWVzcGFjZSB8fFxyXG4gICAgICAgICAgICBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxyXG4gICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XHJcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcclxuXHJcbiAgICAgICAgICAgIHJldCA9IChcclxuICAgICAgICAgICAgICAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbaGFuZGxlT2JqLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8XHJcbiAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXJcclxuICAgICAgICAgICAgKS5hcHBseShtYXRjaGVkLmVsZW0sIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgaWYgKChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxyXG4gICAgICBpZiAoc3BlY2lhbC5wb3N0RGlzcGF0Y2gpIHtcclxuICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsIGV2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgaGFuZGxlcnM6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcnMpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgaGFuZGxlT2JqLFxyXG4gICAgICAgIHNlbCxcclxuICAgICAgICBtYXRjaGVkSGFuZGxlcnMsXHJcbiAgICAgICAgbWF0Y2hlZFNlbGVjdG9ycyxcclxuICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcclxuICAgICAgICBkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcclxuICAgICAgICBjdXIgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICAvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXHJcbiAgICAgIGlmIChcclxuICAgICAgICBkZWxlZ2F0ZUNvdW50ICYmXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05XHJcbiAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXHJcbiAgICAgICAgY3VyLm5vZGVUeXBlICYmXHJcbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQyXHJcbiAgICAgICAgLy8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcclxuICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XHJcbiAgICAgICAgLy8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxyXG4gICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKVxyXG4gICAgICApIHtcclxuICAgICAgICBmb3IgKDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzKSB7XHJcbiAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcclxuICAgICAgICAgIC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBjdXIubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgIShldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzID0ge307XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcclxuICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgID8galF1ZXJ5KHNlbCwgdGhpcykuaW5kZXgoY3VyKSA+IC0xXHJcbiAgICAgICAgICAgICAgICAgIDogalF1ZXJ5LmZpbmQoc2VsLCB0aGlzLCBudWxsLCBbY3VyXSkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXHJcbiAgICAgIGN1ciA9IHRoaXM7XHJcbiAgICAgIGlmIChkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xyXG4gICAgICAgICAgZWxlbTogY3VyLFxyXG4gICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKGRlbGVnYXRlQ291bnQpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRQcm9wOiBmdW5jdGlvbiAobmFtZSwgaG9vaykge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGlzRnVuY3Rpb24oaG9vaylcclxuICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob29rKHRoaXMub3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W25hbWVdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaXg6IGZ1bmN0aW9uIChvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50W2pRdWVyeS5leHBhbmRvXVxyXG4gICAgICAgID8gb3JpZ2luYWxFdmVudFxyXG4gICAgICAgIDogbmV3IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3BlY2lhbDoge1xyXG4gICAgICBsb2FkOiB7XHJcbiAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxyXG4gICAgICAgIG5vQnViYmxlOiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgICBjbGljazoge1xyXG4gICAgICAgIC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXHJcbiAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cclxuICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXHJcbiAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XHJcblxyXG4gICAgICAgICAgLy8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgcmNoZWNrYWJsZVR5cGUudGVzdChlbC50eXBlKSAmJlxyXG4gICAgICAgICAgICBlbC5jbGljayAmJlxyXG4gICAgICAgICAgICBub2RlTmFtZShlbCwgXCJpbnB1dFwiKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcclxuICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cclxuICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXHJcbiAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XHJcblxyXG4gICAgICAgICAgLy8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICByY2hlY2thYmxlVHlwZS50ZXN0KGVsLnR5cGUpICYmXHJcbiAgICAgICAgICAgIGVsLmNsaWNrICYmXHJcbiAgICAgICAgICAgIG5vZGVOYW1lKGVsLCBcImlucHV0XCIpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xyXG4gICAgICAgIC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xyXG4gICAgICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAocmNoZWNrYWJsZVR5cGUudGVzdCh0YXJnZXQudHlwZSkgJiZcclxuICAgICAgICAgICAgICB0YXJnZXQuY2xpY2sgJiZcclxuICAgICAgICAgICAgICBub2RlTmFtZSh0YXJnZXQsIFwiaW5wdXRcIikgJiZcclxuICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQodGFyZ2V0LCBcImNsaWNrXCIpKSB8fFxyXG4gICAgICAgICAgICBub2RlTmFtZSh0YXJnZXQsIFwiYVwiKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG5cclxuICAgICAgYmVmb3JldW5sb2FkOiB7XHJcbiAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXHJcbiAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXHJcbiAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xyXG4gICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIC8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxyXG4gIC8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xyXG4gIC8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxyXG4gIC8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cclxuICBmdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZShlbCwgdHlwZSwgZXhwZWN0U3luYykge1xyXG4gICAgLy8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcclxuICAgIGlmICghZXhwZWN0U3luYykge1xyXG4gICAgICBpZiAoZGF0YVByaXYuZ2V0KGVsLCB0eXBlKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZChlbCwgdHlwZSwgcmV0dXJuVHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcclxuICAgIGRhdGFQcml2LnNldChlbCwgdHlwZSwgZmFsc2UpO1xyXG4gICAgalF1ZXJ5LmV2ZW50LmFkZChlbCwgdHlwZSwge1xyXG4gICAgICBuYW1lc3BhY2U6IGZhbHNlLFxyXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgbm90QXN5bmMsXHJcbiAgICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgICBzYXZlZCA9IGRhdGFQcml2LmdldCh0aGlzLCB0eXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJpZ2dlciAmIDEgJiYgdGhpc1t0eXBlXSkge1xyXG4gICAgICAgICAgLy8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcclxuICAgICAgICAgIC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XHJcbiAgICAgICAgICAvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxyXG4gICAgICAgICAgaWYgKCFzYXZlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxyXG4gICAgICAgICAgICAvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXHJcbiAgICAgICAgICAgIHNhdmVkID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBkYXRhUHJpdi5zZXQodGhpcywgdHlwZSwgc2F2ZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXHJcbiAgICAgICAgICAgIC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXHJcbiAgICAgICAgICAgIG5vdEFzeW5jID0gZXhwZWN0U3luYyh0aGlzLCB0eXBlKTtcclxuICAgICAgICAgICAgdGhpc1t0eXBlXSgpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIHR5cGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2F2ZWQgIT09IHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XHJcbiAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxyXG4gICAgICAgICAgICAvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcclxuICAgICAgICAgICAgLy8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cclxuICAgICAgICAgICAgLy8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcclxuICAgICAgICAgICAgLy8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xyXG4gICAgICAgICAgICAvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxyXG4gICAgICAgICAgfSBlbHNlIGlmICgoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge30pLmRlbGVnYXRlVHlwZSkge1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcclxuICAgICAgICAgIC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2F2ZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XHJcbiAgICAgICAgICBkYXRhUHJpdi5zZXQodGhpcywgdHlwZSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXHJcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXHJcbiAgICAgICAgICAgICAgLy8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcclxuICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHNhdmVkWzBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlKSxcclxuICAgICAgICAgICAgICBzYXZlZC5zbGljZSgxKSxcclxuICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XHJcbiAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGUpIHtcclxuICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xyXG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiAoc3JjLCBwcm9wcykge1xyXG4gICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSkge1xyXG4gICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudChzcmMsIHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFdmVudCBvYmplY3RcclxuICAgIGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcclxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xyXG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcclxuXHJcbiAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXHJcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxyXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9XHJcbiAgICAgICAgc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcclxuICAgICAgICAoc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XHJcbiAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlKVxyXG4gICAgICAgICAgPyByZXR1cm5UcnVlXHJcbiAgICAgICAgICA6IHJldHVybkZhbHNlO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXHJcbiAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcclxuICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcclxuICAgICAgdGhpcy50YXJnZXQgPVxyXG4gICAgICAgIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gM1xyXG4gICAgICAgICAgPyBzcmMudGFyZ2V0LnBhcmVudE5vZGVcclxuICAgICAgICAgIDogc3JjLnRhcmdldDtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xyXG4gICAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcclxuXHJcbiAgICAgIC8vIEV2ZW50IHR5cGVcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudHlwZSA9IHNyYztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgIGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXHJcbiAgICB0aGlzLnRpbWVTdGFtcCA9IChzcmMgJiYgc3JjLnRpbWVTdGFtcCkgfHwgRGF0ZS5ub3coKTtcclxuXHJcbiAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXHJcbiAgICB0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXHJcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxyXG4gIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxyXG4gICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcclxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcclxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcclxuICAgIGlzU2ltdWxhdGVkOiBmYWxzZSxcclxuXHJcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuXHJcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcclxuXHJcbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG4gICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XHJcblxyXG4gICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcclxuXHJcbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcclxuICBqUXVlcnkuZWFjaChcclxuICAgIHtcclxuICAgICAgYWx0S2V5OiB0cnVlLFxyXG4gICAgICBidWJibGVzOiB0cnVlLFxyXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxyXG4gICAgICBjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcclxuICAgICAgY3RybEtleTogdHJ1ZSxcclxuICAgICAgZGV0YWlsOiB0cnVlLFxyXG4gICAgICBldmVudFBoYXNlOiB0cnVlLFxyXG4gICAgICBtZXRhS2V5OiB0cnVlLFxyXG4gICAgICBwYWdlWDogdHJ1ZSxcclxuICAgICAgcGFnZVk6IHRydWUsXHJcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxyXG4gICAgICB2aWV3OiB0cnVlLFxyXG4gICAgICBjaGFyOiB0cnVlLFxyXG4gICAgICBjb2RlOiB0cnVlLFxyXG4gICAgICBjaGFyQ29kZTogdHJ1ZSxcclxuICAgICAga2V5OiB0cnVlLFxyXG4gICAgICBrZXlDb2RlOiB0cnVlLFxyXG4gICAgICBidXR0b246IHRydWUsXHJcbiAgICAgIGJ1dHRvbnM6IHRydWUsXHJcbiAgICAgIGNsaWVudFg6IHRydWUsXHJcbiAgICAgIGNsaWVudFk6IHRydWUsXHJcbiAgICAgIG9mZnNldFg6IHRydWUsXHJcbiAgICAgIG9mZnNldFk6IHRydWUsXHJcbiAgICAgIHBvaW50ZXJJZDogdHJ1ZSxcclxuICAgICAgcG9pbnRlclR5cGU6IHRydWUsXHJcbiAgICAgIHNjcmVlblg6IHRydWUsXHJcbiAgICAgIHNjcmVlblk6IHRydWUsXHJcbiAgICAgIHRhcmdldFRvdWNoZXM6IHRydWUsXHJcbiAgICAgIHRvRWxlbWVudDogdHJ1ZSxcclxuICAgICAgdG91Y2hlczogdHJ1ZSxcclxuXHJcbiAgICAgIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG5cclxuICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcclxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdChldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgIWV2ZW50LndoaWNoICYmXHJcbiAgICAgICAgICBidXR0b24gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgcm1vdXNlRXZlbnQudGVzdChldmVudC50eXBlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKGJ1dHRvbiAmIDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGJ1dHRvbiAmIDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGJ1dHRvbiAmIDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXZlbnQud2hpY2g7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgalF1ZXJ5LmV2ZW50LmFkZFByb3BcclxuICApO1xyXG5cclxuICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uIChcclxuICAgIHR5cGUsXHJcbiAgICBkZWxlZ2F0ZVR5cGVcclxuICApIHtcclxuICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdID0ge1xyXG4gICAgICAvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcclxuICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxyXG4gICAgICAgIC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxyXG4gICAgICAgIC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXHJcbiAgICAgICAgbGV2ZXJhZ2VOYXRpdmUodGhpcywgdHlwZSwgZXhwZWN0U3luYyk7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcclxuICAgICAgICBsZXZlcmFnZU5hdGl2ZSh0aGlzLCB0eXBlKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGUsXHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcclxuICAvLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxyXG4gIC8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XHJcbiAgLy9cclxuICAvLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XHJcbiAgLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XHJcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XHJcbiAgLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cclxuICBqUXVlcnkuZWFjaChcclxuICAgIHtcclxuICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcclxuICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxyXG4gICAgICBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcclxuICAgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIixcclxuICAgIH0sXHJcbiAgICBmdW5jdGlvbiAob3JpZywgZml4KSB7XHJcbiAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW29yaWddID0ge1xyXG4gICAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxyXG4gICAgICAgIGJpbmRUeXBlOiBmaXgsXHJcblxyXG4gICAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICB2YXIgcmV0LFxyXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLFxyXG4gICAgICAgICAgICByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcclxuICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xyXG5cclxuICAgICAgICAgIC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhcmVsYXRlZCB8fFxyXG4gICAgICAgICAgICAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnModGFyZ2V0LCByZWxhdGVkKSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xyXG4gICAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgb246IGZ1bmN0aW9uICh0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XHJcbiAgICAgIHJldHVybiBvbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKTtcclxuICAgIH0sXHJcbiAgICBvbmU6IGZ1bmN0aW9uICh0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XHJcbiAgICAgIHJldHVybiBvbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxKTtcclxuICAgIH0sXHJcbiAgICBvZmY6IGZ1bmN0aW9uICh0eXBlcywgc2VsZWN0b3IsIGZuKSB7XHJcbiAgICAgIHZhciBoYW5kbGVPYmosIHR5cGU7XHJcbiAgICAgIGlmICh0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmopIHtcclxuICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XHJcbiAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xyXG4gICAgICAgIGpRdWVyeSh0eXBlcy5kZWxlZ2F0ZVRhcmdldCkub2ZmKFxyXG4gICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZVxyXG4gICAgICAgICAgICA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZVxyXG4gICAgICAgICAgICA6IGhhbmRsZU9iai5vcmlnVHlwZSxcclxuICAgICAgICAgIGhhbmRsZU9iai5zZWxlY3RvcixcclxuICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcclxuICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcclxuICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXHJcbiAgICAgICAgZm4gPSBzZWxlY3RvcjtcclxuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZm4gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHZhciAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XHJcbiAgICAvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cclxuICAgIHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxyXG4gICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXHJcbiAgICByY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXHJcbiAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XHJcblxyXG4gIC8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xyXG4gIGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldChlbGVtLCBjb250ZW50KSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIG5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgJiZcclxuICAgICAgbm9kZU5hbWUoY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtKS5jaGlsZHJlbihcInRib2R5XCIpWzBdIHx8IGVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW07XHJcbiAgfVxyXG5cclxuICAvLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXHJcbiAgZnVuY3Rpb24gZGlzYWJsZVNjcmlwdChlbGVtKSB7XHJcbiAgICBlbGVtLnR5cGUgPSAoZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpICE9PSBudWxsKSArIFwiL1wiICsgZWxlbS50eXBlO1xyXG4gICAgcmV0dXJuIGVsZW07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoZWxlbSkge1xyXG4gICAgaWYgKChlbGVtLnR5cGUgfHwgXCJcIikuc2xpY2UoMCwgNSkgPT09IFwidHJ1ZS9cIikge1xyXG4gICAgICBlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoNSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcclxuICAgIHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XHJcblxyXG4gICAgaWYgKGRlc3Qubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXHJcbiAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XHJcbiAgICAgIHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KHNyYyk7XHJcbiAgICAgIGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcclxuXHJcbiAgICAgIGlmIChldmVudHMpIHtcclxuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIpO1xyXG5cclxuICAgICAgICBmb3IgKHR5cGUgaW4gZXZlbnRzKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGRlc3QsIHR5cGUsIGV2ZW50c1t0eXBlXVtpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMi4gQ29weSB1c2VyIGRhdGFcclxuICAgIGlmIChkYXRhVXNlci5oYXNEYXRhKHNyYykpIHtcclxuICAgICAgdWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3Moc3JjKTtcclxuICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKHt9LCB1ZGF0YU9sZCk7XHJcblxyXG4gICAgICBkYXRhVXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXHJcbiAgZnVuY3Rpb24gZml4SW5wdXQoc3JjLCBkZXN0KSB7XHJcbiAgICB2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXHJcbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KHNyYy50eXBlKSkge1xyXG4gICAgICBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcclxuXHJcbiAgICAgIC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXHJcbiAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIikge1xyXG4gICAgICBkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb21NYW5pcChjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCkge1xyXG4gICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xyXG4gICAgYXJncyA9IGZsYXQoYXJncyk7XHJcblxyXG4gICAgdmFyIGZyYWdtZW50LFxyXG4gICAgICBmaXJzdCxcclxuICAgICAgc2NyaXB0cyxcclxuICAgICAgaGFzU2NyaXB0cyxcclxuICAgICAgbm9kZSxcclxuICAgICAgZG9jLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgbCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxyXG4gICAgICBpTm9DbG9uZSA9IGwgLSAxLFxyXG4gICAgICB2YWx1ZSA9IGFyZ3NbMF0sXHJcbiAgICAgIHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24odmFsdWUpO1xyXG5cclxuICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxyXG4gICAgaWYgKFxyXG4gICAgICB2YWx1ZUlzRnVuY3Rpb24gfHxcclxuICAgICAgKGwgPiAxICYmXHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJlxyXG4gICAgICAgIHJjaGVja2VkLnRlc3QodmFsdWUpKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKGluZGV4KTtcclxuICAgICAgICBpZiAodmFsdWVJc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICBhcmdzWzBdID0gdmFsdWUuY2FsbCh0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb21NYW5pcChzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsKSB7XHJcbiAgICAgIGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudChcclxuICAgICAgICBhcmdzLFxyXG4gICAgICAgIGNvbGxlY3Rpb25bMF0ub3duZXJEb2N1bWVudCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBjb2xsZWN0aW9uLFxyXG4gICAgICAgIGlnbm9yZWRcclxuICAgICAgKTtcclxuICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xyXG5cclxuICAgICAgaWYgKGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgZnJhZ21lbnQgPSBmaXJzdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXHJcbiAgICAgIGlmIChmaXJzdCB8fCBpZ25vcmVkKSB7XHJcbiAgICAgICAgc2NyaXB0cyA9IGpRdWVyeS5tYXAoZ2V0QWxsKGZyYWdtZW50LCBcInNjcmlwdFwiKSwgZGlzYWJsZVNjcmlwdCk7XHJcbiAgICAgICAgaGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXHJcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXHJcbiAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cclxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgbm9kZSA9IGZyYWdtZW50O1xyXG5cclxuICAgICAgICAgIGlmIChpICE9PSBpTm9DbG9uZSkge1xyXG4gICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxyXG4gICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xyXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxyXG4gICAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcclxuICAgICAgICAgICAgICBqUXVlcnkubWVyZ2Uoc2NyaXB0cywgZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgbm9kZSwgaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xyXG4gICAgICAgICAgZG9jID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQ7XHJcblxyXG4gICAgICAgICAgLy8gUmVlbmFibGUgc2NyaXB0c1xyXG4gICAgICAgICAgalF1ZXJ5Lm1hcChzY3JpcHRzLCByZXN0b3JlU2NyaXB0KTtcclxuXHJcbiAgICAgICAgICAvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBzY3JpcHRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgcnNjcmlwdFR5cGUudGVzdChub2RlLnR5cGUgfHwgXCJcIikgJiZcclxuICAgICAgICAgICAgICAhZGF0YVByaXYuYWNjZXNzKG5vZGUsIFwiZ2xvYmFsRXZhbFwiKSAmJlxyXG4gICAgICAgICAgICAgIGpRdWVyeS5jb250YWlucyhkb2MsIG5vZGUpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIGlmIChub2RlLnNyYyAmJiAobm9kZS50eXBlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgIT09IFwibW9kdWxlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZXZhbFVybChcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNyYyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZG9jXHJcbiAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIERPTUV2YWwobm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKHJjbGVhblNjcmlwdCwgXCJcIiksIG5vZGUsIGRvYyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmUoZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhKSB7XHJcbiAgICB2YXIgbm9kZSxcclxuICAgICAgbm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIGVsZW0pIDogZWxlbSxcclxuICAgICAgaSA9IDA7XHJcblxyXG4gICAgZm9yICg7IChub2RlID0gbm9kZXNbaV0pICE9IG51bGw7IGkrKykge1xyXG4gICAgICBpZiAoIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChub2RlKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBpZiAoa2VlcERhdGEgJiYgaXNBdHRhY2hlZChub2RlKSkge1xyXG4gICAgICAgICAgc2V0R2xvYmFsRXZhbChnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbTtcclxuICB9XHJcblxyXG4gIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsb25lOiBmdW5jdGlvbiAoZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBzcmNFbGVtZW50cyxcclxuICAgICAgICBkZXN0RWxlbWVudHMsXHJcbiAgICAgICAgY2xvbmUgPSBlbGVtLmNsb25lTm9kZSh0cnVlKSxcclxuICAgICAgICBpblBhZ2UgPSBpc0F0dGFjaGVkKGVsZW0pO1xyXG5cclxuICAgICAgLy8gRml4IElFIGNsb25pbmcgaXNzdWVzXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJlxyXG4gICAgICAgIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJlxyXG4gICAgICAgICFqUXVlcnkuaXNYTUxEb2MoZWxlbSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgLy8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXHJcbiAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcclxuICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbChlbGVtKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgZml4SW5wdXQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXHJcbiAgICAgIGlmIChkYXRhQW5kRXZlbnRzKSB7XHJcbiAgICAgICAgaWYgKGRlZXBEYXRhQW5kRXZlbnRzKSB7XHJcbiAgICAgICAgICBzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbChlbGVtKTtcclxuICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoY2xvbmUpO1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb25lQ29weUV2ZW50KGVsZW0sIGNsb25lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcclxuICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lLCBcInNjcmlwdFwiKTtcclxuICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgc2V0R2xvYmFsRXZhbChkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKGVsZW0sIFwic2NyaXB0XCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XHJcbiAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZWxlbXMpIHtcclxuICAgICAgdmFyIGRhdGEsXHJcbiAgICAgICAgZWxlbSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyAoZWxlbSA9IGVsZW1zW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcclxuICAgICAgICBpZiAoYWNjZXB0RGF0YShlbGVtKSkge1xyXG4gICAgICAgICAgaWYgKChkYXRhID0gZWxlbVtkYXRhUHJpdi5leHBhbmRvXSkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGRhdGEuZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbFt0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXHJcbiAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxyXG4gICAgICAgICAgICBlbGVtW2RhdGFQcml2LmV4cGFuZG9dID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVsZW1bZGF0YVVzZXIuZXhwYW5kb10pIHtcclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcclxuICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXHJcbiAgICAgICAgICAgIGVsZW1bZGF0YVVzZXIuZXhwYW5kb10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgIGRldGFjaDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiByZW1vdmUodGhpcywgc2VsZWN0b3IsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yKTtcclxuICAgIH0sXHJcblxyXG4gICAgdGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBhY2Nlc3MoXHJcbiAgICAgICAgdGhpcyxcclxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8galF1ZXJ5LnRleHQodGhpcylcclxuICAgICAgICAgICAgOiB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPT09IDEgfHxcclxuICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHxcclxuICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gOVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxIHx8XHJcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxMSB8fFxyXG4gICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gOVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcclxuICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmVwZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMSB8fFxyXG4gICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHxcclxuICAgICAgICAgIHRoaXMubm9kZVR5cGUgPT09IDlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XHJcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW0sIHRhcmdldC5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBiZWZvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFmdGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzLm5leHRTaWJsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZWxlbSxcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xyXG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xyXG4gICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uIChkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xyXG4gICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xyXG4gICAgICBkZWVwRGF0YUFuZEV2ZW50cyA9XHJcbiAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5jbG9uZSh0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBodG1sOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGFjY2VzcyhcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICAgICFybm9Jbm5lcmh0bWwudGVzdCh2YWx1ZSkgJiZcclxuICAgICAgICAgICAgIXdyYXBNYXBbKHJ0YWdOYW1lLmV4ZWModmFsdWUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV1cclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzW2ldIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGVsZW0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaWdub3JlZCA9IFtdO1xyXG5cclxuICAgICAgLy8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XHJcbiAgICAgIHJldHVybiBkb21NYW5pcChcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIGFyZ3VtZW50cyxcclxuICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICBpZiAoalF1ZXJ5LmluQXJyYXkodGhpcywgaWdub3JlZCkgPCAwKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWxlbSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZ25vcmVkXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZWFjaChcclxuICAgIHtcclxuICAgICAgYXBwZW5kVG86IFwiYXBwZW5kXCIsXHJcbiAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXHJcbiAgICAgIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcclxuICAgICAgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcclxuICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiLFxyXG4gICAgfSxcclxuICAgIGZ1bmN0aW9uIChuYW1lLCBvcmlnaW5hbCkge1xyXG4gICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgZWxlbXMsXHJcbiAgICAgICAgICByZXQgPSBbXSxcclxuICAgICAgICAgIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXHJcbiAgICAgICAgICBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPD0gbGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICBlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSh0cnVlKTtcclxuICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XHJcblxyXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XHJcbiAgICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XHJcbiAgICAgICAgICBwdXNoLmFwcGx5KHJldCwgZWxlbXMuZ2V0KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHJldCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgKTtcclxuICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xyXG5cclxuICB2YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcclxuICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xyXG4gICAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXHJcbiAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuXHJcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcub3BlbmVyKSB7XHJcbiAgICAgIHZpZXcgPSB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcclxuICB9O1xyXG5cclxuICB2YXIgc3dhcCA9IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHJldCxcclxuICAgICAgbmFtZSxcclxuICAgICAgb2xkID0ge307XHJcblxyXG4gICAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXHJcbiAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICBvbGRbbmFtZV0gPSBlbGVtLnN0eWxlW25hbWVdO1xyXG4gICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICByZXQgPSBjYWxsYmFjay5jYWxsKGVsZW0pO1xyXG5cclxuICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xyXG4gICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcblxyXG4gIHZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKGNzc0V4cGFuZC5qb2luKFwifFwiKSwgXCJpXCIpO1xyXG5cclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XHJcbiAgICAvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2VcclxuICAgICAgaWYgKCFkaXYpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID1cclxuICAgICAgICBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXHJcbiAgICAgICAgXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcclxuICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPVxyXG4gICAgICAgIFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcclxuICAgICAgICBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xyXG4gICAgICAgIFwid2lkdGg6NjAlO3RvcDoxJVwiO1xyXG4gICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKS5hcHBlbmRDaGlsZChkaXYpO1xyXG5cclxuICAgICAgdmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2KTtcclxuICAgICAgcGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxyXG4gICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoZGl2U3R5bGUubWFyZ2luTGVmdCkgPT09IDEyO1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXHJcbiAgICAgIC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxyXG4gICAgICBkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xyXG4gICAgICBwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5yaWdodCkgPT09IDM2O1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcclxuICAgICAgLy8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xyXG4gICAgICBib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS53aWR0aCkgPT09IDM2O1xyXG5cclxuICAgICAgLy8gU3VwcG9ydDogSUUgOSBvbmx5XHJcbiAgICAgIC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcclxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NjRcclxuICAgICAgLy8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXHJcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgc2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXYub2Zmc2V0V2lkdGggLyAzKSA9PT0gMTI7XHJcblxyXG4gICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcclxuXHJcbiAgICAgIC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcclxuICAgICAgLy8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxyXG4gICAgICBkaXYgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyhtZWFzdXJlKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWVhc3VyZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwaXhlbFBvc2l0aW9uVmFsLFxyXG4gICAgICBib3hTaXppbmdSZWxpYWJsZVZhbCxcclxuICAgICAgc2Nyb2xsYm94U2l6ZVZhbCxcclxuICAgICAgcGl4ZWxCb3hTdHlsZXNWYWwsXHJcbiAgICAgIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLFxyXG4gICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXHJcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXHJcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgLy8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcclxuICAgIGlmICghZGl2LnN0eWxlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XHJcbiAgICAvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXHJcbiAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XHJcbiAgICBkaXYuY2xvbmVOb2RlKHRydWUpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcclxuICAgIHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZChzdXBwb3J0LCB7XHJcbiAgICAgIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcclxuICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcclxuICAgICAgICByZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xyXG4gICAgICAgIHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xyXG4gICAgICB9LFxyXG4gICAgICByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xyXG4gICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xyXG4gICAgICAgIHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xyXG4gICAgICAvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxyXG4gICAgICAvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cclxuICAgICAgLy8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXHJcbiAgICAgIC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcclxuICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xyXG4gICAgICAgIGlmIChyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcclxuICAgICAgICAgIHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgICAgdHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgICAgICAgdGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweFwiO1xyXG4gICAgICAgICAgdHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcclxuICAgICAgICAgIHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcclxuXHJcbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnRcclxuICAgICAgICAgICAgLmFwcGVuZENoaWxkKHRhYmxlKVxyXG4gICAgICAgICAgICAuYXBwZW5kQ2hpbGQodHIpXHJcbiAgICAgICAgICAgIC5hcHBlbmRDaGlsZCh0ckNoaWxkKTtcclxuXHJcbiAgICAgICAgICB0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodHIpO1xyXG4gICAgICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCh0clN0eWxlLmhlaWdodCkgPiAzO1xyXG5cclxuICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0YWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH0pKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xyXG4gICAgdmFyIHdpZHRoLFxyXG4gICAgICBtaW5XaWR0aCxcclxuICAgICAgbWF4V2lkdGgsXHJcbiAgICAgIHJldCxcclxuICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA1MStcclxuICAgICAgLy8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xyXG4gICAgICAvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXHJcbiAgICAgIC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXHJcbiAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHJcbiAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyhlbGVtKTtcclxuXHJcbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XHJcbiAgICAvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcclxuICAgIC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxyXG4gICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgIHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XHJcblxyXG4gICAgICBpZiAocmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKGVsZW0pKSB7XHJcbiAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXHJcbiAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxyXG4gICAgICAvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxyXG4gICAgICAvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XHJcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmXHJcbiAgICAgICAgcm51bW5vbnB4LnRlc3QocmV0KSAmJlxyXG4gICAgICAgIHJib3hTdHlsZS50ZXN0KG5hbWUpXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcclxuICAgICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xyXG4gICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XHJcbiAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcclxuXHJcbiAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxyXG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcclxuICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDtcclxuXHJcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xyXG4gICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcclxuICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxyXG4gICAgICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXHJcbiAgICAgICAgcmV0ICsgXCJcIlxyXG4gICAgICA6IHJldDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZEdldEhvb2tJZihjb25kaXRpb25GbiwgaG9va0ZuKSB7XHJcbiAgICAvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNvbmRpdGlvbkZuKCkpIHtcclxuICAgICAgICAgIC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxyXG4gICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0O1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgY3NzUHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXSxcclxuICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFxyXG4gICAgdmVuZG9yUHJvcHMgPSB7fTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxyXG4gIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcclxuICAgIC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcclxuICAgIHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcclxuICAgICAgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XHJcbiAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcclxuICBmdW5jdGlvbiBmaW5hbFByb3BOYW1lKG5hbWUpIHtcclxuICAgIHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1tuYW1lXSB8fCB2ZW5kb3JQcm9wc1tuYW1lXTtcclxuXHJcbiAgICBpZiAoZmluYWwpIHtcclxuICAgICAgcmV0dXJuIGZpbmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xyXG4gICAgICByZXR1cm4gbmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiAodmVuZG9yUHJvcHNbbmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShuYW1lKSB8fCBuYW1lKTtcclxuICB9XHJcblxyXG4gIHZhciAvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXHJcbiAgICAvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcclxuICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxyXG4gICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxyXG4gICAgcmN1c3RvbVByb3AgPSAvXi0tLyxcclxuICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxyXG4gICAgY3NzTm9ybWFsVHJhbnNmb3JtID0ge1xyXG4gICAgICBsZXR0ZXJTcGFjaW5nOiBcIjBcIixcclxuICAgICAgZm9udFdlaWdodDogXCI0MDBcIixcclxuICAgIH07XHJcblxyXG4gIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QpIHtcclxuICAgIC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cclxuICAgIC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxyXG4gICAgdmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpO1xyXG4gICAgcmV0dXJuIG1hdGNoZXNcclxuICAgICAgPyAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xyXG4gICAgICAgIE1hdGgubWF4KDAsIG1hdGNoZXNbMl0gLSAoc3VidHJhY3QgfHwgMCkpICsgKG1hdGNoZXNbM10gfHwgXCJweFwiKVxyXG4gICAgICA6IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KFxyXG4gICAgZWxlbSxcclxuICAgIGRpbWVuc2lvbixcclxuICAgIGJveCxcclxuICAgIGlzQm9yZGVyQm94LFxyXG4gICAgc3R5bGVzLFxyXG4gICAgY29tcHV0ZWRWYWxcclxuICApIHtcclxuICAgIHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcclxuICAgICAgZXh0cmEgPSAwLFxyXG4gICAgICBkZWx0YSA9IDA7XHJcblxyXG4gICAgLy8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxyXG4gICAgaWYgKGJveCA9PT0gKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKDsgaSA8IDQ7IGkgKz0gMikge1xyXG4gICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cclxuICAgICAgaWYgKGJveCA9PT0gXCJtYXJnaW5cIikge1xyXG4gICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoZWxlbSwgYm94ICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXHJcbiAgICAgIGlmICghaXNCb3JkZXJCb3gpIHtcclxuICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XHJcblxyXG4gICAgICAgIC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcclxuICAgICAgICBpZiAoYm94ICE9PSBcInBhZGRpbmdcIikge1xyXG4gICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhcclxuICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgXCJib3JkZXJcIiArIGNzc0V4cGFuZFtpXSArIFwiV2lkdGhcIixcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgc3R5bGVzXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBleHRyYSArPSBqUXVlcnkuY3NzKFxyXG4gICAgICAgICAgICBlbGVtLFxyXG4gICAgICAgICAgICBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLFxyXG4gICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICBzdHlsZXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXHJcbiAgICAgICAgLy8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xyXG4gICAgICAgIGlmIChib3ggPT09IFwiY29udGVudFwiKSB7XHJcbiAgICAgICAgICBkZWx0YSAtPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcclxuICAgICAgICBpZiAoYm94ICE9PSBcIm1hcmdpblwiKSB7XHJcbiAgICAgICAgICBkZWx0YSAtPSBqUXVlcnkuY3NzKFxyXG4gICAgICAgICAgICBlbGVtLFxyXG4gICAgICAgICAgICBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLFxyXG4gICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICBzdHlsZXNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcclxuICAgIGlmICghaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCkge1xyXG4gICAgICAvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXHJcbiAgICAgIC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cclxuICAgICAgZGVsdGEgKz1cclxuICAgICAgICBNYXRoLm1heChcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBNYXRoLmNlaWwoXHJcbiAgICAgICAgICAgIGVsZW1bXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXSAtXHJcbiAgICAgICAgICAgICAgY29tcHV0ZWRWYWwgLVxyXG4gICAgICAgICAgICAgIGRlbHRhIC1cclxuICAgICAgICAgICAgICBleHRyYSAtXHJcbiAgICAgICAgICAgICAgMC41XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxyXG4gICAgICAgICAgICAvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWx0YTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgZGltZW5zaW9uLCBleHRyYSkge1xyXG4gICAgLy8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcclxuICAgICAgLy8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXHJcbiAgICAgIC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxyXG4gICAgICBib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxyXG4gICAgICBpc0JvcmRlckJveCA9XHJcbiAgICAgICAgYm94U2l6aW5nTmVlZGVkICYmXHJcbiAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXHJcbiAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcclxuICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzKSxcclxuICAgICAgb2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcclxuICAgIC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgaWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcclxuICAgICAgaWYgKCFleHRyYSkge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgIH1cclxuICAgICAgdmFsID0gXCJhdXRvXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcclxuICAgIC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxyXG4gICAgLy8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxyXG4gICAgaWYgKFxyXG4gICAgICAoKCFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3gpIHx8XHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcclxuICAgICAgICAvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxyXG4gICAgICAgIC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxyXG4gICAgICAgIC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXHJcbiAgICAgICAgKCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoZWxlbSwgXCJ0clwiKSkgfHxcclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcclxuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXHJcbiAgICAgICAgdmFsID09PSBcImF1dG9cIiB8fFxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxyXG4gICAgICAgIC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXHJcbiAgICAgICAgKCFwYXJzZUZsb2F0KHZhbCkgJiZcclxuICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImlubGluZVwiKSkgJiZcclxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcclxuICAgICAgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aFxyXG4gICAgKSB7XHJcbiAgICAgIGlzQm9yZGVyQm94ID1cclxuICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIjtcclxuXHJcbiAgICAgIC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cclxuICAgICAgLy8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxyXG4gICAgICAvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXHJcbiAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XHJcbiAgICAgIGlmICh2YWx1ZUlzQm9yZGVyQm94KSB7XHJcbiAgICAgICAgdmFsID0gZWxlbVtvZmZzZXRQcm9wXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXHJcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcclxuXHJcbiAgICAvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB2YWwgK1xyXG4gICAgICBib3hNb2RlbEFkanVzdG1lbnQoXHJcbiAgICAgICAgZWxlbSxcclxuICAgICAgICBkaW1lbnNpb24sXHJcbiAgICAgICAgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSxcclxuICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxyXG4gICAgICAgIHN0eWxlcyxcclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcclxuICAgICAgICB2YWxcclxuICAgICAgKSArXHJcbiAgICAgIFwicHhcIlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgLy8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XHJcbiAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcclxuICAgIGNzc0hvb2tzOiB7XHJcbiAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xyXG4gICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBjdXJDU1MoZWxlbSwgXCJvcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcclxuICAgIGNzc051bWJlcjoge1xyXG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcclxuICAgICAgY29sdW1uQ291bnQ6IHRydWUsXHJcbiAgICAgIGZpbGxPcGFjaXR5OiB0cnVlLFxyXG4gICAgICBmbGV4R3JvdzogdHJ1ZSxcclxuICAgICAgZmxleFNocmluazogdHJ1ZSxcclxuICAgICAgZm9udFdlaWdodDogdHJ1ZSxcclxuICAgICAgZ3JpZEFyZWE6IHRydWUsXHJcbiAgICAgIGdyaWRDb2x1bW46IHRydWUsXHJcbiAgICAgIGdyaWRDb2x1bW5FbmQ6IHRydWUsXHJcbiAgICAgIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcclxuICAgICAgZ3JpZFJvdzogdHJ1ZSxcclxuICAgICAgZ3JpZFJvd0VuZDogdHJ1ZSxcclxuICAgICAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxyXG4gICAgICBsaW5lSGVpZ2h0OiB0cnVlLFxyXG4gICAgICBvcGFjaXR5OiB0cnVlLFxyXG4gICAgICBvcmRlcjogdHJ1ZSxcclxuICAgICAgb3JwaGFuczogdHJ1ZSxcclxuICAgICAgd2lkb3dzOiB0cnVlLFxyXG4gICAgICB6SW5kZXg6IHRydWUsXHJcbiAgICAgIHpvb206IHRydWUsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcclxuICAgIC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcclxuICAgIGNzc1Byb3BzOiB7fSxcclxuXHJcbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxyXG4gICAgc3R5bGU6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcclxuICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXHJcbiAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxyXG4gICAgICB2YXIgcmV0LFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgaG9va3MsXHJcbiAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UobmFtZSksXHJcbiAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKSxcclxuICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XHJcbiAgICAgIC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxyXG4gICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXHJcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wKSB7XHJcbiAgICAgICAgbmFtZSA9IGZpbmFsUHJvcE5hbWUob3JpZ05hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxyXG4gICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxyXG4gICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJiByZXRbMV0pIHtcclxuICAgICAgICAgIHZhbHVlID0gYWRqdXN0Q1NTKGVsZW0sIG5hbWUsIHJldCk7XHJcblxyXG4gICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XHJcbiAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcclxuICAgICAgICAvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXHJcbiAgICAgICAgLy8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCkge1xyXG4gICAgICAgICAgdmFsdWUgKz0gKHJldCAmJiByZXRbM10pIHx8IChqUXVlcnkuY3NzTnVtYmVyW29yaWdOYW1lXSA/IFwiXCIgOiBcInB4XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJlxyXG4gICAgICAgICAgdmFsdWUgPT09IFwiXCIgJiZcclxuICAgICAgICAgIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDBcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHN0eWxlW25hbWVdID0gXCJpbmhlcml0XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhaG9va3MgfHxcclxuICAgICAgICAgICEoXCJzZXRcIiBpbiBob29rcykgfHxcclxuICAgICAgICAgICh2YWx1ZSA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgZXh0cmEpKSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBpZiAoaXNDdXN0b21Qcm9wKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0eWxlW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGhvb2tzICYmXHJcbiAgICAgICAgICBcImdldFwiIGluIGhvb2tzICYmXHJcbiAgICAgICAgICAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxyXG4gICAgICAgIHJldHVybiBzdHlsZVtuYW1lXTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjc3M6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzKSB7XHJcbiAgICAgIHZhciB2YWwsXHJcbiAgICAgICAgbnVtLFxyXG4gICAgICAgIGhvb2tzLFxyXG4gICAgICAgIG9yaWdOYW1lID0gY2FtZWxDYXNlKG5hbWUpLFxyXG4gICAgICAgIGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QobmFtZSk7XHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XHJcbiAgICAgIC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcclxuICAgICAgLy8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxyXG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcCkge1xyXG4gICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxyXG4gICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xyXG5cclxuICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcclxuICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MpIHtcclxuICAgICAgICB2YWwgPSBob29rcy5nZXQoZWxlbSwgdHJ1ZSwgZXh0cmEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxyXG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXHJcbiAgICAgIGlmICh2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0pIHtcclxuICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bbmFtZV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xyXG4gICAgICBpZiAoZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEpIHtcclxuICAgICAgICBudW0gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKG51bSkgPyBudW0gfHwgMCA6IHZhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5lYWNoKFtcImhlaWdodFwiLCBcIndpZHRoXCJdLCBmdW5jdGlvbiAoX2ksIGRpbWVuc2lvbikge1xyXG4gICAgalF1ZXJ5LmNzc0hvb2tzW2RpbWVuc2lvbl0gPSB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkLCBleHRyYSkge1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXHJcbiAgICAgICAgICAvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxyXG4gICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpKSAmJlxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgOCtcclxuICAgICAgICAgICAgLy8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cclxuICAgICAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XHJcbiAgICAgICAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcclxuICAgICAgICAgICAgLy8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAoIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aClcclxuICAgICAgICAgICAgPyBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZ2V0V2lkdGhPckhlaWdodChlbGVtLCBkaW1lbnNpb24sIGV4dHJhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSwgZXh0cmEpIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcyxcclxuICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcclxuICAgICAgICAgIC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcclxuICAgICAgICAgIC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXHJcbiAgICAgICAgICBzY3JvbGxib3hTaXplQnVnZ3kgPVxyXG4gICAgICAgICAgICAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiYgc3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxyXG4gICAgICAgICAgYm94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxyXG4gICAgICAgICAgaXNCb3JkZXJCb3ggPVxyXG4gICAgICAgICAgICBib3hTaXppbmdOZWVkZWQgJiZcclxuICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXHJcbiAgICAgICAgICBzdWJ0cmFjdCA9IGV4dHJhXHJcbiAgICAgICAgICAgID8gYm94TW9kZWxBZGp1c3RtZW50KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpXHJcbiAgICAgICAgICAgIDogMDtcclxuXHJcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXHJcbiAgICAgICAgLy8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcclxuICAgICAgICBpZiAoaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5KSB7XHJcbiAgICAgICAgICBzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXHJcbiAgICAgICAgICAgIGVsZW1bXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXSAtXHJcbiAgICAgICAgICAgICAgcGFyc2VGbG9hdChzdHlsZXNbZGltZW5zaW9uXSkgLVxyXG4gICAgICAgICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMpIC1cclxuICAgICAgICAgICAgICAwLjVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHN1YnRyYWN0ICYmXHJcbiAgICAgICAgICAobWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyh2YWx1ZSkpICYmXHJcbiAgICAgICAgICAobWF0Y2hlc1szXSB8fCBcInB4XCIpICE9PSBcInB4XCJcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGVsZW0uc3R5bGVbZGltZW5zaW9uXSA9IHZhbHVlO1xyXG4gICAgICAgICAgdmFsdWUgPSBqUXVlcnkuY3NzKGVsZW0sIGRpbWVuc2lvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoZWxlbSwgdmFsdWUsIHN1YnRyYWN0KTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKFxyXG4gICAgc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXHJcbiAgICBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcclxuICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIChwYXJzZUZsb2F0KGN1ckNTUyhlbGVtLCBcIm1hcmdpbkxlZnRcIikpIHx8XHJcbiAgICAgICAgICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXHJcbiAgICAgICAgICAgICAgc3dhcChlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcclxuICAgICAgICAgICAgICB9KSkgKyBcInB4XCJcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xyXG4gIGpRdWVyeS5lYWNoKFxyXG4gICAge1xyXG4gICAgICBtYXJnaW46IFwiXCIsXHJcbiAgICAgIHBhZGRpbmc6IFwiXCIsXHJcbiAgICAgIGJvcmRlcjogXCJXaWR0aFwiLFxyXG4gICAgfSxcclxuICAgIGZ1bmN0aW9uIChwcmVmaXgsIHN1ZmZpeCkge1xyXG4gICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XSA9IHtcclxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBleHBhbmRlZCA9IHt9LFxyXG4gICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcclxuICAgICAgICAgICAgcGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbdmFsdWVdO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4cGFuZGVkW3ByZWZpeCArIGNzc0V4cGFuZFtpXSArIHN1ZmZpeF0gPVxyXG4gICAgICAgICAgICAgIHBhcnRzW2ldIHx8IHBhcnRzW2kgLSAyXSB8fCBwYXJ0c1swXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChwcmVmaXggIT09IFwibWFyZ2luXCIpIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgY3NzOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGFjY2VzcyhcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHN0eWxlcyxcclxuICAgICAgICAgICAgbGVuLFxyXG4gICAgICAgICAgICBtYXAgPSB7fSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcclxuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xyXG4gICAgICAgICAgICBsZW4gPSBuYW1lLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICBtYXBbbmFtZVtpXV0gPSBqUXVlcnkuY3NzKGVsZW0sIG5hbWVbaV0sIGZhbHNlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlKVxyXG4gICAgICAgICAgICA6IGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBUd2VlbihlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZykge1xyXG4gICAgcmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdChlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyk7XHJcbiAgfVxyXG4gIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xyXG5cclxuICBUd2Vlbi5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQpIHtcclxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgdGhpcy5wcm9wID0gcHJvcDtcclxuICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcclxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcclxuICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKTtcclxuICAgIH0sXHJcbiAgICBjdXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XHJcblxyXG4gICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0XHJcbiAgICAgICAgPyBob29rcy5nZXQodGhpcylcclxuICAgICAgICA6IFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgcnVuOiBmdW5jdGlvbiAocGVyY2VudCkge1xyXG4gICAgICB2YXIgZWFzZWQsXHJcbiAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1t0aGlzLmVhc2luZ10oXHJcbiAgICAgICAgICBwZXJjZW50LFxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICAxLFxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm5vdyA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnNldCkge1xyXG4gICAgICAgIGhvb2tzLnNldCh0aGlzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XHJcblxyXG4gIFR3ZWVuLnByb3BIb29rcyA9IHtcclxuICAgIF9kZWZhdWx0OiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKHR3ZWVuKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcclxuICAgICAgICAvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcclxuICAgICAgICAgICh0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdICE9IG51bGwgJiZcclxuICAgICAgICAgICAgdHdlZW4uZWxlbS5zdHlsZVt0d2Vlbi5wcm9wXSA9PSBudWxsKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxyXG4gICAgICAgIC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xyXG4gICAgICAgIC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXHJcbiAgICAgICAgcmVzdWx0ID0galF1ZXJ5LmNzcyh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiKTtcclxuXHJcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXHJcbiAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHR3ZWVuKSB7XHJcbiAgICAgICAgLy8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXHJcbiAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxyXG4gICAgICAgIC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKSB7XHJcbiAgICAgICAgICBqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSh0d2Vlbik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgIChqUXVlcnkuY3NzSG9va3NbdHdlZW4ucHJvcF0gfHxcclxuICAgICAgICAgICAgdHdlZW4uZWxlbS5zdHlsZVtmaW5hbFByb3BOYW1lKHR3ZWVuLnByb3ApXSAhPSBudWxsKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAvLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcclxuICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uICh0d2Vlbikge1xyXG4gICAgICBpZiAodHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5lYXNpbmcgPSB7XHJcbiAgICBsaW5lYXI6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgIHJldHVybiBwO1xyXG4gICAgfSxcclxuICAgIHN3aW5nOiBmdW5jdGlvbiAocCkge1xyXG4gICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcclxuICAgIH0sXHJcbiAgICBfZGVmYXVsdDogXCJzd2luZ1wiLFxyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xyXG5cclxuICAvLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxyXG4gIGpRdWVyeS5meC5zdGVwID0ge307XHJcblxyXG4gIHZhciBmeE5vdyxcclxuICAgIGluUHJvZ3Jlc3MsXHJcbiAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcclxuICAgIHJydW4gPSAvcXVldWVIb29rcyQvO1xyXG5cclxuICBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcclxuICAgIGlmIChpblByb2dyZXNzKSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgalF1ZXJ5LmZ4LnRpY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcclxuICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoZnhOb3cgPSBEYXRlLm5vdygpKTtcclxuICB9XHJcblxyXG4gIC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXHJcbiAgZnVuY3Rpb24gZ2VuRngodHlwZSwgaW5jbHVkZVdpZHRoKSB7XHJcbiAgICB2YXIgd2hpY2gsXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XHJcblxyXG4gICAgLy8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxyXG4gICAgLy8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcclxuICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xyXG4gICAgZm9yICg7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGgpIHtcclxuICAgICAgd2hpY2ggPSBjc3NFeHBhbmRbaV07XHJcbiAgICAgIGF0dHJzW1wibWFyZ2luXCIgKyB3aGljaF0gPSBhdHRyc1tcInBhZGRpbmdcIiArIHdoaWNoXSA9IHR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluY2x1ZGVXaWR0aCkge1xyXG4gICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhdHRycztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcclxuICAgIHZhciB0d2VlbixcclxuICAgICAgY29sbGVjdGlvbiA9IChBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW10pLmNvbmNhdChcclxuICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbXCIqXCJdXHJcbiAgICAgICksXHJcbiAgICAgIGluZGV4ID0gMCxcclxuICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgaWYgKCh0d2VlbiA9IGNvbGxlY3Rpb25baW5kZXhdLmNhbGwoYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSkpKSB7XHJcbiAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcclxuICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoZWxlbSwgcHJvcHMsIG9wdHMpIHtcclxuICAgIHZhciBwcm9wLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgdG9nZ2xlLFxyXG4gICAgICBob29rcyxcclxuICAgICAgb2xkZmlyZSxcclxuICAgICAgcHJvcFR3ZWVuLFxyXG4gICAgICByZXN0b3JlRGlzcGxheSxcclxuICAgICAgZGlzcGxheSxcclxuICAgICAgaXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcclxuICAgICAgYW5pbSA9IHRoaXMsXHJcbiAgICAgIG9yaWcgPSB7fSxcclxuICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLFxyXG4gICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSxcclxuICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJmeHNob3dcIik7XHJcblxyXG4gICAgLy8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXHJcbiAgICBpZiAoIW9wdHMucXVldWUpIHtcclxuICAgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgXCJmeFwiKTtcclxuICAgICAgaWYgKGhvb2tzLnVucXVldWVkID09IG51bGwpIHtcclxuICAgICAgICBob29rcy51bnF1ZXVlZCA9IDA7XHJcbiAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XHJcbiAgICAgICAgaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICghaG9va3MudW5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgb2xkZmlyZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaG9va3MudW5xdWV1ZWQrKztcclxuXHJcbiAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xyXG4gICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XHJcbiAgICAgICAgICBpZiAoIWpRdWVyeS5xdWV1ZShlbGVtLCBcImZ4XCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xyXG4gICAgZm9yIChwcm9wIGluIHByb3BzKSB7XHJcbiAgICAgIHZhbHVlID0gcHJvcHNbcHJvcF07XHJcbiAgICAgIGlmIChyZnh0eXBlcy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgIGRlbGV0ZSBwcm9wc1twcm9wXTtcclxuICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAoaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIikpIHtcclxuICAgICAgICAgIC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcclxuICAgICAgICAgIC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXHJcbiAgICAgICAgICBpZiAodmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaGlkZGVuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvcmlnW3Byb3BdID0gKGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdKSB8fCBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxyXG4gICAgcHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3BzKTtcclxuICAgIGlmICghcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KG9yaWcpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcclxuICAgIGlmIChpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcclxuICAgICAgLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXHJcbiAgICAgIC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xyXG4gICAgICAvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxyXG4gICAgICBvcHRzLm92ZXJmbG93ID0gW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WV07XHJcblxyXG4gICAgICAvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcclxuICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xyXG4gICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZGlzcGxheVwiKTtcclxuICAgICAgfVxyXG4gICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XHJcbiAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSkge1xyXG4gICAgICAgICAgZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XHJcbiAgICAgICAgICBzaG93SGlkZShbZWxlbV0sIHRydWUpO1xyXG4gICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XHJcbiAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XHJcbiAgICAgICAgICBzaG93SGlkZShbZWxlbV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXHJcbiAgICAgIGlmIChcclxuICAgICAgICBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8XHJcbiAgICAgICAgKGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbClcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKGpRdWVyeS5jc3MoZWxlbSwgXCJmbG9hdFwiKSA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXHJcbiAgICAgICAgICBpZiAoIXByb3BUd2Vlbikge1xyXG4gICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0cy5vdmVyZmxvdykge1xyXG4gICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbMF07XHJcbiAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sxXTtcclxuICAgICAgICBzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WzJdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcclxuICAgIHByb3BUd2VlbiA9IGZhbHNlO1xyXG4gICAgZm9yIChwcm9wIGluIG9yaWcpIHtcclxuICAgICAgLy8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cclxuICAgICAgaWYgKCFwcm9wVHdlZW4pIHtcclxuICAgICAgICBpZiAoZGF0YVNob3cpIHtcclxuICAgICAgICAgIGlmIChcImhpZGRlblwiIGluIGRhdGFTaG93KSB7XHJcbiAgICAgICAgICAgIGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgXCJmeHNob3dcIiwge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXHJcbiAgICAgICAgaWYgKHRvZ2dsZSkge1xyXG4gICAgICAgICAgZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXHJcbiAgICAgICAgaWYgKGhpZGRlbikge1xyXG4gICAgICAgICAgc2hvd0hpZGUoW2VsZW1dLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cclxuICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cclxuXHJcbiAgICAgICAgICAvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcclxuICAgICAgICAgIGlmICghaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgXCJmeHNob3dcIik7XHJcbiAgICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xyXG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxyXG4gICAgICBwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbihoaWRkZW4gPyBkYXRhU2hvd1twcm9wXSA6IDAsIHByb3AsIGFuaW0pO1xyXG4gICAgICBpZiAoIShwcm9wIGluIGRhdGFTaG93KSkge1xyXG4gICAgICAgIGRhdGFTaG93W3Byb3BdID0gcHJvcFR3ZWVuLnN0YXJ0O1xyXG4gICAgICAgIGlmIChoaWRkZW4pIHtcclxuICAgICAgICAgIHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XHJcbiAgICAgICAgICBwcm9wVHdlZW4uc3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJvcEZpbHRlcihwcm9wcywgc3BlY2lhbEVhc2luZykge1xyXG4gICAgdmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcclxuXHJcbiAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcclxuICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcclxuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShpbmRleCk7XHJcbiAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbbmFtZV07XHJcbiAgICAgIHZhbHVlID0gcHJvcHNbaW5kZXhdO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcclxuICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XSA9IHZhbHVlWzBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaW5kZXggIT09IG5hbWUpIHtcclxuICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgIGRlbGV0ZSBwcm9wc1tpbmRleF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdO1xyXG4gICAgICBpZiAoaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcykge1xyXG4gICAgICAgIHZhbHVlID0gaG9va3MuZXhwYW5kKHZhbHVlKTtcclxuICAgICAgICBkZWxldGUgcHJvcHNbbmFtZV07XHJcblxyXG4gICAgICAgIC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cclxuICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXHJcbiAgICAgICAgZm9yIChpbmRleCBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKCEoaW5kZXggaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2luZGV4XSA9IHZhbHVlW2luZGV4XTtcclxuICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNwZWNpYWxFYXNpbmdbbmFtZV0gPSBlYXNpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbihlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcmVzdWx0LFxyXG4gICAgICBzdG9wcGVkLFxyXG4gICAgICBpbmRleCA9IDAsXHJcbiAgICAgIGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcclxuICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxyXG4gICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XHJcbiAgICAgIH0pLFxyXG4gICAgICB0aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXHJcbiAgICAgICAgICByZW1haW5pbmcgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxyXG4gICAgICAgICAgLy8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxyXG4gICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxyXG4gICAgICAgICAgcGVyY2VudCA9IDEgLSB0ZW1wLFxyXG4gICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKHBlcmNlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmddKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxyXG4gICAgICAgIGlmIChwZXJjZW50IDwgMSAmJiBsZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cclxuICAgICAgICBpZiAoIWxlbmd0aCkge1xyXG4gICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChlbGVtLCBbYW5pbWF0aW9uLCAxLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxyXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKGVsZW0sIFthbmltYXRpb25dKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xyXG4gICAgICAgIGVsZW06IGVsZW0sXHJcbiAgICAgICAgcHJvcHM6IGpRdWVyeS5leHRlbmQoe30sIHByb3BlcnRpZXMpLFxyXG4gICAgICAgIG9wdHM6IGpRdWVyeS5leHRlbmQoXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBzcGVjaWFsRWFzaW5nOiB7fSxcclxuICAgICAgICAgICAgZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICApLFxyXG4gICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcclxuICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxyXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxyXG4gICAgICAgIHR3ZWVuczogW10sXHJcbiAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChwcm9wLCBlbmQpIHtcclxuICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihcclxuICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMsXHJcbiAgICAgICAgICAgIHByb3AsXHJcbiAgICAgICAgICAgIGVuZCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1twcm9wXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmdcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBhbmltYXRpb24udHdlZW5zLnB1c2godHdlZW4pO1xyXG4gICAgICAgICAgcmV0dXJuIHR3ZWVuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGdvdG9FbmQpIHtcclxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcclxuICAgICAgICAgICAgbGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcclxuICAgICAgICAgIGlmIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XHJcbiAgICAgICAgICBpZiAoZ290b0VuZCkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIDEsIDBdKTtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICB9KSxcclxuICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XHJcblxyXG4gICAgcHJvcEZpbHRlcihwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyk7XHJcblxyXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzW2luZGV4XS5jYWxsKFxyXG4gICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICBlbGVtLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGFuaW1hdGlvbi5vcHRzXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXN1bHQuc3RvcCkpIHtcclxuICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyhcclxuICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW0sXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLnF1ZXVlXHJcbiAgICAgICAgICApLnN0b3AgPSByZXN1bHQuc3RvcC5iaW5kKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkubWFwKHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uKTtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb24ub3B0cy5zdGFydCkpIHtcclxuICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbChlbGVtLCBhbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXHJcbiAgICBhbmltYXRpb25cclxuICAgICAgLnByb2dyZXNzKGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzKVxyXG4gICAgICAuZG9uZShhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSlcclxuICAgICAgLmZhaWwoYW5pbWF0aW9uLm9wdHMuZmFpbClcclxuICAgICAgLmFsd2F5cyhhbmltYXRpb24ub3B0cy5hbHdheXMpO1xyXG5cclxuICAgIGpRdWVyeS5meC50aW1lcihcclxuICAgICAgalF1ZXJ5LmV4dGVuZCh0aWNrLCB7XHJcbiAgICAgICAgZWxlbTogZWxlbSxcclxuICAgICAgICBhbmltOiBhbmltYXRpb24sXHJcbiAgICAgICAgcXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gIH1cclxuXHJcbiAgalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoQW5pbWF0aW9uLCB7XHJcbiAgICB0d2VlbmVyczoge1xyXG4gICAgICBcIipcIjogW1xyXG4gICAgICAgIGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2Vlbihwcm9wLCB2YWx1ZSk7XHJcbiAgICAgICAgICBhZGp1c3RDU1ModHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKHZhbHVlKSwgdHdlZW4pO1xyXG4gICAgICAgICAgcmV0dXJuIHR3ZWVuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9LFxyXG5cclxuICAgIHR3ZWVuZXI6IGZ1bmN0aW9uIChwcm9wcywgY2FsbGJhY2spIHtcclxuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcHMpKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcclxuICAgICAgICBwcm9wcyA9IFtcIipcIl07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaChybm90aHRtbHdoaXRlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHByb3AsXHJcbiAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHByb3AgPSBwcm9wc1tpbmRleF07XHJcbiAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdID0gQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdIHx8IFtdO1xyXG4gICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXS51bnNoaWZ0KGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwcmVmaWx0ZXJzOiBbZGVmYXVsdFByZWZpbHRlcl0sXHJcblxyXG4gICAgcHJlZmlsdGVyOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByZXBlbmQpIHtcclxuICAgICAgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KGNhbGxiYWNrKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgalF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGZuKSB7XHJcbiAgICB2YXIgb3B0ID1cclxuICAgICAgc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiXHJcbiAgICAgICAgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZClcclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgY29tcGxldGU6IGZuIHx8ICghZm4gJiYgZWFzaW5nKSB8fCAoaXNGdW5jdGlvbihzcGVlZCkgJiYgc3BlZWQpLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXHJcbiAgICAgICAgICAgIGVhc2luZzogKGZuICYmIGVhc2luZykgfHwgKGVhc2luZyAmJiAhaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZyksXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgIC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxyXG4gICAgaWYgKGpRdWVyeS5meC5vZmYpIHtcclxuICAgICAgb3B0LmR1cmF0aW9uID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgaWYgKG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzKSB7XHJcbiAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzW29wdC5kdXJhdGlvbl07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXHJcbiAgICBpZiAob3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlKSB7XHJcbiAgICAgIG9wdC5xdWV1ZSA9IFwiZnhcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBRdWV1ZWluZ1xyXG4gICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcclxuXHJcbiAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdC5vbGQpKSB7XHJcbiAgICAgICAgb3B0Lm9sZC5jYWxsKHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0LnF1ZXVlKSB7XHJcbiAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgb3B0LnF1ZXVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gb3B0O1xyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgZmFkZVRvOiBmdW5jdGlvbiAoc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIHRoaXMuZmlsdGVyKGlzSGlkZGVuV2l0aGluVHJlZSlcclxuICAgICAgICAgIC5jc3MoXCJvcGFjaXR5XCIsIDApXHJcbiAgICAgICAgICAuc2hvdygpXHJcblxyXG4gICAgICAgICAgLy8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXHJcbiAgICAgICAgICAuZW5kKClcclxuICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3ApLFxyXG4gICAgICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayksXHJcbiAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxyXG4gICAgICAgICAgdmFyIGFuaW0gPSBBbmltYXRpb24odGhpcywgalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcCksIG9wdGFsbCk7XHJcblxyXG4gICAgICAgICAgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICBpZiAoZW1wdHkgfHwgZGF0YVByaXYuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSB7XHJcbiAgICAgICAgICAgIGFuaW0uc3RvcCh0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICBkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcclxuXHJcbiAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlXHJcbiAgICAgICAgPyB0aGlzLmVhY2goZG9BbmltYXRpb24pXHJcbiAgICAgICAgOiB0aGlzLnF1ZXVlKG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24pO1xyXG4gICAgfSxcclxuICAgIHN0b3A6IGZ1bmN0aW9uICh0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XHJcbiAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiAoaG9va3MpIHtcclxuICAgICAgICB2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XHJcbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XHJcbiAgICAgICAgc3RvcChnb3RvRW5kKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xyXG4gICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xyXG4gICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNsZWFyUXVldWUpIHtcclxuICAgICAgICB0aGlzLnF1ZXVlKHR5cGUgfHwgXCJmeFwiLCBbXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcclxuICAgICAgICAgIGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcclxuICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXHJcbiAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICAgIGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wKSB7XHJcbiAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAoaW5kZXggaW4gZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiZcclxuICAgICAgICAgICAgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uYW5pbS5zdG9wKGdvdG9FbmQpO1xyXG4gICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cclxuICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXHJcbiAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxyXG4gICAgICAgIGlmIChkZXF1ZXVlIHx8ICFnb3RvRW5kKSB7XHJcbiAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGZpbmlzaDogZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgaWYgKHR5cGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyksXHJcbiAgICAgICAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFwicXVldWVcIl0sXHJcbiAgICAgICAgICBob29rcyA9IGRhdGFbdHlwZSArIFwicXVldWVIb29rc1wiXSxcclxuICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXHJcbiAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcclxuICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxyXG4gICAgICAgIGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XHJcblxyXG4gICAgICAgIGlmIChob29rcyAmJiBob29rcy5zdG9wKSB7XHJcbiAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxyXG4gICAgICAgIGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcclxuICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcclxuICAgICAgICAgICAgdGltZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgaWYgKHF1ZXVlW2luZGV4XSAmJiBxdWV1ZVtpbmRleF0uZmluaXNoKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlW2luZGV4XS5maW5pc2guY2FsbCh0aGlzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXHJcbiAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5lYWNoKFtcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCJdLCBmdW5jdGlvbiAoX2ksIG5hbWUpIHtcclxuICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mbltuYW1lXTtcclxuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiXHJcbiAgICAgICAgPyBjc3NGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICAgICAgOiB0aGlzLmFuaW1hdGUoZ2VuRngobmFtZSwgdHJ1ZSksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcclxuICBqUXVlcnkuZWFjaChcclxuICAgIHtcclxuICAgICAgc2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXHJcbiAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcclxuICAgICAgc2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxyXG4gICAgICBmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcclxuICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxyXG4gICAgICBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfSxcclxuICAgIH0sXHJcbiAgICBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcclxuICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGpRdWVyeS50aW1lcnMgPSBbXTtcclxuICBqUXVlcnkuZngudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0aW1lcixcclxuICAgICAgaSA9IDAsXHJcbiAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XHJcblxyXG4gICAgZnhOb3cgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIGZvciAoOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRpbWVyID0gdGltZXJzW2ldO1xyXG5cclxuICAgICAgLy8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxyXG4gICAgICBpZiAoIXRpbWVyKCkgJiYgdGltZXJzW2ldID09PSB0aW1lcikge1xyXG4gICAgICAgIHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xyXG4gICAgICBqUXVlcnkuZnguc3RvcCgpO1xyXG4gICAgfVxyXG4gICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XHJcbiAgICBqUXVlcnkudGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XHJcbiAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGluUHJvZ3Jlc3MpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgc2NoZWR1bGUoKTtcclxuICB9O1xyXG5cclxuICBqUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5meC5zcGVlZHMgPSB7XHJcbiAgICBzbG93OiA2MDAsXHJcbiAgICBmYXN0OiAyMDAsXHJcblxyXG4gICAgLy8gRGVmYXVsdCBzcGVlZFxyXG4gICAgX2RlZmF1bHQ6IDQwMCxcclxuICB9O1xyXG5cclxuICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXHJcbiAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cclxuICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiAodGltZSwgdHlwZSkge1xyXG4gICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbdGltZV0gfHwgdGltZSA6IHRpbWU7XHJcbiAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSwgZnVuY3Rpb24gKG5leHQsIGhvb2tzKSB7XHJcbiAgICAgIHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobmV4dCwgdGltZSk7XHJcbiAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXHJcbiAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXHJcbiAgICAgIG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKTtcclxuXHJcbiAgICBpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxyXG4gICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXHJcbiAgICBzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcclxuICAgIC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XHJcbiAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxyXG4gICAgLy8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cclxuICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgaW5wdXQudmFsdWUgPSBcInRcIjtcclxuICAgIGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XHJcbiAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XHJcbiAgfSkoKTtcclxuXHJcbiAgdmFyIGJvb2xIb29rLFxyXG4gICAgYXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKHRoaXMsIG5hbWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgYXR0cjogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgIHZhciByZXQsXHJcbiAgICAgICAgaG9va3MsXHJcbiAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xyXG4gICAgICBpZiAoblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoZWxlbSwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXHJcbiAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcclxuICAgICAgaWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcclxuICAgICAgICBob29rcyA9XHJcbiAgICAgICAgICBqUXVlcnkuYXR0ckhvb2tzW25hbWUudG9Mb3dlckNhc2UoKV0gfHxcclxuICAgICAgICAgIChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QobmFtZSkgPyBib29sSG9vayA6IHVuZGVmaW5lZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGhvb2tzICYmXHJcbiAgICAgICAgICBcInNldFwiIGluIGhvb2tzICYmXHJcbiAgICAgICAgICAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgbmFtZSk7XHJcblxyXG4gICAgICAvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxyXG4gICAgICByZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJIb29rczoge1xyXG4gICAgICB0eXBlOiB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgIXN1cHBvcnQucmFkaW9WYWx1ZSAmJlxyXG4gICAgICAgICAgICB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXHJcbiAgICAgICAgICAgIG5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIilcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gZWxlbS52YWx1ZTtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgbmFtZSxcclxuICAgICAgICBpID0gMCxcclxuICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXHJcbiAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XHJcblxyXG4gICAgICBpZiAoYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICB3aGlsZSAoKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkpIHtcclxuICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xyXG4gIGJvb2xIb29rID0ge1xyXG4gICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUsIG5hbWUpIHtcclxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcclxuICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmFtZTtcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmVhY2goalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xyXG4gICAgdmFyIGdldHRlciA9IGF0dHJIYW5kbGVbbmFtZV0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcclxuXHJcbiAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XHJcbiAgICAgIHZhciByZXQsXHJcbiAgICAgICAgaGFuZGxlLFxyXG4gICAgICAgIGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICBpZiAoIWlzWE1MKSB7XHJcbiAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxyXG4gICAgICAgIGhhbmRsZSA9IGF0dHJIYW5kbGVbbG93ZXJjYXNlTmFtZV07XHJcbiAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IHJldDtcclxuICAgICAgICByZXQgPSBnZXR0ZXIoZWxlbSwgbmFtZSwgaXNYTUwpICE9IG51bGwgPyBsb3dlcmNhc2VOYW1lIDogbnVsbDtcclxuICAgICAgICBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdID0gaGFuZGxlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICB2YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXHJcbiAgICByY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xyXG5cclxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgIHByb3A6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkZWxldGUgdGhpc1tqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lXTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgIHByb3A6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgcmV0LFxyXG4gICAgICAgIGhvb2tzLFxyXG4gICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcbiAgICAgIC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcclxuICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xyXG4gICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcclxuICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZTtcclxuICAgICAgICBob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbbmFtZV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgaG9va3MgJiZcclxuICAgICAgICAgIFwic2V0XCIgaW4gaG9va3MgJiZcclxuICAgICAgICAgIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChlbGVtW25hbWVdID0gdmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBlbGVtW25hbWVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcm9wSG9va3M6IHtcclxuICAgICAgdGFiSW5kZXg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XHJcbiAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcclxuICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXHJcbiAgICAgICAgICAvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxyXG4gICAgICAgICAgdmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBcInRhYmluZGV4XCIpO1xyXG5cclxuICAgICAgICAgIGlmICh0YWJpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGFiaW5kZXgsIDEwKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSB8fFxyXG4gICAgICAgICAgICAocmNsaWNrYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpICYmIGVsZW0uaHJlZilcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcblxyXG4gICAgcHJvcEZpeDoge1xyXG4gICAgICBmb3I6IFwiaHRtbEZvclwiLFxyXG4gICAgICBjbGFzczogXCJjbGFzc05hbWVcIixcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxyXG4gIC8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxyXG4gIC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcclxuICAvLyBvbiB0aGUgb3B0aW9uXHJcbiAgLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcclxuICAvLyB3aGVuIGluIGFuIG9wdGdyb3VwXHJcbiAgLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXHJcbiAgLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXHJcbiAgaWYgKCFzdXBwb3J0Lm9wdFNlbGVjdGVkKSB7XHJcbiAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xyXG5cclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xyXG5cclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xyXG5cclxuICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBqUXVlcnkuZWFjaChcclxuICAgIFtcclxuICAgICAgXCJ0YWJJbmRleFwiLFxyXG4gICAgICBcInJlYWRPbmx5XCIsXHJcbiAgICAgIFwibWF4TGVuZ3RoXCIsXHJcbiAgICAgIFwiY2VsbFNwYWNpbmdcIixcclxuICAgICAgXCJjZWxsUGFkZGluZ1wiLFxyXG4gICAgICBcInJvd1NwYW5cIixcclxuICAgICAgXCJjb2xTcGFuXCIsXHJcbiAgICAgIFwidXNlTWFwXCIsXHJcbiAgICAgIFwiZnJhbWVCb3JkZXJcIixcclxuICAgICAgXCJjb250ZW50RWRpdGFibGVcIixcclxuICAgIF0sXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGpRdWVyeS5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcclxuICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcclxuICBmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKHZhbHVlKSB7XHJcbiAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcbiAgICByZXR1cm4gdG9rZW5zLmpvaW4oXCIgXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbSkge1xyXG4gICAgcmV0dXJuIChlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSB8fCBcIlwiO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkodmFsdWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB2YXIgY2xhc3NlcyxcclxuICAgICAgICBlbGVtLFxyXG4gICAgICAgIGN1cixcclxuICAgICAgICBjdXJWYWx1ZSxcclxuICAgICAgICBjbGF6eixcclxuICAgICAgICBqLFxyXG4gICAgICAgIGZpbmFsVmFsdWUsXHJcbiAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChqKSB7XHJcbiAgICAgICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyhlbGVtKTtcclxuICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiO1xyXG5cclxuICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGN1ci5pbmRleE9mKFwiIFwiICsgY2xhenogKyBcIiBcIikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XHJcbiAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZmluYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIHZhciBjbGFzc2VzLFxyXG4gICAgICAgIGVsZW0sXHJcbiAgICAgICAgY3VyLFxyXG4gICAgICAgIGN1clZhbHVlLFxyXG4gICAgICAgIGNsYXp6LFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgZmluYWxWYWx1ZSxcclxuICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGopIHtcclxuICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZW1vdmVDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGosIGdldENsYXNzKHRoaXMpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcclxuICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoZWxlbSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcclxuICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiO1xyXG5cclxuICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xyXG4gICAgICAgICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZihcIiBcIiArIGNsYXp6ICsgXCIgXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cclxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcclxuICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmaW5hbFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUsIHN0YXRlVmFsKSB7XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxyXG4gICAgICAgIGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKHZhbHVlKSA6IHRoaXMucmVtb3ZlQ2xhc3ModmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3MoXHJcbiAgICAgICAgICAgIHZhbHVlLmNhbGwodGhpcywgaSwgZ2V0Q2xhc3ModGhpcyksIHN0YXRlVmFsKSxcclxuICAgICAgICAgICAgc3RhdGVWYWxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XHJcblxyXG4gICAgICAgIGlmIChpc1ZhbGlkVmFsdWUpIHtcclxuICAgICAgICAgIC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHNlbGYgPSBqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xyXG5cclxuICAgICAgICAgIHdoaWxlICgoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcclxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3ModGhpcyk7XHJcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcclxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXHJcbiAgICAgICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxyXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcclxuICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cclxuICAgICAgICAgIGlmICh0aGlzLnNldEF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgICBcImNsYXNzXCIsXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgPyBcIlwiXHJcbiAgICAgICAgICAgICAgICA6IGRhdGFQcml2LmdldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgdmFyIGNsYXNzTmFtZSxcclxuICAgICAgICBlbGVtLFxyXG4gICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xyXG4gICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxyXG4gICAgICAgICAgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShnZXRDbGFzcyhlbGVtKSkgKyBcIiBcIikuaW5kZXhPZihjbGFzc05hbWUpID4gLTFcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgdmFyIHJyZXR1cm4gPSAvXFxyL2c7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgdmFyIGhvb2tzLFxyXG4gICAgICAgIHJldCxcclxuICAgICAgICB2YWx1ZUlzRnVuY3Rpb24sXHJcbiAgICAgICAgZWxlbSA9IHRoaXNbMF07XHJcblxyXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgaG9va3MgPVxyXG4gICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbZWxlbS50eXBlXSB8fFxyXG4gICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGhvb2tzICYmXHJcbiAgICAgICAgICAgIFwiZ2V0XCIgaW4gaG9va3MgJiZcclxuICAgICAgICAgICAgKHJldCA9IGhvb2tzLmdldChlbGVtLCBcInZhbHVlXCIpKSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXQgPSBlbGVtLnZhbHVlO1xyXG5cclxuICAgICAgICAgIC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcclxuICAgICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcclxuICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24odmFsdWUpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgIHZhciB2YWw7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsdWVJc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKHRoaXMsIGksIGpRdWVyeSh0aGlzKS52YWwoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhbCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFsID0gXCJcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIHZhbCArPSBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaG9va3MgPVxyXG4gICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHxcclxuICAgICAgICAgIGpRdWVyeS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xyXG5cclxuICAgICAgICAvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFob29rcyB8fFxyXG4gICAgICAgICAgIShcInNldFwiIGluIGhvb2tzKSB8fFxyXG4gICAgICAgICAgaG9va3Muc2V0KHRoaXMsIHZhbCwgXCJ2YWx1ZVwiKSA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgIHZhbEhvb2tzOiB7XHJcbiAgICAgIG9wdGlvbjoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidmFsdWVcIik7XHJcbiAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGxcclxuICAgICAgICAgICAgPyB2YWxcclxuICAgICAgICAgICAgOiAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxyXG4gICAgICAgICAgICAgIC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcclxuICAgICAgICAgICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgc3RyaXBBbmRDb2xsYXBzZShqUXVlcnkudGV4dChlbGVtKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgc2VsZWN0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgdmFyIHZhbHVlLFxyXG4gICAgICAgICAgICBvcHRpb24sXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxyXG4gICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxyXG4gICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXHJcbiAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgaSA9IG1heDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSBvbmUgPyBpbmRleCA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAgICAgICAgICAgLy8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAob3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4KSAmJlxyXG4gICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcclxuICAgICAgICAgICAgICAhb3B0aW9uLmRpc2FibGVkICYmXHJcbiAgICAgICAgICAgICAgKCFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgIW5vZGVOYW1lKG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkob3B0aW9uKS52YWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcclxuICAgICAgICAgICAgICBpZiAob25lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxyXG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICAgIHZhciBvcHRpb25TZXQsXHJcbiAgICAgICAgICAgIG9wdGlvbixcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcclxuICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbaV07XHJcblxyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xyXG5cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIChvcHRpb24uc2VsZWN0ZWQgPVxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQob3B0aW9uKSwgdmFsdWVzKSA+IC0xKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBvcHRpb25TZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcclxuICAgICAgICAgIGlmICghb3B0aW9uU2V0KSB7XHJcbiAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcclxuICBqUXVlcnkuZWFjaChbXCJyYWRpb1wiLCBcImNoZWNrYm94XCJdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBqUXVlcnkudmFsSG9va3NbdGhpc10gPSB7XHJcbiAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gKGVsZW0uY2hlY2tlZCA9XHJcbiAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUpID4gLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgICBpZiAoIXN1cHBvcnQuY2hlY2tPbikge1xyXG4gICAgICBqUXVlcnkudmFsSG9va3NbdGhpc10uZ2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cclxuXHJcbiAgc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XHJcblxyXG4gIHZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcclxuICAgIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gIGpRdWVyeS5leHRlbmQoalF1ZXJ5LmV2ZW50LCB7XHJcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycykge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICBjdXIsXHJcbiAgICAgICAgdG1wLFxyXG4gICAgICAgIGJ1YmJsZVR5cGUsXHJcbiAgICAgICAgb250eXBlLFxyXG4gICAgICAgIGhhbmRsZSxcclxuICAgICAgICBzcGVjaWFsLFxyXG4gICAgICAgIGxhc3RFbGVtZW50LFxyXG4gICAgICAgIGV2ZW50UGF0aCA9IFtlbGVtIHx8IGRvY3VtZW50XSxcclxuICAgICAgICB0eXBlID0gaGFzT3duLmNhbGwoZXZlbnQsIFwidHlwZVwiKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcclxuICAgICAgICBuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoZXZlbnQsIFwibmFtZXNwYWNlXCIpXHJcbiAgICAgICAgICA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIilcclxuICAgICAgICAgIDogW107XHJcblxyXG4gICAgICBjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xyXG5cclxuICAgICAgLy8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcclxuICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XHJcbiAgICAgIGlmIChyZm9jdXNNb3JwaC50ZXN0KHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIi5cIikgPiAtMSkge1xyXG4gICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcclxuICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcclxuICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcclxuICAgICAgfVxyXG4gICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xyXG5cclxuICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXHJcbiAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dXHJcbiAgICAgICAgPyBldmVudFxyXG4gICAgICAgIDogbmV3IGpRdWVyeS5FdmVudCh0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQpO1xyXG5cclxuICAgICAgLy8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxyXG4gICAgICBldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcclxuICAgICAgZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFwiLlwiKTtcclxuICAgICAgZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZVxyXG4gICAgICAgID8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKVxyXG4gICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgIC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxyXG4gICAgICBldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxyXG4gICAgICBkYXRhID0gZGF0YSA9PSBudWxsID8gW2V2ZW50XSA6IGpRdWVyeS5tYWtlQXJyYXkoZGF0YSwgW2V2ZW50XSk7XHJcblxyXG4gICAgICAvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXHJcbiAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFvbmx5SGFuZGxlcnMgJiZcclxuICAgICAgICBzcGVjaWFsLnRyaWdnZXIgJiZcclxuICAgICAgICBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXHJcbiAgICAgIC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXHJcbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyhlbGVtKSkge1xyXG4gICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xyXG4gICAgICAgIGlmICghcmZvY3VzTW9ycGgudGVzdChidWJibGVUeXBlICsgdHlwZSkpIHtcclxuICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgZXZlbnRQYXRoLnB1c2goY3VyKTtcclxuICAgICAgICAgIHRtcCA9IGN1cjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxyXG4gICAgICAgIGlmICh0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICBldmVudFBhdGgucHVzaCh0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxyXG4gICAgICBpID0gMDtcclxuICAgICAgd2hpbGUgKChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICBsYXN0RWxlbWVudCA9IGN1cjtcclxuICAgICAgICBldmVudC50eXBlID0gaSA+IDEgPyBidWJibGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xyXG5cclxuICAgICAgICAvLyBqUXVlcnkgaGFuZGxlclxyXG4gICAgICAgIGhhbmRsZSA9XHJcbiAgICAgICAgICAoZGF0YVByaXYuZ2V0KGN1ciwgXCJldmVudHNcIikgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlbZXZlbnQudHlwZV0gJiZcclxuICAgICAgICAgIGRhdGFQcml2LmdldChjdXIsIFwiaGFuZGxlXCIpO1xyXG4gICAgICAgIGlmIChoYW5kbGUpIHtcclxuICAgICAgICAgIGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmF0aXZlIGhhbmRsZXJcclxuICAgICAgICBoYW5kbGUgPSBvbnR5cGUgJiYgY3VyW29udHlwZV07XHJcbiAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YShjdXIpKSB7XHJcbiAgICAgICAgICBldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcclxuICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgLy8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xyXG4gICAgICBpZiAoIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAoIXNwZWNpYWwuX2RlZmF1bHQgfHxcclxuICAgICAgICAgICAgc3BlY2lhbC5fZGVmYXVsdC5hcHBseShldmVudFBhdGgucG9wKCksIGRhdGEpID09PSBmYWxzZSkgJiZcclxuICAgICAgICAgIGFjY2VwdERhdGEoZWxlbSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXHJcbiAgICAgICAgICBpZiAob250eXBlICYmIGlzRnVuY3Rpb24oZWxlbVt0eXBlXSkgJiYgIWlzV2luZG93KGVsZW0pKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2RcclxuICAgICAgICAgICAgdG1wID0gZWxlbVtvbnR5cGVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRtcCkge1xyXG4gICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXHJcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgICBsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxlbVt0eXBlXSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICAgICAgICBsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0bXApIHtcclxuICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxyXG4gICAgLy8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcclxuICAgIHNpbXVsYXRlOiBmdW5jdGlvbiAodHlwZSwgZWxlbSwgZXZlbnQpIHtcclxuICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKG5ldyBqUXVlcnkuRXZlbnQoKSwgZXZlbnQsIHtcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKGUsIG51bGwsIGVsZW0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCB0aGlzKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XHJcbiAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcclxuICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxyXG4gIC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcclxuICAvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xyXG4gIC8vXHJcbiAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXHJcbiAgLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXHJcbiAgLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXHJcbiAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcclxuICBpZiAoIXN1cHBvcnQuZm9jdXNpbikge1xyXG4gICAgalF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XHJcbiAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XHJcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xyXG4gICAgICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xyXG4gICAgICAgICAgLy8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxyXG4gICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXHJcbiAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKGRvYywgZml4KTtcclxuXHJcbiAgICAgICAgICBpZiAoIWF0dGFjaGVzKSB7XHJcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCAoYXR0YWNoZXMgfHwgMCkgKyAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcclxuICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgpIC0gMTtcclxuXHJcbiAgICAgICAgICBpZiAoIWF0dGFjaGVzKSB7XHJcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xyXG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YVByaXYuYWNjZXNzKGRvYywgZml4LCBhdHRhY2hlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XHJcblxyXG4gIHZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xyXG5cclxuICB2YXIgcnF1ZXJ5ID0gL1xcPy87XHJcblxyXG4gIC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcclxuICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIHhtbDtcclxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxyXG4gICAgLy8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXHJcbiAgICB0cnkge1xyXG4gICAgICB4bWwgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkYXRhLCBcInRleHQveG1sXCIpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB4bWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSB7XHJcbiAgICAgIGpRdWVyeS5lcnJvcihcIkludmFsaWQgWE1MOiBcIiArIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHhtbDtcclxuICB9O1xyXG5cclxuICB2YXIgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXHJcbiAgICByQ1JMRiA9IC9cXHI/XFxuL2csXHJcbiAgICByc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXHJcbiAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XHJcblxyXG4gIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XHJcbiAgICB2YXIgbmFtZTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxyXG4gICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChpLCB2KSB7XHJcbiAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xyXG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxyXG4gICAgICAgICAgYWRkKHByZWZpeCwgdik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxyXG4gICAgICAgICAgYnVpbGRQYXJhbXMoXHJcbiAgICAgICAgICAgIHByZWZpeCArIFwiW1wiICsgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiKSArIFwiXVwiLFxyXG4gICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICB0cmFkaXRpb25hbCxcclxuICAgICAgICAgICAgYWRkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKCF0cmFkaXRpb25hbCAmJiB0b1R5cGUob2JqKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXHJcbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcclxuICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxyXG4gICAgICBhZGQocHJlZml4LCBvYmopO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcclxuICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcclxuICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiAoYSwgdHJhZGl0aW9uYWwpIHtcclxuICAgIHZhciBwcmVmaXgsXHJcbiAgICAgIHMgPSBbXSxcclxuICAgICAgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWVPckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24odmFsdWVPckZ1bmN0aW9uKVxyXG4gICAgICAgICAgPyB2YWx1ZU9yRnVuY3Rpb24oKVxyXG4gICAgICAgICAgOiB2YWx1ZU9yRnVuY3Rpb247XHJcblxyXG4gICAgICAgIHNbcy5sZW5ndGhdID1cclxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcclxuICAgICAgICAgIFwiPVwiICtcclxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICBpZiAoYSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSB8fCAoYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KGEpKSkge1xyXG4gICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcclxuICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXHJcbiAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICBmb3IgKHByZWZpeCBpbiBhKSB7XHJcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4LCBhW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxyXG4gICAgcmV0dXJuIHMuam9pbihcIiZcIik7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xyXG4gICAgfSxcclxuICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheShlbGVtZW50cykgOiB0aGlzO1xyXG4gICAgICB9KVxyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLm5hbWUgJiZcclxuICAgICAgICAgICAgIWpRdWVyeSh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJlxyXG4gICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJlxyXG4gICAgICAgICAgICAhcnN1Ym1pdHRlclR5cGVzLnRlc3QodHlwZSkgJiZcclxuICAgICAgICAgICAgKHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCh0eXBlKSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfaSwgZWxlbSkge1xyXG4gICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSh0aGlzKS52YWwoKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIikgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZ2V0KCk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICB2YXIgcjIwID0gLyUyMC9nLFxyXG4gICAgcmhhc2ggPSAvIy4qJC8sXHJcbiAgICByYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxyXG4gICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLFxyXG4gICAgLy8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXHJcbiAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxyXG4gICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXHJcbiAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXHJcbiAgICAvKiBQcmVmaWx0ZXJzXHJcbiAgICAgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxyXG4gICAgICogMikgVGhlc2UgYXJlIGNhbGxlZDpcclxuICAgICAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcclxuICAgICAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcclxuICAgICAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcclxuICAgICAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuICAgICAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXHJcbiAgICAgKi9cclxuICAgIHByZWZpbHRlcnMgPSB7fSxcclxuICAgIC8qIFRyYW5zcG9ydHMgYmluZGluZ3NcclxuICAgICAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcclxuICAgICAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuICAgICAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxyXG4gICAgICovXHJcbiAgICB0cmFuc3BvcnRzID0ge30sXHJcbiAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cclxuICAgIGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdChcIipcIiksXHJcbiAgICAvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cclxuICAgIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcclxuXHJcbiAgLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxyXG4gIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUpIHtcclxuICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcclxuICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRhdGFUeXBlLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xyXG5cclxuICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcclxuICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXHJcbiAgICAgICAgd2hpbGUgKChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSkge1xyXG4gICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgIGlmIChkYXRhVHlwZVswXSA9PT0gXCIrXCIpIHtcclxuICAgICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSgxKSB8fCBcIipcIjtcclxuICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS51bnNoaWZ0KGZ1bmMpO1xyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS5wdXNoKGZ1bmMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xyXG4gIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKFxyXG4gICAgc3RydWN0dXJlLFxyXG4gICAgb3B0aW9ucyxcclxuICAgIG9yaWdpbmFsT3B0aW9ucyxcclxuICAgIGpxWEhSXHJcbiAgKSB7XHJcbiAgICB2YXIgaW5zcGVjdGVkID0ge30sXHJcbiAgICAgIHNlZWtpbmdUcmFuc3BvcnQgPSBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHM7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xyXG4gICAgICB2YXIgc2VsZWN0ZWQ7XHJcbiAgICAgIGluc3BlY3RlZFtkYXRhVHlwZV0gPSB0cnVlO1xyXG4gICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbiAoXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoXHJcbiAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICAgb3JpZ2luYWxPcHRpb25zLFxyXG4gICAgICAgICAganFYSFJcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICAhc2Vla2luZ1RyYW5zcG9ydCAmJlxyXG4gICAgICAgICAgIWluc3BlY3RlZFtkYXRhVHlwZU9yVHJhbnNwb3J0XVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdChkYXRhVHlwZU9yVHJhbnNwb3J0KTtcclxuICAgICAgICAgIGluc3BlY3QoZGF0YVR5cGVPclRyYW5zcG9ydCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWVraW5nVHJhbnNwb3J0KSB7XHJcbiAgICAgICAgICByZXR1cm4gIShzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zcGVjdChvcHRpb25zLmRhdGFUeXBlc1swXSkgfHwgKCFpbnNwZWN0ZWRbXCIqXCJdICYmIGluc3BlY3QoXCIqXCIpKTtcclxuICB9XHJcblxyXG4gIC8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xyXG4gIC8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXHJcbiAgLy8gRml4ZXMgIzk4ODdcclxuICBmdW5jdGlvbiBhamF4RXh0ZW5kKHRhcmdldCwgc3JjKSB7XHJcbiAgICB2YXIga2V5LFxyXG4gICAgICBkZWVwLFxyXG4gICAgICBmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XHJcblxyXG4gICAgZm9yIChrZXkgaW4gc3JjKSB7XHJcbiAgICAgIGlmIChzcmNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiBkZWVwIHx8IChkZWVwID0ge30pKVtrZXldID0gc3JjW2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChkZWVwKSB7XHJcbiAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgdGFyZ2V0LCBkZWVwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxyXG4gICAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXHJcbiAgICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyhzLCBqcVhIUiwgcmVzcG9uc2VzKSB7XHJcbiAgICB2YXIgY3QsXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIGZpbmFsRGF0YVR5cGUsXHJcbiAgICAgIGZpcnN0RGF0YVR5cGUsXHJcbiAgICAgIGNvbnRlbnRzID0gcy5jb250ZW50cyxcclxuICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcclxuICAgIHdoaWxlIChkYXRhVHlwZXNbMF0gPT09IFwiKlwiKSB7XHJcbiAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xyXG4gICAgICBpZiAoY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxyXG4gICAgaWYgKGN0KSB7XHJcbiAgICAgIGZvciAodHlwZSBpbiBjb250ZW50cykge1xyXG4gICAgICAgIGlmIChjb250ZW50c1t0eXBlXSAmJiBjb250ZW50c1t0eXBlXS50ZXN0KGN0KSkge1xyXG4gICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodHlwZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcclxuICAgIGlmIChkYXRhVHlwZXNbMF0gaW4gcmVzcG9uc2VzKSB7XHJcbiAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXHJcbiAgICAgIGZvciAodHlwZSBpbiByZXNwb25zZXMpIHtcclxuICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdXSkge1xyXG4gICAgICAgICAgZmluYWxEYXRhVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmaXJzdERhdGFUeXBlKSB7XHJcbiAgICAgICAgICBmaXJzdERhdGFUeXBlID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxyXG4gICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcclxuICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXHJcbiAgICAvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXHJcbiAgICBpZiAoZmluYWxEYXRhVHlwZSkge1xyXG4gICAgICBpZiAoZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWzBdKSB7XHJcbiAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoZmluYWxEYXRhVHlwZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3BvbnNlc1tmaW5hbERhdGFUeXBlXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcclxuICAgKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcclxuICAgKi9cclxuICBmdW5jdGlvbiBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcykge1xyXG4gICAgdmFyIGNvbnYyLFxyXG4gICAgICBjdXJyZW50LFxyXG4gICAgICBjb252LFxyXG4gICAgICB0bXAsXHJcbiAgICAgIHByZXYsXHJcbiAgICAgIGNvbnZlcnRlcnMgPSB7fSxcclxuICAgICAgLy8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxyXG4gICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xyXG4gICAgaWYgKGRhdGFUeXBlc1sxXSkge1xyXG4gICAgICBmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XHJcbiAgICAgICAgY29udmVydGVyc1tjb252LnRvTG93ZXJDYXNlKCldID0gcy5jb252ZXJ0ZXJzW2NvbnZdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXHJcbiAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICBpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xyXG4gICAgICAgIGpxWEhSW3MucmVzcG9uc2VGaWVsZHNbY3VycmVudF1dID0gcmVzcG9uc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXHJcbiAgICAgIGlmICghcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIocmVzcG9uc2UsIHMuZGF0YVR5cGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmV2ID0gY3VycmVudDtcclxuICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICBjdXJyZW50ID0gcHJldjtcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50KSB7XHJcbiAgICAgICAgICAvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxyXG4gICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgY3VycmVudF0gfHwgY29udmVydGVyc1tcIiogXCIgKyBjdXJyZW50XTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxyXG4gICAgICAgICAgaWYgKCFjb252KSB7XHJcbiAgICAgICAgICAgIGZvciAoY29udjIgaW4gY29udmVydGVycykge1xyXG4gICAgICAgICAgICAgIC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxyXG4gICAgICAgICAgICAgIHRtcCA9IGNvbnYyLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgICBpZiAodG1wWzFdID09PSBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcclxuICAgICAgICAgICAgICAgIGNvbnYgPVxyXG4gICAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIHRtcFswXV0gfHwgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnYpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW2NvbnYyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnRlcnNbY29udjJdICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFswXTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0bXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxyXG4gICAgICAgICAgaWYgKGNvbnYgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxyXG4gICAgICAgICAgICBpZiAoY29udiAmJiBzLnRocm93cykge1xyXG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGNvbnZcclxuICAgICAgICAgICAgICAgICAgICA/IGVcclxuICAgICAgICAgICAgICAgICAgICA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xyXG4gIH1cclxuXHJcbiAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcclxuICAgIGFjdGl2ZTogMCxcclxuXHJcbiAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XHJcbiAgICBsYXN0TW9kaWZpZWQ6IHt9LFxyXG4gICAgZXRhZzoge30sXHJcblxyXG4gICAgYWpheFNldHRpbmdzOiB7XHJcbiAgICAgIHVybDogbG9jYXRpb24uaHJlZixcclxuICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdChsb2NhdGlvbi5wcm90b2NvbCksXHJcbiAgICAgIGdsb2JhbDogdHJ1ZSxcclxuICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXHJcbiAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcclxuXHJcbiAgICAgIC8qXHJcblx0XHR0aW1lb3V0OiAwLFxyXG5cdFx0ZGF0YTogbnVsbCxcclxuXHRcdGRhdGFUeXBlOiBudWxsLFxyXG5cdFx0dXNlcm5hbWU6IG51bGwsXHJcblx0XHRwYXNzd29yZDogbnVsbCxcclxuXHRcdGNhY2hlOiBudWxsLFxyXG5cdFx0dGhyb3dzOiBmYWxzZSxcclxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcclxuXHRcdGhlYWRlcnM6IHt9LFxyXG5cdFx0Ki9cclxuXHJcbiAgICAgIGFjY2VwdHM6IHtcclxuICAgICAgICBcIipcIjogYWxsVHlwZXMsXHJcbiAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXHJcbiAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcclxuICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxyXG4gICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBjb250ZW50czoge1xyXG4gICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXHJcbiAgICAgICAgaHRtbDogL1xcYmh0bWwvLFxyXG4gICAgICAgIGpzb246IC9cXGJqc29uXFxiLyxcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHJlc3BvbnNlRmllbGRzOiB7XHJcbiAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXHJcbiAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIixcclxuICAgICAgICBqc29uOiBcInJlc3BvbnNlSlNPTlwiLFxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXHJcbiAgICAgIC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcclxuICAgICAgY29udmVydGVyczoge1xyXG4gICAgICAgIC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxyXG4gICAgICAgIFwiKiB0ZXh0XCI6IFN0cmluZyxcclxuXHJcbiAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXHJcbiAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcclxuXHJcbiAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxyXG4gICAgICAgIFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXHJcblxyXG4gICAgICAgIC8vIFBhcnNlIHRleHQgYXMgeG1sXHJcbiAgICAgICAgXCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUwsXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxyXG4gICAgICAvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXHJcbiAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXHJcbiAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxyXG4gICAgICBmbGF0T3B0aW9uczoge1xyXG4gICAgICAgIHVybDogdHJ1ZSxcclxuICAgICAgICBjb250ZXh0OiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxyXG4gICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxyXG4gICAgLy8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cclxuICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gKHRhcmdldCwgc2V0dGluZ3MpIHtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzXHJcbiAgICAgICAgPyAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxyXG4gICAgICAgICAgYWpheEV4dGVuZChhamF4RXh0ZW5kKHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyksIHNldHRpbmdzKVxyXG4gICAgICAgIDogLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xyXG4gICAgICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXHJcbiAgICBhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cyksXHJcblxyXG4gICAgLy8gTWFpbiBtZXRob2RcclxuICAgIGFqYXg6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgLy8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcclxuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBvcHRpb25zID0gdXJsO1xyXG4gICAgICAgIHVybCA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3RcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICB2YXIgdHJhbnNwb3J0LFxyXG4gICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cclxuICAgICAgICBjYWNoZVVSTCxcclxuICAgICAgICAvLyBSZXNwb25zZSBoZWFkZXJzXHJcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxyXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcclxuICAgICAgICAvLyB0aW1lb3V0IGhhbmRsZVxyXG4gICAgICAgIHRpbWVvdXRUaW1lcixcclxuICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcclxuICAgICAgICB1cmxBbmNob3IsXHJcbiAgICAgICAgLy8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxyXG4gICAgICAgIGNvbXBsZXRlZCxcclxuICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcclxuICAgICAgICBmaXJlR2xvYmFscyxcclxuICAgICAgICAvLyBMb29wIHZhcmlhYmxlXHJcbiAgICAgICAgaSxcclxuICAgICAgICAvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcclxuICAgICAgICB1bmNhY2hlZCxcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XHJcbiAgICAgICAgcyA9IGpRdWVyeS5hamF4U2V0dXAoe30sIG9wdGlvbnMpLFxyXG4gICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XHJcbiAgICAgICAgY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXHJcbiAgICAgICAgLy8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxyXG4gICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9XHJcbiAgICAgICAgICBzLmNvbnRleHQgJiYgKGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5KVxyXG4gICAgICAgICAgICA/IGpRdWVyeShjYWxsYmFja0NvbnRleHQpXHJcbiAgICAgICAgICAgIDogalF1ZXJ5LmV2ZW50LFxyXG4gICAgICAgIC8vIERlZmVycmVkc1xyXG4gICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXHJcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xyXG4gICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXHJcbiAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcclxuICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxyXG4gICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcclxuICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcclxuICAgICAgICBzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcclxuICAgICAgICAvLyBGYWtlIHhoclxyXG4gICAgICAgIGpxWEhSID0ge1xyXG4gICAgICAgICAgcmVhZHlTdGF0ZTogMCxcclxuXHJcbiAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXHJcbiAgICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmhlYWRlcnMuZXhlYyhyZXNwb25zZUhlYWRlcnNTdHJpbmcpKSkge1xyXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSA9IChcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSArIFwiIFwiXSB8fCBbXVxyXG4gICAgICAgICAgICAgICAgICApLmNvbmNhdChtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oXCIsIFwiKTtcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgLy8gUmF3IHN0cmluZ1xyXG4gICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAvLyBDYWNoZXMgdGhlIGhlYWRlclxyXG4gICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPVxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XHJcbiAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcclxuICAgICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHMubWltZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xyXG4gICAgICAgICAgc3RhdHVzQ29kZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgICAgICB2YXIgY29kZTtcclxuICAgICAgICAgICAgaWYgKG1hcCkge1xyXG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAganFYSFIuYWx3YXlzKG1hcFtqcVhIUi5zdGF0dXNdKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcclxuICAgICAgICAgICAgICAgIGZvciAoY29kZSBpbiBtYXApIHtcclxuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVtjb2RlXSA9IFtzdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKHN0YXR1c1RleHQpIHtcclxuICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcclxuICAgICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoZmluYWxUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb25lKDAsIGZpbmFsVGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgLy8gQXR0YWNoIGRlZmVycmVkc1xyXG4gICAgICBkZWZlcnJlZC5wcm9taXNlKGpxWEhSKTtcclxuXHJcbiAgICAgIC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxyXG4gICAgICAvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxyXG4gICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcclxuICAgICAgcy51cmwgPSAoKHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmKSArIFwiXCIpLnJlcGxhY2UoXHJcbiAgICAgICAgcnByb3RvY29sLFxyXG4gICAgICAgIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcclxuICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcclxuICAgICAgcy5kYXRhVHlwZXMgPSAocy5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXHJcbiAgICAgICAgXCJcIixcclxuICAgICAgXTtcclxuXHJcbiAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxyXG4gICAgICBpZiAocy5jcm9zc0RvbWFpbiA9PSBudWxsKSB7XHJcbiAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcclxuICAgICAgICAvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxyXG4gICAgICAgIC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcclxuXHJcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XHJcbiAgICAgICAgICAvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxyXG4gICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcclxuICAgICAgICAgIHMuY3Jvc3NEb21haW4gPVxyXG4gICAgICAgICAgICBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cclxuICAgICAgICAgICAgdXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXHJcbiAgICAgICAgICAvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXHJcbiAgICAgICAgICBzLmNyb3NzRG9tYWluID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xyXG4gICAgICBpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbShzLmRhdGEsIHMudHJhZGl0aW9uYWwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXHJcbiAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcclxuXHJcbiAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXHJcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgICByZXR1cm4ganFYSFI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXHJcbiAgICAgIC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXHJcbiAgICAgIGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xyXG5cclxuICAgICAgLy8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xyXG4gICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XHJcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxyXG4gICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XHJcbiAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3Qocy50eXBlKTtcclxuXHJcbiAgICAgIC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxyXG4gICAgICAvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cclxuICAgICAgLy8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxyXG4gICAgICBjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2Uocmhhc2gsIFwiXCIpO1xyXG5cclxuICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcclxuICAgICAgaWYgKCFzLmhhc0NvbnRlbnQpIHtcclxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcclxuICAgICAgICB1bmNhY2hlZCA9IHMudXJsLnNsaWNlKGNhY2hlVVJMLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcclxuICAgICAgICBpZiAocy5kYXRhICYmIChzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIpKSB7XHJcbiAgICAgICAgICBjYWNoZVVSTCArPSAocnF1ZXJ5LnRlc3QoY2FjaGVVUkwpID8gXCImXCIgOiBcIj9cIikgKyBzLmRhdGE7XHJcblxyXG4gICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxyXG4gICAgICAgICAgZGVsZXRlIHMuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcclxuICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZShyYW50aUNhY2hlLCBcIiQxXCIpO1xyXG4gICAgICAgICAgdW5jYWNoZWQgPVxyXG4gICAgICAgICAgICAocnF1ZXJ5LnRlc3QoY2FjaGVVUkwpID8gXCImXCIgOiBcIj9cIikgK1xyXG4gICAgICAgICAgICBcIl89XCIgK1xyXG4gICAgICAgICAgICBub25jZS5ndWlkKysgK1xyXG4gICAgICAgICAgICB1bmNhY2hlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcclxuICAgICAgICBzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XHJcblxyXG4gICAgICAgIC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIHMuZGF0YSAmJlxyXG4gICAgICAgIHMucHJvY2Vzc0RhdGEgJiZcclxuICAgICAgICAocy5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpID09PSAwXHJcbiAgICAgICkge1xyXG4gICAgICAgIHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKHIyMCwgXCIrXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxyXG4gICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XHJcbiAgICAgICAgaWYgKGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKSB7XHJcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxyXG4gICAgICAgICAgICBcIklmLU1vZGlmaWVkLVNpbmNlXCIsXHJcbiAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKSB7XHJcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XHJcbiAgICAgIGlmIChcclxuICAgICAgICAocy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSkgfHxcclxuICAgICAgICBvcHRpb25zLmNvbnRlbnRUeXBlXHJcbiAgICAgICkge1xyXG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcclxuICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcclxuICAgICAgICBcIkFjY2VwdFwiLFxyXG4gICAgICAgIHMuZGF0YVR5cGVzWzBdICYmIHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV1cclxuICAgICAgICAgID8gcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSArXHJcbiAgICAgICAgICAgICAgKHMuZGF0YVR5cGVzWzBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIilcclxuICAgICAgICAgIDogcy5hY2NlcHRzW1wiKlwiXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXHJcbiAgICAgIGZvciAoaSBpbiBzLmhlYWRlcnMpIHtcclxuICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKGksIHMuaGVhZGVyc1tpXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHMuYmVmb3JlU2VuZCAmJlxyXG4gICAgICAgIChzLmJlZm9yZVNlbmQuY2FsbChjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkKVxyXG4gICAgICApIHtcclxuICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cclxuICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXHJcbiAgICAgIHN0ckFib3J0ID0gXCJhYm9ydFwiO1xyXG5cclxuICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXHJcbiAgICAgIGNvbXBsZXRlRGVmZXJyZWQuYWRkKHMuY29tcGxldGUpO1xyXG4gICAgICBqcVhIUi5kb25lKHMuc3VjY2Vzcyk7XHJcbiAgICAgIGpxWEhSLmZhaWwocy5lcnJvcik7XHJcblxyXG4gICAgICAvLyBHZXQgdHJhbnNwb3J0XHJcbiAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcclxuXHJcbiAgICAgIC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxyXG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xyXG4gICAgICAgIGRvbmUoLTEsIFwiTm8gVHJhbnNwb3J0XCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xyXG5cclxuICAgICAgICAvLyBTZW5kIGdsb2JhbCBldmVudFxyXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xyXG4gICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoXCJhamF4U2VuZFwiLCBbanFYSFIsIHNdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXHJcbiAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGpxWEhSO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGltZW91dFxyXG4gICAgICAgIGlmIChzLmFzeW5jICYmIHMudGltZW91dCA+IDApIHtcclxuICAgICAgICAgIHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAganFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xyXG4gICAgICAgICAgfSwgcy50aW1lb3V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKHJlcXVlc3RIZWFkZXJzLCBkb25lKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXHJcbiAgICAgICAgICBpZiAoY29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXHJcbiAgICAgICAgICBkb25lKC0xLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxyXG4gICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XHJcbiAgICAgICAgdmFyIGlzU3VjY2VzcyxcclxuICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgbW9kaWZpZWQsXHJcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xyXG4gICAgICAgIGlmIChjb21wbGV0ZWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgaWYgKHRpbWVvdXRUaW1lcikge1xyXG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cclxuICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxyXG4gICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xyXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcclxuXHJcbiAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcclxuICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxyXG4gICAgICAgIGlzU3VjY2VzcyA9IChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkgfHwgc3RhdHVzID09PSAzMDQ7XHJcblxyXG4gICAgICAgIC8vIEdldCByZXNwb25zZSBkYXRhXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlcykge1xyXG4gICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0XHJcbiAgICAgICAgaWYgKCFpc1N1Y2Nlc3MgJiYgalF1ZXJ5LmluQXJyYXkoXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMpID4gLTEpIHtcclxuICAgICAgICAgIHMuY29udmVydGVyc1tcInRleHQgc2NyaXB0XCJdID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXHJcbiAgICAgICAgcmVzcG9uc2UgPSBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcyk7XHJcblxyXG4gICAgICAgIC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXHJcbiAgICAgICAgaWYgKGlzU3VjY2Vzcykge1xyXG4gICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cclxuICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xyXG4gICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xyXG4gICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gaWYgbm8gY29udGVudFxyXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIpIHtcclxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAzMDQpIHtcclxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcclxuICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXHJcbiAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XHJcbiAgICAgICAgICBpZiAoc3RhdHVzIHx8ICFzdGF0dXNUZXh0KSB7XHJcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgc3RhdHVzID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcclxuICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9IChuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQpICsgXCJcIjtcclxuXHJcbiAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxyXG4gICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcclxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKGNhbGxiYWNrQ29udGV4dCwgW3N1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHQsIGVycm9yXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xyXG4gICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoc3RhdHVzQ29kZSk7XHJcbiAgICAgICAgc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XHJcbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLCBbXHJcbiAgICAgICAgICAgIGpxWEhSLFxyXG4gICAgICAgICAgICBzLFxyXG4gICAgICAgICAgICBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IsXHJcbiAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbXBsZXRlXHJcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aChjYWxsYmFja0NvbnRleHQsIFtqcVhIUiwgc3RhdHVzVGV4dF0pO1xyXG5cclxuICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcclxuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsIFtqcVhIUiwgc10pO1xyXG5cclxuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxyXG4gICAgICAgICAgaWYgKCEtLWpRdWVyeS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBqcVhIUjtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SlNPTjogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeS5nZXQodXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIik7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbiAoX2ksIG1ldGhvZCkge1xyXG4gICAgalF1ZXJ5W21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSkge1xyXG4gICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xyXG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xyXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcclxuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcclxuICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KFxyXG4gICAgICAgIGpRdWVyeS5leHRlbmQoXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBqUXVlcnkuaXNQbGFpbk9iamVjdCh1cmwpICYmIHVybFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSBpbiBzLmhlYWRlcnMpIHtcclxuICAgICAgaWYgKGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikge1xyXG4gICAgICAgIHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbaV0gfHwgXCJcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBkb2MpIHtcclxuICAgIHJldHVybiBqUXVlcnkuYWpheCh7XHJcbiAgICAgIHVybDogdXJsLFxyXG5cclxuICAgICAgLy8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXHJcbiAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxyXG4gICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgYXN5bmM6IGZhbHNlLFxyXG4gICAgICBnbG9iYWw6IGZhbHNlLFxyXG5cclxuICAgICAgLy8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcclxuICAgICAgLy8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcclxuICAgICAgLy8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXHJcbiAgICAgIGNvbnZlcnRlcnM6IHtcclxuICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgICB9LFxyXG4gICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbChyZXNwb25zZSwgb3B0aW9ucywgZG9jKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgd3JhcEFsbDogZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgdmFyIHdyYXA7XHJcblxyXG4gICAgICBpZiAodGhpc1swXSkge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGh0bWwpKSB7XHJcbiAgICAgICAgICBodG1sID0gaHRtbC5jYWxsKHRoaXNbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcclxuICAgICAgICB3cmFwID0galF1ZXJ5KGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUodHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzWzBdLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd3JhcFxyXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChlbGVtLmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5hcHBlbmQodGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGh0bWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lcihodG1sLmNhbGwodGhpcywgaSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSxcclxuICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xyXG5cclxuICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBjb250ZW50cy53cmFwQWxsKGh0bWwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWxmLmFwcGVuZChodG1sKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICB3cmFwOiBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICB2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKGh0bWwpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgIGpRdWVyeSh0aGlzKS53cmFwQWxsKGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bndyYXA6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICB0aGlzLnBhcmVudChzZWxlY3RvcilcclxuICAgICAgICAubm90KFwiYm9keVwiKVxyXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIGpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKGVsZW0pO1xyXG4gIH07XHJcbiAgalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHJldHVybiAhIShcclxuICAgICAgZWxlbS5vZmZzZXRXaWR0aCB8fFxyXG4gICAgICBlbGVtLm9mZnNldEhlaWdodCB8fFxyXG4gICAgICBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XHJcbiAgICAgIC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXHJcbiAgICAgIDA6IDIwMCxcclxuXHJcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XHJcbiAgICAgIC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxyXG4gICAgICAxMjIzOiAyMDQsXHJcbiAgICB9LFxyXG4gICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcclxuXHJcbiAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQ7XHJcbiAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XHJcblxyXG4gIGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XHJcblxyXG4gICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxyXG4gICAgaWYgKHN1cHBvcnQuY29ycyB8fCAoeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChoZWFkZXJzLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIHhociA9IG9wdGlvbnMueGhyKCk7XHJcblxyXG4gICAgICAgICAgeGhyLm9wZW4oXHJcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudXNlcm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmRcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBvcHRpb25zLnhockZpZWxkcykge1xyXG4gICAgICAgICAgICAgIHhocltpXSA9IG9wdGlvbnMueGhyRmllbGRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcclxuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcclxuICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcclxuICAgICAgICAgIC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcclxuICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xyXG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTZXQgaGVhZGVyc1xyXG4gICAgICAgICAgZm9yIChpIGluIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgaGVhZGVyc1tpXSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsbGJhY2tcclxuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxyXG4gICAgICAgICAgICAgICAgICAvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgLy8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxyXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgwLCBcImVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcclxuICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIHhoclN1Y2Nlc3NTdGF0dXNbeGhyLnN0YXR1c10gfHwgeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcclxuICAgICAgICAgICAgICAgICAgICAoeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIikgIT09IFwidGV4dFwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH1cclxuICAgICAgICAgICAgICAgICAgICAgIDogeyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXHJcbiAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBMaXN0ZW4gdG8gZXZlbnRzXHJcbiAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcclxuICAgICAgICAgIGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayhcImVycm9yXCIpO1xyXG5cclxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxyXG4gICAgICAgICAgLy8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcclxuICAgICAgICAgIC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcclxuICAgICAgICAgIGlmICh4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxyXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXHJcbiAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKFwiYWJvcnRcIik7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxyXG4gICAgICAgICAgICB4aHIuc2VuZCgob3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSkgfHwgbnVsbCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcclxuICBqUXVlcnkuYWpheFByZWZpbHRlcihmdW5jdGlvbiAocykge1xyXG4gICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcclxuICAgICAgcy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcclxuICBqUXVlcnkuYWpheFNldHVwKHtcclxuICAgIGFjY2VwdHM6IHtcclxuICAgICAgc2NyaXB0OlxyXG4gICAgICAgIFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXHJcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIixcclxuICAgIH0sXHJcbiAgICBjb250ZW50czoge1xyXG4gICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiLyxcclxuICAgIH0sXHJcbiAgICBjb252ZXJ0ZXJzOiB7XHJcbiAgICAgIFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cclxuICBqUXVlcnkuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAocykge1xyXG4gICAgaWYgKHMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzLmNhY2hlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocy5jcm9zc0RvbWFpbikge1xyXG4gICAgICBzLnR5cGUgPSBcIkdFVFwiO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcclxuICBqUXVlcnkuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLCBmdW5jdGlvbiAocykge1xyXG4gICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcclxuICAgIGlmIChzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMpIHtcclxuICAgICAgdmFyIHNjcmlwdCwgY2FsbGJhY2s7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBzY3JpcHQgPSBqUXVlcnkoXCI8c2NyaXB0PlwiKVxyXG4gICAgICAgICAgICAuYXR0cihzLnNjcmlwdEF0dHJzIHx8IHt9KVxyXG4gICAgICAgICAgICAucHJvcCh7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9KVxyXG4gICAgICAgICAgICAub24oXHJcbiAgICAgICAgICAgICAgXCJsb2FkIGVycm9yXCIsXHJcbiAgICAgICAgICAgICAgKGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZShldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcclxuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0WzBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICB2YXIgb2xkQ2FsbGJhY2tzID0gW10sXHJcbiAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xyXG5cclxuICAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXHJcbiAgalF1ZXJ5LmFqYXhTZXR1cCh7XHJcbiAgICBqc29ucDogXCJjYWxsYmFja1wiLFxyXG4gICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArIG5vbmNlLmd1aWQrKztcclxuICAgICAgdGhpc1tjYWxsYmFja10gPSB0cnVlO1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICAvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcclxuICBqUXVlcnkuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIiwgZnVuY3Rpb24gKHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSKSB7XHJcbiAgICB2YXIgY2FsbGJhY2tOYW1lLFxyXG4gICAgICBvdmVyd3JpdHRlbixcclxuICAgICAgcmVzcG9uc2VDb250YWluZXIsXHJcbiAgICAgIGpzb25Qcm9wID1cclxuICAgICAgICBzLmpzb25wICE9PSBmYWxzZSAmJlxyXG4gICAgICAgIChyanNvbnAudGVzdChzLnVybClcclxuICAgICAgICAgID8gXCJ1cmxcIlxyXG4gICAgICAgICAgOiB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICAgIChzLmNvbnRlbnRUeXBlIHx8IFwiXCIpLmluZGV4T2YoXHJcbiAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxyXG4gICAgICAgICAgICApID09PSAwICYmXHJcbiAgICAgICAgICAgIHJqc29ucC50ZXN0KHMuZGF0YSkgJiZcclxuICAgICAgICAgICAgXCJkYXRhXCIpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcclxuICAgIGlmIChqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1swXSA9PT0gXCJqc29ucFwiKSB7XHJcbiAgICAgIC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcclxuICAgICAgY2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbihzLmpzb25wQ2FsbGJhY2spXHJcbiAgICAgICAgPyBzLmpzb25wQ2FsbGJhY2soKVxyXG4gICAgICAgIDogcy5qc29ucENhbGxiYWNrO1xyXG5cclxuICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxyXG4gICAgICBpZiAoanNvblByb3ApIHtcclxuICAgICAgICBzW2pzb25Qcm9wXSA9IHNbanNvblByb3BdLnJlcGxhY2Uocmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgcy51cmwgKz1cclxuICAgICAgICAgIChycXVlcnkudGVzdChzLnVybCkgPyBcIiZcIiA6IFwiP1wiKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxyXG4gICAgICBzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICBqUXVlcnkuZXJyb3IoY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclswXTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcclxuICAgICAgcy5kYXRhVHlwZXNbMF0gPSBcImpzb25cIjtcclxuXHJcbiAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcclxuICAgICAgb3ZlcndyaXR0ZW4gPSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcclxuICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcclxuICAgICAganFYSFIuYWx3YXlzKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcclxuICAgICAgICBpZiAob3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgalF1ZXJ5KHdpbmRvdykucmVtb3ZlUHJvcChjYWxsYmFja05hbWUpO1xyXG5cclxuICAgICAgICAgIC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gb3ZlcndyaXR0ZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxyXG4gICAgICAgIGlmIChzW2NhbGxiYWNrTmFtZV0pIHtcclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxyXG4gICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xyXG5cclxuICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcclxuICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcclxuICAgICAgICBpZiAocmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbihvdmVyd3JpdHRlbikpIHtcclxuICAgICAgICAgIG92ZXJ3cml0dGVuKHJlc3BvbnNlQ29udGFpbmVyWzBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XHJcbiAgICAgIHJldHVybiBcInNjcmlwdFwiO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XHJcbiAgLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxyXG4gIC8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxyXG4gIC8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cclxuICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XHJcbiAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keTtcclxuICAgIGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xyXG4gICAgcmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXHJcbiAgLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxyXG4gIC8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XHJcbiAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xyXG4gIGpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMpIHtcclxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcclxuICAgICAgY29udGV4dCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgIC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxyXG4gICAgICAvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxyXG4gICAgICBpZiAoc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQpIHtcclxuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcclxuICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xyXG4gICAgICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXHJcbiAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XHJcbiAgICAgICAgYmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcclxuICAgICAgICBjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoYmFzZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKGRhdGEpO1xyXG4gICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcclxuXHJcbiAgICAvLyBTaW5nbGUgdGFnXHJcbiAgICBpZiAocGFyc2VkKSB7XHJcbiAgICAgIHJldHVybiBbY29udGV4dC5jcmVhdGVFbGVtZW50KHBhcnNlZFsxXSldO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcclxuXHJcbiAgICBpZiAoc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCkge1xyXG4gICAgICBqUXVlcnkoc2NyaXB0cykucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgcGFyc2VkLmNoaWxkTm9kZXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcclxuICAgKi9cclxuICBqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuICAgIHZhciBzZWxlY3RvcixcclxuICAgICAgdHlwZSxcclxuICAgICAgcmVzcG9uc2UsXHJcbiAgICAgIHNlbGYgPSB0aGlzLFxyXG4gICAgICBvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XHJcblxyXG4gICAgaWYgKG9mZiA+IC0xKSB7XHJcbiAgICAgIHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSh1cmwuc2xpY2Uob2ZmKSk7XHJcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxyXG4gICAgaWYgKGlzRnVuY3Rpb24ocGFyYW1zKSkge1xyXG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xyXG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcclxuICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xyXG4gICAgfSBlbHNlIGlmIChwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICB0eXBlID0gXCJQT1NUXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcclxuICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHtcclxuICAgICAgalF1ZXJ5XHJcbiAgICAgICAgLmFqYXgoe1xyXG4gICAgICAgICAgdXJsOiB1cmwsXHJcblxyXG4gICAgICAgICAgLy8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxyXG4gICAgICAgICAgLy8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXHJcbiAgICAgICAgICB0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXHJcbiAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXHJcbiAgICAgICAgICBkYXRhOiBwYXJhbXMsXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZG9uZShmdW5jdGlvbiAocmVzcG9uc2VUZXh0KSB7XHJcbiAgICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcclxuICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICAgIHNlbGYuaHRtbChcclxuICAgICAgICAgICAgc2VsZWN0b3JcclxuICAgICAgICAgICAgICA/IC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxyXG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKVxyXG4gICAgICAgICAgICAgICAgICAuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSlcclxuICAgICAgICAgICAgICAgICAgLmZpbmQoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgOiAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxyXG4gICAgICAgICAgLy8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxyXG4gICAgICAgICAgLy8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmFsd2F5cyhcclxuICAgICAgICAgIGNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChqcVhIUiwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KFxyXG4gICAgICAgICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSB8fCBbanFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xyXG4gICAgfSkubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIGpRdWVyeS5vZmZzZXQgPSB7XHJcbiAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBpKSB7XHJcbiAgICAgIHZhciBjdXJQb3NpdGlvbixcclxuICAgICAgICBjdXJMZWZ0LFxyXG4gICAgICAgIGN1ckNTU1RvcCxcclxuICAgICAgICBjdXJUb3AsXHJcbiAgICAgICAgY3VyT2Zmc2V0LFxyXG4gICAgICAgIGN1ckNTU0xlZnQsXHJcbiAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24sXHJcbiAgICAgICAgcG9zaXRpb24gPSBqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIiksXHJcbiAgICAgICAgY3VyRWxlbSA9IGpRdWVyeShlbGVtKSxcclxuICAgICAgICBwcm9wcyA9IHt9O1xyXG5cclxuICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxyXG4gICAgICBpZiAocG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcclxuICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xyXG4gICAgICBjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKGVsZW0sIFwidG9wXCIpO1xyXG4gICAgICBjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyhlbGVtLCBcImxlZnRcIik7XHJcbiAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID1cclxuICAgICAgICAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSAmJlxyXG4gICAgICAgIChjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0KS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xyXG5cclxuICAgICAgLy8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcclxuICAgICAgLy8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXHJcbiAgICAgIGlmIChjYWxjdWxhdGVQb3NpdGlvbikge1xyXG4gICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcclxuICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJUb3AgPSBwYXJzZUZsb2F0KGN1ckNTU1RvcCkgfHwgMDtcclxuICAgICAgICBjdXJMZWZ0ID0gcGFyc2VGbG9hdChjdXJDU1NMZWZ0KSB8fCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xyXG4gICAgICAgIC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCh7fSwgY3VyT2Zmc2V0KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvcHMudG9wID0gb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICsgY3VyVG9wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHByb3BzLmxlZnQgPSBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCArIGN1ckxlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcInVzaW5nXCIgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbChlbGVtLCBwcm9wcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy50b3AgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIHByb3BzLnRvcCArPSBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHMubGVmdCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgcHJvcHMubGVmdCArPSBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgIC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxyXG4gICAgb2Zmc2V0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyB0aGlzXHJcbiAgICAgICAgICA6IHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgIGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIG9wdGlvbnMsIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlY3QsXHJcbiAgICAgICAgd2luLFxyXG4gICAgICAgIGVsZW0gPSB0aGlzWzBdO1xyXG5cclxuICAgICAgaWYgKCFlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcclxuICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XHJcbiAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcclxuICAgICAgLy8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXHJcbiAgICAgIGlmICghZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXHJcbiAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICB3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcclxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XHJcbiAgICAvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcclxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghdGhpc1swXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9mZnNldFBhcmVudCxcclxuICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgZG9jLFxyXG4gICAgICAgIGVsZW0gPSB0aGlzWzBdLFxyXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcblxyXG4gICAgICAvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxyXG4gICAgICBpZiAoalF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpID09PSBcImZpeGVkXCIpIHtcclxuICAgICAgICAvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XHJcbiAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xyXG5cclxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxyXG4gICAgICAgIC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXHJcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50ICYmXHJcbiAgICAgICAgICAob2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQpICYmXHJcbiAgICAgICAgICBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIlxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIG9mZnNldFBhcmVudCAmJlxyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmXHJcbiAgICAgICAgICBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDFcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxyXG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0galF1ZXJ5KG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XHJcbiAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUpO1xyXG4gICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyhcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50LFxyXG4gICAgICAgICAgICBcImJvcmRlckxlZnRXaWR0aFwiLFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDpcclxuICAgICAgICAgIG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlKSxcclxuICAgICAgICBsZWZ0OlxyXG4gICAgICAgICAgb2Zmc2V0LmxlZnQgLVxyXG4gICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgLVxyXG4gICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSksXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxyXG4gICAgLy8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxyXG4gICAgLy8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XHJcbiAgICAvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XHJcbiAgICAvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXHJcbiAgICAvL1xyXG4gICAgLy8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXHJcbiAgICAvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxyXG4gICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xyXG5cclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgJiZcclxuICAgICAgICAgIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXHJcbiAgalF1ZXJ5LmVhY2goXHJcbiAgICB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSxcclxuICAgIGZ1bmN0aW9uIChtZXRob2QsIHByb3ApIHtcclxuICAgICAgdmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcclxuXHJcbiAgICAgIGpRdWVyeS5mblttZXRob2RdID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBhY2Nlc3MoXHJcbiAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCwgdmFsKSB7XHJcbiAgICAgICAgICAgIC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xyXG4gICAgICAgICAgICB2YXIgd2luO1xyXG4gICAgICAgICAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcclxuICAgICAgICAgICAgICB3aW4gPSBlbGVtO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICB3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gd2luID8gd2luW3Byb3BdIDogZWxlbVttZXRob2RdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2luKSB7XHJcbiAgICAgICAgICAgICAgd2luLnNjcm9sbFRvKFxyXG4gICAgICAgICAgICAgICAgIXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcclxuICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZWxlbVttZXRob2RdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgdmFsLFxyXG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxyXG4gIC8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXHJcbiAgLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XHJcbiAgLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcclxuICAvLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xyXG4gIC8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXHJcbiAgalF1ZXJ5LmVhY2goW1widG9wXCIsIFwibGVmdFwiXSwgZnVuY3Rpb24gKF9pLCBwcm9wKSB7XHJcbiAgICBqUXVlcnkuY3NzSG9va3NbcHJvcF0gPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbiAoXHJcbiAgICAgIGVsZW0sXHJcbiAgICAgIGNvbXB1dGVkXHJcbiAgICApIHtcclxuICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgY29tcHV0ZWQgPSBjdXJDU1MoZWxlbSwgcHJvcCk7XHJcblxyXG4gICAgICAgIC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxyXG4gICAgICAgIHJldHVybiBybnVtbm9ucHgudGVzdChjb21wdXRlZClcclxuICAgICAgICAgID8galF1ZXJ5KGVsZW0pLnBvc2l0aW9uKClbcHJvcF0gKyBcInB4XCJcclxuICAgICAgICAgIDogY29tcHV0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcclxuICBqUXVlcnkuZWFjaCh7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xyXG4gICAgalF1ZXJ5LmVhY2goXHJcbiAgICAgIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxyXG4gICAgICBmdW5jdGlvbiAoZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSkge1xyXG4gICAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxyXG4gICAgICAgIGpRdWVyeS5mbltmdW5jTmFtZV0gPSBmdW5jdGlvbiAobWFyZ2luLCB2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGNoYWluYWJsZSA9XHJcbiAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAmJiAoZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiKSxcclxuICAgICAgICAgICAgZXh0cmEgPVxyXG4gICAgICAgICAgICAgIGRlZmF1bHRFeHRyYSB8fFxyXG4gICAgICAgICAgICAgIChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFjY2VzcyhcclxuICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGRvYztcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoXCJvdXRlclwiKSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICA/IGVsZW1bXCJpbm5lclwiICsgbmFtZV1cclxuICAgICAgICAgICAgICAgICAgOiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgbmFtZV07XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICBkb2NbXCJzY3JvbGxcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJvZmZzZXRcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICBkb2NbXCJvZmZzZXRcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICBkb2NbXCJjbGllbnRcIiArIG5hbWVdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxyXG4gICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIHR5cGUsIGV4dHJhKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNoYWluYWJsZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICBqUXVlcnkuZWFjaChcclxuICAgIFtcclxuICAgICAgXCJhamF4U3RhcnRcIixcclxuICAgICAgXCJhamF4U3RvcFwiLFxyXG4gICAgICBcImFqYXhDb21wbGV0ZVwiLFxyXG4gICAgICBcImFqYXhFcnJvclwiLFxyXG4gICAgICBcImFqYXhTdWNjZXNzXCIsXHJcbiAgICAgIFwiYWpheFNlbmRcIixcclxuICAgIF0sXHJcbiAgICBmdW5jdGlvbiAoX2ksIHR5cGUpIHtcclxuICAgICAgalF1ZXJ5LmZuW3R5cGVdID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZm4pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgYmluZDogZnVuY3Rpb24gKHR5cGVzLCBkYXRhLCBmbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlcywgbnVsbCwgZGF0YSwgZm4pO1xyXG4gICAgfSxcclxuICAgIHVuYmluZDogZnVuY3Rpb24gKHR5cGVzLCBmbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmYodHlwZXMsIG51bGwsIGZuKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xyXG4gICAgfSxcclxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGZuKSB7XHJcbiAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcclxuICAgICAgICA/IHRoaXMub2ZmKHNlbGVjdG9yLCBcIioqXCIpXHJcbiAgICAgICAgOiB0aGlzLm9mZih0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbik7XHJcbiAgICB9LFxyXG5cclxuICAgIGhvdmVyOiBmdW5jdGlvbiAoZm5PdmVyLCBmbk91dCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCB8fCBmbk92ZXIpO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgalF1ZXJ5LmVhY2goXHJcbiAgICAoXHJcbiAgICAgIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xyXG4gICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcclxuICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCJcclxuICAgICkuc3BsaXQoXCIgXCIpLFxyXG4gICAgZnVuY3Rpb24gKF9pLCBuYW1lKSB7XHJcbiAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXHJcbiAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xyXG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMFxyXG4gICAgICAgICAgPyB0aGlzLm9uKG5hbWUsIG51bGwsIGRhdGEsIGZuKVxyXG4gICAgICAgICAgOiB0aGlzLnRyaWdnZXIobmFtZSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgKTtcclxuXHJcbiAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XHJcbiAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXHJcbiAgdmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xyXG5cclxuICAvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcclxuICAvLyBhcmd1bWVudHMuXHJcbiAgLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxyXG4gIC8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxyXG4gIGpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xyXG4gICAgdmFyIHRtcCwgYXJncywgcHJveHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xyXG4gICAgICBjb250ZXh0ID0gZm47XHJcbiAgICAgIGZuID0gdG1wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXHJcbiAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpbXVsYXRlZCBiaW5kXHJcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgcHJveHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xyXG5cclxuICAgIHJldHVybiBwcm94eTtcclxuICB9O1xyXG5cclxuICBqUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24gKGhvbGQpIHtcclxuICAgIGlmIChob2xkKSB7XHJcbiAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGpRdWVyeS5yZWFkeSh0cnVlKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcclxuICBqUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcclxuICBqUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcbiAgalF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XHJcbiAgalF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcclxuICBqUXVlcnkudHlwZSA9IHRvVHlwZTtcclxuXHJcbiAgalF1ZXJ5Lm5vdyA9IERhdGUubm93O1xyXG5cclxuICBqUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgLy8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cclxuICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcclxuICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXHJcbiAgICB2YXIgdHlwZSA9IGpRdWVyeS50eXBlKG9iaik7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSAmJlxyXG4gICAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcclxuICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxyXG4gICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cclxuICAgICAgIWlzTmFOKG9iaiAtIHBhcnNlRmxvYXQob2JqKSlcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgalF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/IFwiXCIgOiAodGV4dCArIFwiXCIpLnJlcGxhY2UocnRyaW0sIFwiXCIpO1xyXG4gIH07XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxyXG4gIC8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcclxuICAvLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3RcclxuICAvLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXHJcbiAgLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXHJcbiAgLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXHJcbiAgLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxyXG5cclxuICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxyXG4gIC8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cclxuICAvLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cclxuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGpRdWVyeTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxyXG4gICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXHJcbiAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxyXG4gICAgXyQgPSB3aW5kb3cuJDtcclxuXHJcbiAgalF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoZGVlcCkge1xyXG4gICAgaWYgKHdpbmRvdy4kID09PSBqUXVlcnkpIHtcclxuICAgICAgd2luZG93LiQgPSBfJDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkpIHtcclxuICAgICAgd2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGpRdWVyeTtcclxuICB9O1xyXG5cclxuICAvLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxyXG4gIC8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcclxuICAvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXHJcbiAgaWYgKHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGpRdWVyeTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwibW9kdWxlIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJ0aGlzIiwibm9HbG9iYWwiLCJhcnIiLCJnZXRQcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic2xpY2UiLCJmbGF0IiwiYXJyYXkiLCJjYWxsIiwiY29uY2F0IiwiYXBwbHkiLCJwdXNoIiwiaW5kZXhPZiIsImNsYXNzMnR5cGUiLCJ0b1N0cmluZyIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZm5Ub1N0cmluZyIsIk9iamVjdEZ1bmN0aW9uU3RyaW5nIiwic3VwcG9ydCIsImlzRnVuY3Rpb24iLCJvYmoiLCJub2RlVHlwZSIsImlzV2luZG93IiwicHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyIsInR5cGUiLCJzcmMiLCJub25jZSIsIm5vTW9kdWxlIiwiRE9NRXZhbCIsImNvZGUiLCJub2RlIiwiZG9jIiwiaSIsInZhbCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9UeXBlIiwidmVyc2lvbiIsImpRdWVyeSIsInNlbGVjdG9yIiwiY29udGV4dCIsImZuIiwiaW5pdCIsInByb3RvdHlwZSIsImpxdWVyeSIsImNvbnN0cnVjdG9yIiwibGVuZ3RoIiwidG9BcnJheSIsImdldCIsIm51bSIsInB1c2hTdGFjayIsImVsZW1zIiwicmV0IiwibWVyZ2UiLCJwcmV2T2JqZWN0IiwiZWFjaCIsImNhbGxiYWNrIiwibWFwIiwiZWxlbSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwiZXZlbiIsImdyZXAiLCJfZWxlbSIsIm9kZCIsImxlbiIsImoiLCJlbmQiLCJzb3J0Iiwic3BsaWNlIiwiZXh0ZW5kIiwib3B0aW9ucyIsIm5hbWUiLCJjb3B5IiwiY29weUlzQXJyYXkiLCJjbG9uZSIsInRhcmdldCIsImRlZXAiLCJpc1BsYWluT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiZXhwYW5kbyIsIk1hdGgiLCJyYW5kb20iLCJyZXBsYWNlIiwiaXNSZWFkeSIsImVycm9yIiwibXNnIiwibm9vcCIsInByb3RvIiwiQ3RvciIsImlzRW1wdHlPYmplY3QiLCJnbG9iYWxFdmFsIiwiaXNBcnJheUxpa2UiLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiaW5BcnJheSIsInNlY29uZCIsImludmVydCIsImNhbGxiYWNrSW52ZXJzZSIsIm1hdGNoZXMiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsInZhbHVlIiwiZ3VpZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic3BsaXQiLCJfaSIsInRvTG93ZXJDYXNlIiwiU2l6emxlIiwiRXhwciIsImdldFRleHQiLCJpc1hNTCIsInRva2VuaXplIiwiY29tcGlsZSIsInNlbGVjdCIsIm91dGVybW9zdENvbnRleHQiLCJzb3J0SW5wdXQiLCJoYXNEdXBsaWNhdGUiLCJzZXREb2N1bWVudCIsImRvY0VsZW0iLCJkb2N1bWVudElzSFRNTCIsInJidWdneVFTQSIsInJidWdneU1hdGNoZXMiLCJjb250YWlucyIsIkRhdGUiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwibm9ubmF0aXZlU2VsZWN0b3JDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwicG9wIiwicHVzaE5hdGl2ZSIsImxpc3QiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJyd2hpdGVzcGFjZSIsIlJlZ0V4cCIsInJ0cmltIiwicmNvbW1hIiwicmNvbWJpbmF0b3JzIiwicmRlc2NlbmQiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJJRCIsIkNMQVNTIiwiVEFHIiwiQVRUUiIsIlBTRVVETyIsIkNISUxEIiwiYm9vbCIsIm5lZWRzQ29udGV4dCIsInJodG1sIiwicmlucHV0cyIsInJoZWFkZXIiLCJybmF0aXZlIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiZXNjYXBlIiwibm9uSGV4IiwiaGlnaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJjc3Nlc2NhcGUiLCJmY3NzZXNjYXBlIiwiY2giLCJhc0NvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJ1bmxvYWRIYW5kbGVyIiwiaW5EaXNhYmxlZEZpZWxkc2V0IiwiYWRkQ29tYmluYXRvciIsImRpc2FibGVkIiwibm9kZU5hbWUiLCJkaXIiLCJuZXh0IiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsInRlc3RDb250ZXh0Iiwic2NvcGUiLCJ0b1NlbGVjdG9yIiwiam9pbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsInJlbW92ZUF0dHJpYnV0ZSIsImtleXMiLCJjYWNoZSIsImtleSIsImNhY2hlTGVuZ3RoIiwic2hpZnQiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJjdXIiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwiZG9jdW1lbnRFbGVtZW50IiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbHRlciIsImF0dHJJZCIsImZpbmQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwidG1wIiwiaW5wdXQiLCJpbm5lckhUTUwiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwic3BlY2lmaWVkIiwic2VsIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0IiwiX2FyZ3VtZW50Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsIl9jb250ZXh0IiwieG1sIiwidW5pcXVlQ2FjaGUiLCJvdXRlckNhY2hlIiwibm9kZUluZGV4Iiwic3RhcnQiLCJwYXJlbnQiLCJ1c2VDYWNoZSIsImxhc3RDaGlsZCIsInVuaXF1ZUlEIiwicHNldWRvIiwiYXJncyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibm90IiwibWF0Y2hlciIsInVubWF0Y2hlZCIsImhhcyIsImxhbmciLCJlbGVtTGFuZyIsImhhc2giLCJsb2NhdGlvbiIsInJvb3QiLCJmb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImVuYWJsZWQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiZW1wdHkiLCJoZWFkZXIiLCJidXR0b24iLCJfbWF0Y2hJbmRleGVzIiwibHQiLCJndCIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsInJlc2V0IiwiZmlsdGVycyIsInBhcnNlT25seSIsInRva2VucyIsInNvRmFyIiwicHJlRmlsdGVycyIsImNhY2hlZCIsImNvbWJpbmF0b3IiLCJiYXNlIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJ0ZW1wIiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJ0b2tlbiIsImNvbXBpbGVkIiwiX25hbWUiLCJkZWZhdWx0VmFsdWUiLCJ1bmlxdWUiLCJpc1hNTERvYyIsImVzY2FwZVNlbGVjdG9yIiwidW50aWwiLCJ0cnVuY2F0ZSIsImlzIiwic2libGluZ3MiLCJuIiwicm5lZWRzQ29udGV4dCIsInJzaW5nbGVUYWciLCJ3aW5ub3ciLCJxdWFsaWZpZXIiLCJzZWxmIiwicm9vdGpRdWVyeSIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJwcmV2IiwidGFyZ2V0cyIsImwiLCJjbG9zZXN0IiwiaW5kZXgiLCJwcmV2QWxsIiwiYWRkIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnQiLCJyZXZlcnNlIiwicm5vdGh0bWx3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJfIiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwibG9ja2VkIiwicXVldWUiLCJmaXJpbmdJbmRleCIsImZpcmUiLCJvbmNlIiwic3RvcE9uRmFsc2UiLCJyZW1vdmUiLCJkaXNhYmxlIiwibG9jayIsImZpcmVXaXRoIiwiSWRlbnRpdHkiLCJ2IiwiVGhyb3dlciIsImV4IiwiYWRvcHRWYWx1ZSIsInJlc29sdmUiLCJyZWplY3QiLCJub1ZhbHVlIiwibWV0aG9kIiwicHJvbWlzZSIsImZhaWwiLCJ0aGVuIiwiRGVmZXJyZWQiLCJmdW5jIiwidHVwbGVzIiwic3RhdGUiLCJhbHdheXMiLCJkZWZlcnJlZCIsImNhdGNoIiwicGlwZSIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInByb2dyZXNzIiwibm90aWZ5Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsIm1heERlcHRoIiwiZGVwdGgiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9jZXNzIiwiZXhjZXB0aW9uSG9vayIsInN0YWNrVHJhY2UiLCJyZWplY3RXaXRoIiwiZ2V0U3RhY2tIb29rIiwic2V0VGltZW91dCIsInN0YXRlU3RyaW5nIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsIm1hc3RlciIsInVwZGF0ZUZ1bmMiLCJyZXJyb3JOYW1lcyIsInN0YWNrIiwiY29uc29sZSIsIndhcm4iLCJtZXNzYWdlIiwicmVhZHlFeGNlcHRpb24iLCJyZWFkeUxpc3QiLCJyZWFkeVdhaXQiLCJ3YWl0IiwiY29tcGxldGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsIl9rZXkiLCJybXNQcmVmaXgiLCJyZGFzaEFscGhhIiwiZmNhbWVsQ2FzZSIsIl9hbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInNldCIsImRhdGEiLCJwcm9wIiwiaGFzRGF0YSIsImRhdGFQcml2IiwiZGF0YVVzZXIiLCJyYnJhY2UiLCJybXVsdGlEYXNoIiwiZ2V0RGF0YSIsIkpTT04iLCJwYXJzZSIsImRhdGFBdHRyIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJkZXF1ZXVlIiwic3RhcnRMZW5ndGgiLCJob29rcyIsIl9xdWV1ZUhvb2tzIiwic3RvcCIsInNldHRlciIsImNsZWFyUXVldWUiLCJjb3VudCIsImRlZmVyIiwicG51bSIsInNvdXJjZSIsInJjc3NOdW0iLCJjc3NFeHBhbmQiLCJpc0F0dGFjaGVkIiwiY29tcG9zZWQiLCJnZXRSb290Tm9kZSIsImlzSGlkZGVuV2l0aGluVHJlZSIsInN0eWxlIiwiZGlzcGxheSIsImNzcyIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZGl2IiwiY2hlY2tDbG9uZSIsImNsb25lTm9kZSIsIm5vQ2xvbmVDaGVja2VkIiwib3B0aW9uIiwid3JhcE1hcCIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0IiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwib3B0Z3JvdXAiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJidWlsZEZyYWdtZW50Iiwic2NyaXB0cyIsInNlbGVjdGlvbiIsImlnbm9yZWQiLCJ3cmFwIiwiYXR0YWNoZWQiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJleHBlY3RTeW5jIiwic2FmZUFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJvbiIsInR5cGVzIiwib25lIiwib3JpZ0ZuIiwiZXZlbnQiLCJvZmYiLCJoYW5kbGVPYmpJbiIsImV2ZW50SGFuZGxlIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJjcmVhdGUiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwibmF0aXZlRXZlbnQiLCJoYW5kbGVyUXVldWUiLCJmaXgiLCJkZWxlZ2F0ZVRhcmdldCIsInByZURpc3BhdGNoIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJtYXRjaGVkSGFuZGxlcnMiLCJtYXRjaGVkU2VsZWN0b3JzIiwiYWRkUHJvcCIsImhvb2siLCJFdmVudCIsImVudW1lcmFibGUiLCJvcmlnaW5hbEV2ZW50Iiwid3JpdGFibGUiLCJsb2FkIiwibm9CdWJibGUiLCJjbGljayIsImxldmVyYWdlTmF0aXZlIiwidHJpZ2dlciIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwibm90QXN5bmMiLCJzYXZlZCIsImlzVHJpZ2dlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInByb3BzIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJub3ciLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJjdHJsS2V5IiwiZGV0YWlsIiwiZXZlbnRQaGFzZSIsIm1ldGFLZXkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJ2aWV3IiwiY2hhciIsImNoYXJDb2RlIiwia2V5Q29kZSIsImJ1dHRvbnMiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicG9pbnRlcklkIiwicG9pbnRlclR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRhcmdldFRvdWNoZXMiLCJ0b0VsZW1lbnQiLCJ0b3VjaGVzIiwid2hpY2giLCJibHVyIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJub0lubmVyaHRtbCIsInJjaGVja2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiZGlzYWJsZVNjcmlwdCIsInJlc3RvcmVTY3JpcHQiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJwZGF0YU9sZCIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsInZhbHVlSXNGdW5jdGlvbiIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJpbnNlcnQiLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwic3dhcCIsIm9sZCIsInJib3hTdHlsZSIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY29udGFpbmVyIiwiY3NzVGV4dCIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJyaWdodCIsInBpeGVsQm94U3R5bGVzVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm9mZnNldFdpZHRoIiwibWVhc3VyZSIsInJvdW5kIiwicGFyc2VGbG9hdCIsInJlbGlhYmxlVHJEaW1lbnNpb25zVmFsIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsQm94U3R5bGVzIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luTGVmdCIsInNjcm9sbGJveFNpemUiLCJyZWxpYWJsZVRyRGltZW5zaW9ucyIsInRhYmxlIiwidHJDaGlsZCIsInRyU3R5bGUiLCJoZWlnaHQiLCJwYXJzZUludCIsImN1ckNTUyIsImNvbXB1dGVkIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BzIiwidmVuZG9yUHJvcE5hbWUiLCJjYXBOYW1lIiwiZmluYWxQcm9wTmFtZSIsImZpbmFsIiwiY3NzUHJvcHMiLCJyZGlzcGxheXN3YXAiLCJyY3VzdG9tUHJvcCIsImNzc1Nob3ciLCJ2aXNpYmlsaXR5IiwiY3NzTm9ybWFsVHJhbnNmb3JtIiwibGV0dGVyU3BhY2luZyIsImZvbnRXZWlnaHQiLCJzZXRQb3NpdGl2ZU51bWJlciIsInN1YnRyYWN0IiwibWF4IiwiYm94TW9kZWxBZGp1c3RtZW50IiwiZGltZW5zaW9uIiwiYm94IiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJjb21wdXRlZFZhbCIsImV4dHJhIiwiZGVsdGEiLCJjZWlsIiwiZ2V0V2lkdGhPckhlaWdodCIsImJveFNpemluZ05lZWRlZCIsInZhbHVlSXNCb3JkZXJCb3giLCJvZmZzZXRQcm9wIiwiZ2V0Q2xpZW50UmVjdHMiLCJjc3NIb29rcyIsIm9wYWNpdHkiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImNvbHVtbkNvdW50IiwiZmlsbE9wYWNpdHkiLCJmbGV4R3JvdyIsImZsZXhTaHJpbmsiLCJncmlkQXJlYSIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblN0YXJ0IiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3RhcnQiLCJsaW5lSGVpZ2h0Iiwib3JkZXIiLCJvcnBoYW5zIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsIm9yaWdOYW1lIiwiaXNDdXN0b21Qcm9wIiwic2V0UHJvcGVydHkiLCJpc0Zpbml0ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbGJveFNpemVCdWdneSIsImxlZnQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm9yZGVyIiwicHJlZml4Iiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsIlR3ZWVuIiwiZWFzaW5nIiwicHJvcEhvb2tzIiwicnVuIiwicGVyY2VudCIsImVhc2VkIiwiZHVyYXRpb24iLCJwb3MiLCJzdGVwIiwiZngiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibGluZWFyIiwicCIsInN3aW5nIiwiY29zIiwiUEkiLCJmeE5vdyIsImluUHJvZ3Jlc3MiLCJyZnh0eXBlcyIsInJydW4iLCJzY2hlZHVsZSIsImhpZGRlbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImludGVydmFsIiwidGljayIsImNyZWF0ZUZ4Tm93IiwiZ2VuRngiLCJpbmNsdWRlV2lkdGgiLCJjcmVhdGVUd2VlbiIsImFuaW1hdGlvbiIsIkFuaW1hdGlvbiIsInR3ZWVuZXJzIiwiZGVmYXVsdFByZWZpbHRlciIsIm9wdHMiLCJvbGRmaXJlIiwicHJvcFR3ZWVuIiwicmVzdG9yZURpc3BsYXkiLCJpc0JveCIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwicHJlZmlsdGVycyIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwidHdlZW5zIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwiZ290b0VuZCIsImJpbmQiLCJjb21wbGV0ZSIsInRpbWVyIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwib3B0Iiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYXR0ck5hbWVzIiwiZ2V0dGVyIiwibG93ZXJjYXNlTmFtZSIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInByb3BGaXgiLCJ0YWJpbmRleCIsImZvciIsImNsYXNzIiwic3RyaXBBbmRDb2xsYXBzZSIsImdldENsYXNzIiwiY2xhc3Nlc1RvQXJyYXkiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJjdXJWYWx1ZSIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzVmFsaWRWYWx1ZSIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInJyZXR1cm4iLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsImZvY3VzaW4iLCJyZm9jdXNNb3JwaCIsInN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImxhc3RFbGVtZW50IiwiZXZlbnRQYXRoIiwicGFyZW50V2luZG93Iiwic2ltdWxhdGUiLCJ0cmlnZ2VySGFuZGxlciIsImF0dGFjaGVzIiwicnF1ZXJ5IiwicGFyc2VYTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ0cmFkaXRpb25hbCIsInBhcmFtIiwicyIsInZhbHVlT3JGdW5jdGlvbiIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwicjIwIiwicmhhc2giLCJyYW50aUNhY2hlIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicmVzcG9uc2VzIiwiY3QiLCJmaW5hbERhdGFUeXBlIiwiZmlyc3REYXRhVHlwZSIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJjb252ZXJ0ZXJzIiwiYWpheENvbnZlcnQiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsImNvbnYyIiwiY3VycmVudCIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJ0aHJvd3MiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwidXJsIiwiaXNMb2NhbCIsInByb3RvY29sIiwicHJvY2Vzc0RhdGEiLCJhc3luYyIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsImpzb24iLCJhamF4U2V0dXAiLCJzZXR0aW5ncyIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwiYWpheCIsInRyYW5zcG9ydCIsImNhY2hlVVJMIiwicmVzcG9uc2VIZWFkZXJzU3RyaW5nIiwicmVzcG9uc2VIZWFkZXJzIiwidGltZW91dFRpbWVyIiwidXJsQW5jaG9yIiwiZmlyZUdsb2JhbHMiLCJ1bmNhY2hlZCIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImNyb3NzRG9tYWluIiwiaG9zdCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzdWNjZXNzIiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInZpc2libGUiLCJvZmZzZXRIZWlnaHQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib250aW1lb3V0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5Iiwic2NyaXB0QXR0cnMiLCJjaGFyc2V0Iiwic2NyaXB0Q2hhcnNldCIsImV2dCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJyZWN0Iiwid2luIiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJwcm94eSIsImhvbGRSZWFkeSIsImhvbGQiLCJwYXJzZUpTT04iLCJpc051bWVyaWMiLCJpc05hTiIsInRyaW0iLCJfalF1ZXJ5IiwiXyQiLCIkIiwibm9Db25mbGljdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztDQUFBOzs7Ozs7Ozs7Ozs7O0NBY0EsR0FBQyxVQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjs7Q0FHMUIsSUFBc0U7Ozs7Ozs7O0NBUXBFQyxNQUFBQSxjQUFBLEdBQWlCRixNQUFNLENBQUNHLFFBQVAsR0FDYkYsT0FBTyxDQUFDRCxNQUFELEVBQVMsSUFBVCxDQURNLEdBRWIsVUFBVUksQ0FBVixFQUFhO0NBQ1gsWUFBSSxDQUFDQSxDQUFDLENBQUNELFFBQVAsRUFBaUI7Q0FDZixnQkFBTSxJQUFJRSxLQUFKLENBQVUsMENBQVYsQ0FBTjtDQUNEOztDQUNELGVBQU9KLE9BQU8sQ0FBQ0csQ0FBRCxDQUFkO0NBQ0QsT0FQTDtDQVFELEtBbkJ5Qjs7Q0F3QjNCLEdBeEJELEVBd0JHLE9BQU9FLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDQyxjQXhCNUMsRUF3QmtELFVBQVVELE1BQVYsRUFBa0JFLFFBQWxCLEVBQTRCOztDQU81RSxRQUFJQyxHQUFHLEdBQUcsRUFBVjtDQUVBLFFBQUlDLFFBQVEsR0FBR0MsTUFBTSxDQUFDQyxjQUF0QjtDQUVBLFFBQUlDLEtBQUssR0FBR0osR0FBRyxDQUFDSSxLQUFoQjtDQUVBLFFBQUlDLElBQUksR0FBR0wsR0FBRyxDQUFDSyxJQUFKLEdBQ1AsVUFBVUMsS0FBVixFQUFpQjtDQUNmLGFBQU9OLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRSxJQUFULENBQWNELEtBQWQsQ0FBUDtDQUNELEtBSE0sR0FJUCxVQUFVQSxLQUFWLEVBQWlCO0NBQ2YsYUFBT04sR0FBRyxDQUFDUSxNQUFKLENBQVdDLEtBQVgsQ0FBaUIsRUFBakIsRUFBcUJILEtBQXJCLENBQVA7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
